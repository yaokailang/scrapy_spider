2019-07-25 14:24:54 [scrapy.utils.log] INFO: Scrapy 1.6.0 started (bot: applet_community)
2019-07-25 14:24:54 [scrapy.utils.log] INFO: Versions: lxml 4.3.4.0, libxml2 2.9.5, cssselect 1.0.3, parsel 1.5.1, w3lib 1.20.0, Twisted 19.2.1, Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)], pyOpenSSL 18.0.0 (OpenSSL 1.1.0i  14 Aug 2018), cryptography 2.3.1, Platform Windows-10-10.0.16299-SP0
2019-07-25 14:24:54 [scrapy.crawler] INFO: Overridden settings: {'BOT_NAME': 'applet_community', 'LOG_FILE': 'log.txt', 'NEWSPIDER_MODULE': 'applet_community.spiders', 'SPIDER_MODULES': ['applet_community.spiders']}
2019-07-25 14:24:54 [scrapy.extensions.telnet] INFO: Telnet Password: 903f36b221333fdc
2019-07-25 14:24:54 [scrapy.middleware] INFO: Enabled extensions:
['scrapy.extensions.corestats.CoreStats',
 'scrapy.extensions.telnet.TelnetConsole',
 'scrapy.extensions.logstats.LogStats']
2019-07-25 14:24:54 [scrapy.middleware] INFO: Enabled downloader middlewares:
['scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware',
 'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware',
 'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware',
 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware',
 'applet_community.middlewares.applet_communityDownloadMileware',
 'scrapy.downloadermiddlewares.retry.RetryMiddleware',
 'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware',
 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware',
 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware',
 'scrapy.downloadermiddlewares.cookies.CookiesMiddleware',
 'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware',
 'scrapy.downloadermiddlewares.stats.DownloaderStats']
2019-07-25 14:24:54 [scrapy.middleware] INFO: Enabled spider middlewares:
['scrapy.spidermiddlewares.httperror.HttpErrorMiddleware',
 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware',
 'scrapy.spidermiddlewares.referer.RefererMiddleware',
 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware',
 'scrapy.spidermiddlewares.depth.DepthMiddleware']
2019-07-25 14:24:54 [scrapy.middleware] INFO: Enabled item pipelines:
['applet_community.pipelines.AppletCommunityPipeline']
2019-07-25 14:24:54 [scrapy.core.engine] INFO: Spider opened
2019-07-25 14:24:54 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)
2019-07-25 14:24:54 [scrapy.extensions.telnet] INFO: Telnet console listening on 127.0.0.1:6023
2019-07-25 14:24:54 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1> (referer: None)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=2> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.dupefilters] DEBUG: Filtered duplicate request: <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=3> - no more duplicates will be shown (see DUPEFILTER_DEBUG to show all duplicates)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=10> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=6> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=9> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=4> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5265-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=3> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5380-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5265-1.html>
{'author': 'Rolan',
 'content': '你或许听说过，快速入门就是要学最小必要知识。而我最近在看微信小程序的官方教程时发现，这个教程虽然简单，但对于微信小程序开发来说，80%的套路都能从这里学习到，你的小程序从0到1可以从这里实现突破。在开始之前，先做100字的铺垫。一个页面 '
            '= 4个文件小程序的每个页面都是由4个文件组成的 ，前两个最重要，是我们的重头戏。先给这几个文件一个简短的解释：js '
            '文件——数据来源；wxml 文件——页面的骨架；wxss 文件——页面的装饰效果；json '
            '文件——可选，配置页面上的零件。另外，本文的目标读者是真心想要尝试小程序的无经验开发者，英语水平要求中学及格水平以上。另外，为了你可以动手跟着做，请下载微信开发工具并注册微信小程序。部分语言过于通俗是为了更好的理解。绑定数据现在就开始我们的第一个套路。小程序简易教程 '
            '-> 编写代码 -> 创建页面 -> 第二个代码块依照小程序的定义，小程序中的每个页面都包含一个js文件。在一个 js '
            '文件中，你需要列出这个页面上需要的数据（上图红框中的内容）。也就是说，data下面规定的数据（请努力去上图中找到 '
            'data），就是页面上需要用到的数据。这就叫做数据绑定。「数据绑定」对你来说可能是个新词汇。这里先不急着理解，我们的目标是会用，会用了就能理解一大半了。怎么应用「数据绑定」呢？只需要两步：1，声明；2，使用。声明的格式是这样的（类似上图中的内容）：Page({data: '
            "{greeting: 'Hello "
            "World'}//...})在微信开发工具中是这样的：注意看红框中的内容，和上面的代码块是一样的注意看 data "
            '那个部分，我声明了名字为greeting的数据。（所谓数据，学名应该叫变量，但在我们的教程里可以近似理解。）第二步是使用。使用的意思是，我们到页面上把这个数据显示出来。方法是这样的：{{greeting}}注意看{{ '
            '}}之间的部分，我们只需要把刚刚定义好的数据名称写在两个大括号里就行了。顺带一提，这种使用数据的方法，叫做八字胡方法（英文Mustache），因为加上的两个大括号可以想象成嘴上的胡子。或许记住了胡子，你就记住了这种使用方法。这就完成了我们的第一个套路——数据绑定。简单吧！但是这里有一个疑问，我们在哪里使用绑定好的数据呢？也就是问，在哪里使用{{greeting}}这句程序呢？答案是我们的页面上，也就是 '
            'wxml '
            '这个文件中。这就是我们的下一个套路——显示数据。显示数据上一个套路的讲解中，我们出现了这样一句程序{{greeting}}。这是在使用数据。但这行代码的完整版其实是这样的：<text '
            'class="your-class">{{greeting}}</text>在微信开发工具中的样子是这样的：还是看红框内的内容，也请注意这是在 '
            'wxml '
            '文件中我们对{{greeting}}这一部分已经熟悉，但对于它前面和后面的代码还不熟悉。所以我们现在进行讲解。显示数据时，我们其实希望显示出来的内容是很好看的。但如果你只写成{{greeting}}，显示出来的效果并不好：最左边红框中的文字一点装饰效果都没有为了让显示数据有更好看的效果，我们需要对{{greeting}}进行装饰。怎么装饰数据呢。我们要用2个东西：标签样式表什么是标签，我们从例子中来理解：{{greeting}}两边的<text '
            'class="your-class">和</text>就是标签，而且分别叫开始标签和结束标签。（你能发现开始标签和结束标签的区别么？）开始标签可以定义一些属性，以便调整显示的结果。这就像是你画一幅画可以选择用毛笔，来画出国画的效果。在上面的例子中，class="your-class"就是<text>这个标签的一个属性，<text>标签会表现出class="your-class"的规定的样子。那么class="your-class"这个属性的完整意思是什么呢？他的意思是<text>的 '
            'class '
            '对应样式表中的your-class。对，你可以把等号理解为对应。而后面的"your-class"就是我们在样式表中规定好的一种装饰效果。这里出现了我们的第2个工具：样式表。样式表是写在 '
            'wxss 文件中的，我们来看看怎么写：.your-class {display: flex;flex-direction: '
            'column;align-items: center;color: '
            'blue;}在开发者工具中的样子是这样的：你通过理解代码中英文的字面意思就可以了解到，我把字的 color '
            '定义为蓝色，把位置定义为 center。最重要的，是这个样式的名字，叫做.your-class，而<text>标签中的 class '
            '属性，正好指向这个样式，所以<text>中的数据会变成中间位置的蓝色字。（在.your-class的最前面有一个点，那是对应<text>中 '
            'class '
            '属性的特有标记，还有类似的标记[1]，可以在以后更多的实践中去理解)到这里，我们的前两个套路就已经简单的介绍完了。总结一下：绑定数据：在 '
            'js 文件中的 Page 模块下面定义 data 的名字，并用八字胡方法({{ }})来使用数据。显示数据：在 wxml '
            '中给数据加上标签（比如 text 标签），并且给标签加上属性（比如 class 属性）。class 对应的样式在 wxss '
            '文件中写好。不过，我们这里好像缺了什么。我好像没教大家怎么写最后一步的 wxss。微信文档说，wxss 和 css '
            '大体上都是一样的[2]。大家可以去找找css的书，或者期待我后续的实践教程，带你一步一步写一个能上线的小程序。现在，如果你把这两个套路循环用起来，已经能解决很多问题了。想要多显示一个数据，就先在 '
            'js文件中绑定这个数据，然后去 wxml 文件中装饰数据。下面是绑定两个数据的示例代码：Page({data: '
            "{greeting: 'Hello World',farewell: "
            "'Goodbye!'}//其他内容})而对应显示这两个数据的示例代码是这样的：<!--index.wxml--><text "
            'class="your-class">{{greeting}}</text><view '
            'class="your-class">{{farewell}}</view>在开发者工具中显示的样子是这样的：我在写教程的过程中升级了一次开发者工具，所以界面有变化大家可以看到，我在最右侧的红箭头处加入了一行新代码， '
            '然后显示出了新数据。但是，这次不一样的是，我用了一个叫做<view>的标签，而不是之前的<text>标签。其实 wxml '
            '文件中可以使用很多种标签来显示数据，有负责显示图片的，有可以负责滚动效果的的，他们都被写在微信文档中，你在实践的过程中可以查看。比如，我使用了一个叫做<icon>的标签，然后显示出了一个圆形的图标：有了「绑定数据」和「显示数据」这两个套路，我们已经能够写出一个简单的页面了。能够做到展示，但没有交互，所以我们进入第三个套路：绑定交互。绑定交互绑定交互这个名字听起来有没有和之前的「绑定数据」很像？他们的操作方法也很相似。绑定交互分为两步：声明：在 '
            'js 文件中声明交互的名称。使用：在 wxml '
            '文件中使用这个交互。先来看「声明」。怎么声明一个交互呢？（或者用微信文档的说法，怎么来声明一个事件呢？）请在 js '
            '文件中写下这样几行代码，就在我们之前绑定数据的 data 模块下面：changeWord: function() '
            "{this.setData({farewell: 'Never Say "
            "Goodbye!'})}在开发者工具中的样子是：这样，我们就声明了一个叫做changeWord的交互。这个交互的具体内容是，改变 "
            'farewell 这个数据的内容。原来是Goodbye!，现在我们要改成Never Say '
            'Goodbye!。而这个声明中function，this，setDate都是什么意思，我们在后面实践中再讲，大家关注的重点是这个声明中最前面的部分，也就是这个交互的名字：changeWord。我们已经声明完了这个交互，现在就该进入第2步——使用交互。请在 '
            'wxml 中插入这样的代码片段：<button bindtap="changeWord" type=\'primary\' '
            'class="your-button" '
            'size=\'default\'>改变文字</button>在开发者工具中的的样子是这样的：这里的重点是bindtap="changeWord"，大家可以看到我们刚刚声明的交互changeWord出现了，那前面的bingtap=是什么呢？他的意思是：把点击事件的交互对应到changeWord。当你点一下图中的那个绿色按钮，我们的页面就会把Goodbye!换为 '
            'Never Say '
            'Goodbye!除了利用标签的bindtap属性来绑定交互，还可以用bindlongtap（绑定长按事件），bindtouchmove（绑定触摸后移动事件）等等，他们都有各自的效果。具体内容都被写在事件相关的文档中，你可以亲自试一下。你会发现他们的开头都是 '
            'bind，就好像单词的前缀一样，加上tap，longtap等后缀，就能帮你绑定一个交互。（绑定事件的前缀还有另外一种，叫catch，比如catchtap，catchtouchmove等等，你可以结合文档，试验一下他们的效果）[3]到这里，我们已经能够简单的绑定交互了。但绑定交互的核心目的是要改变页面上的显示，从而给用户一个反馈。下面就让我们来看看第4个套路：修改显示。执行交互就像绑定数据之后，要去显示数据。我们绑定交互之后，也要让交互被执行，这样才有意义。而交互的执行内容，就写在被声明的交互的下面：changeWord: '
            'function() {// '
            '这里写交互的实际内容}我们这里介绍两种交互内容的写法，足够解决很多问题了：修改页面数据弹窗第一种，修改页面数据。我们在上一个套路的实例代码中已经见过：changeWord: '
            "function() {this.setData({farewell: 'Never Say "
            "Goodbye!'})}这几行代码中间的部分，就是要执行的交互内容：this.setData({farewell: 'Never "
            'Say '
            "Goodbye!'})即使你不懂得javaScript编程语言，也完全可以从英语的字面意思去理解这几行代码。这3行代码是在说，我这个页面(this)要修改数据(setData)中的farewell为 "
            'Never Say '
            'Goodbye!。如果你想修改其他数据，比如greeting，你可以如法炮制：changeAnotherWord: '
            "function() {this.setData({greeting: 'Hello, "
            "again!'})}你会发现这里面有很多结构是固定的。变化的部分只有交互的名称（变成了changeAnotherWord）和要修改的数据（变成了greeting: "
            "'Hello, "
            "again!'）。如果你也想修改页面上的数据，请如法炮制。我们要介绍的第二种交互方法是弹窗，而且是微信内建的弹窗。首先，还是要做一下绑定交互这个套路：1，在 "
            'js 文件中声明一个交互；2，在 wxml 中使用这个交互。声明交互的代码如下（在 js '
            '文件中），我们用showConfirmation作为名称： showConfirmation: function() {\r\n'
            ' var that = this\r\n'
            ' wx.showModal({\r\n'
            " title: '提示',\r\n"
            " content: '你确定要更改文字吗？',\r\n"
            ' showCancel: true,\r\n'
            " cancelText: '取消',\r\n"
            " confirmText: '确定',\r\n"
            ' success: function (response) { \r\n'
            ' that.changeWord()\r\n'
            ' }\r\n'
            ' })\r\n'
            ' }\r\n'
            '在微信开发者工具中是这样的：先不要在乎这里面陌生的代码，我们继续看使用交互的部分：<button '
            'bindtap="showConfirmation" type=\'primary\' class="your-button" '
            "size='default'>改变文字</button>我把上一个套路中出现的 button "
            '改写成了绑定到这个showConfirmation，在微信开发者工具中的样子是这样的：写完之后，我再去点「改变文字」的按钮，就会出现对话框：箭头连接的两部分是一样的，你发现了吗你会发现，所有的不一样，都只是在 '
            'js 文件中showConfirmation的下面，其他的部分都符合我们以前的套路。那我们就看看那段陌生的代码： var that '
            '= this\r\n'
            ' wx.showModal({\r\n'
            " title: '提示',\r\n"
            " content: '你确定要更改文字吗？',\r\n"
            ' showCancel: true,\r\n'
            " cancelText: '取消',\r\n"
            " confirmText: '确定',\r\n"
            ' success: function (response) { \r\n'
            ' that.changeWord()\r\n'
            ' }\r\n'
            ' })\r\n'
            '我们从wx.showModal看起，这是一个微信内建的代码表达方式，从英文的字面就能理解他是什么意思：请微信（wx）显示一下对话框（showModal）。那怎么用这个工具呢，微信的文档里面已经写好了：我们只需要像填空一样，把制作对话框需要的 '
            'title, content, showCancel '
            '等需要填充的地方填好就可以了。这样，微信会帮助我们制作出一个对话框。但在这段代码中，有一个比较难解释的地方，就是var that '
            '= '
            'this和that.changeWord()。你能猜到他们是联动的，因为他们都有一个that。具体的意思是：把这个页面存储在那个地方（var '
            'that = '
            'this），让那个地方的数据中的文字改变（that.changeWord()）。为了避免混乱，我们暂时解释到这里。而且这两行也不影响我们制作一个对话框。因为制作对话框只需要做一件事[4]：使用wx.showModal跳转到这里，我们已经能在一个页面上使用4个套路了：绑定数据，显示数据，绑定交互，修改数据。如果你的小程序比较复杂，那么，是时候跳转到下一个页面来开辟一片新战场。要跳转到下一个页面，我们只需要最后一个套路：跳转。跳转本质上也是一种交互，我们完全可以用上面提到的「绑定交互」和「执行交互」来实现。再重复一遍这两步：1，在 '
            'js 文件中声明一个交互；2，在 wxml 中使用这个交互。我们先在 js '
            '文件中声明一个名为navigateToLogs的交互：navigateToLogs: function() '
            '{wx.navigateTo({url: '
            "'/pages/logs/logs'})}在开发者工具中的样子是这样的：这里面有我们不太熟悉的代码，比如wx.navigateTo，根据上一个套路的经验，你已经能够大致猜到他的意思了，对么？不过我们还是把下一步走完再说。在 "
            'wxml 中使用这个交互：<button bindtap="navigateToLogs" type=\'default\' '
            'class="your-button" '
            "size='default'>跳转</button>在开发者工具中的样子是这样的：好了，现在，如果我们点一下「跳转」按钮，他就会跳到下一页。已经看完了效果，我们回来看那段不熟悉的代码：wx.navigateTo({url: "
            "'/pages/logs/logs'})这一次，我们依然可以从字面理解：请微信（wx）导航到（navigateTo）logs "
            "路径下的页面（url: '/pages/logs/logs'）。其中 url "
            "这个数据是微信要求的，在文档中可以找到他的说明，我们依然是照着文档来填空就可以了[5]。这里面有一点需要说明，新页面的地址叫做'/pages/logs/logs'，他是从哪里来的呢？大家看下图红框中的文件结构，会发现 "
            'logs 这个页面的地址就是 pages 文件夹下面的 logs 文件夹下面的 logs 文件（有4个文件，但都叫 '
            'logs），用标准的格式表示，就成了我们刚刚提到的/pages/logs/logs。更进一步，按照微信的规定，我们还需要把他写在一个叫做app.json的配置文件中，这样微信才允许我们跳转到那个路径。总结一下好了，到这里，我们把5个套路都学完了。如果你能把他们组合起来，不断使用，你就能制作一个用很多功能的小程序：绑定数据——在 '
            'js 文件中声明数据名称显示数据——在 wxml 中写出数据显示的位置，并在 wxss 中写出装饰效果绑定交互——在 js '
            '文件中声明交互的名称执行交互——在 js '
            '文件中支出要修改的数据或者显示弹窗跳转——跳转到下一页，开辟新的战场番外篇——调取微信数据微信小程序其实还有一个隐含套路，叫做调用微信提供的接口。用微信官方的话讲，就是使用微信的能力。如果没有这些能力，微信小程序只能叫小程序，而不能叫「微信」小程序。其实，我们已经在上面见过一些微信小程序的能力了，比如显示弹窗的wx.showModal，比如跳转下一页的wx.navigateTo你已经发现，他们的特点都是wx.开头。更多的能力还有，还有获取用户头像，打开扫一扫这样的能力。他们怎么用呢？其实都是查文档，看看这个方法需要你提供哪些数据，提供给他就好了。用两个字总结就是：填空。最后的最后，轻轻说一句，对于刚刚入门的开发者，最大的坑可能是——忘记保存。因为我曾经也是个新手，在很多领域依然是新手，甚至还没有入门。希望这份教程能帮到你。共勉。这种标记叫做选择器，可以在这个小程序 '
            'wxss '
            '文档的选择器那一节找到而且是个简版的css，不会用到复杂一点的级联样式另外，还有两类特殊的交互，为了避免大家混乱，我没有讲，但在我们后续的教程中会用到，感兴趣的朋友可以先了解一下：一类是某些标签特有的绑定方法，比如<checkbox-group>便签有一个特有属性 '
            'bindchange，可以用来绑定交互。另一类是用户关闭和打开页面时绑定的交互，比如onLoad，这类交互都是以 on '
            '开头的，代表这个页面的事件，直接在 js 文件中声明，不用再 wxml '
            '中绑定到标签。微信还有2个可用弹窗类交互，大家可以对照文档进行实验。微信出了提供wx.navigateTo这个跳转方法，还提供了其他4个导航相关的方法，你可以在实践中体会他们的区别。另外，微信还提供了<navigator>标签来实现跳转，跟wx.navigateTo等方法实现同样效果，为避免混乱，这里只留下文档地址，不详细举例。',
 'pub_time': '2019-6-21 00:17',
 'title': '5个套路看懂微信小程序开发 '}
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5381-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5385-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5380-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:55 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5379-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:55 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5381-1.html>
{'author': 'Rolan',
 'content': '程序日历组件\r\n'
            '闲来没事把之前想做的日历组件给做了 先上图\r\n'
            '\r\n'
            '参数\r\n'
            '\r\n'
            '        \r\n'
            '            参数\r\n'
            '            类型\r\n'
            '            说明\r\n'
            '            默认值\r\n'
            '        \r\n'
            '        \r\n'
            '            header\r\n'
            '            Boolean\r\n'
            '            是否显示头部操作栏\r\n'
            '            true\r\n'
            '        \r\n'
            '        \r\n'
            '            preMonth\r\n'
            '            Boolean\r\n'
            '            是否显示上个月按钮\r\n'
            '            true\r\n'
            '        \r\n'
            '         \r\n'
            '            nextMonth\r\n'
            '            Boolean\r\n'
            '            是否显示下个月按钮\r\n'
            '            true\r\n'
            '        \r\n'
            '         \r\n'
            '            preYear\r\n'
            '            Boolean\r\n'
            '            是否显示上一年按钮\r\n'
            '            false\r\n'
            '        \r\n'
            '         \r\n'
            '            nextYear\r\n'
            '            Boolean\r\n'
            '            是否显示下一年按钮\r\n'
            '            false\r\n'
            '        \r\n'
            '         \r\n'
            '            today\r\n'
            '            Boolean\r\n'
            '            是否显示今天按钮\r\n'
            '            false\r\n'
            '        \r\n'
            '        \r\n'
            '            weeks\r\n'
            '            Boolean\r\n'
            '            是否显示周标题\r\n'
            '            true\r\n'
            '        \r\n'
            '        \r\n'
            '            weeksType\r\n'
            '            String\r\n'
            '            周标题类型\r\n'
            '            cn\r\n'
            '        \r\n'
            '        \r\n'
            '            showMoreDays\r\n'
            '            Boolean\r\n'
            '            是否显示前后月份残余数据\r\n'
            '            false\r\n'
            '        \r\n'
            '        \r\n'
            '            formatType\r\n'
            '            String\r\n'
            '            日期连接符\r\n'
            '            -\r\n'
            '        \r\n'
            '    \r\n'
            '事件\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '事件名称\r\n'
            '说明\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            'select\r\n'
            '在选择日期时触发，返回选中的日期\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '示例\r\n'
            'index.wxml\r\n'
            '<calendar today="{{true}}" bind:select="select"></calendar>\r\n'
            '复制代码index.json\r\n'
            '"usingComponents": {\r\n'
            '        "calendar": "../../../components/calendar/index"\r\n'
            '    }\r\n'
            '复制代码index.js\r\n'
            'select(e) {\r\n'
            '        console.log(e)\r\n'
            '    },\r\n'
            '复制代码返回选中的日期 e.detail.value\r\n'
            '\r\n'
            '详细代码看github\r\n'
            'github',
 'pub_time': '2019-7-19 00:42',
 'title': '小程序日历组件 '}
2019-07-25 14:24:55 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5385-1.html>
{'author': 'Rolan',
 'content': '垃圾分类，从我做起最近垃圾分类比较火，各大城市纷纷开始实施垃圾分类制度，提高垃圾的资源价值和经济价值。但是垃圾分类不好记，然后我自己捣鼓了一款垃圾分类小程序，来帮助大家进行垃圾分类。:smile: '
            '做小程序的同时自己也学习了一波。小程序（垃圾的小窝）该程序实现了文字搜索，图像识别，查看分类等功能，非常具有实用性。下面贴几张图：暂时就贴这几张图了，想要了解更多，可以搜索\xa0'
            '垃圾的小窝\xa0'
            '或者扫小程序码体验。开发技术栈这次开发用到的技术栈有Taro+TS+Stylus，不得不说，框架还是比原生坑多的，如果不做多端的话不建议尝试框架。后续我可能会发布支付宝小程序端。希望大家能支持。小程序码欢迎大家体验:clap:并给出建议。源码地址：\xa0'
            'https://github.com/webpig/gar...',
 'pub_time': '2019-7-22 00:13',
 'title': '垃圾分类小程序 '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5379-1.html>
{'author': 'Rolan',
 'content': '在正文之前先大致描述下什么是cli工具，cli工具英文名command-line '
            'interface,也就是命令行交互接口，比较典型的几个case例如，create-react-app，vue-cli，具体可以去百度一下，下面gif是小打卡目前用的一套自动化发布工具:wrench:可以看到整个发布流程大致是以选择或默认项的形式实现，大致分析下面几步选择打包形式\xa0 \xa0 '
            '开发模式/debug模式/发布模式设置版本号填写发布信息选择环境是否提交版本commit是不是非常无脑？是不是再也不用担心线上发错环境了？有了它就算不同项目间，就算一天发n次版本还需要担心什么呢？当然除了简单的发布功能还，还可以做很多的事情，比如\xa0'
            '创建page/component模版\xa0等一些更多有趣的事情为了节约版面就不贴图了，具体可以看下仓库\xa0'
            'github.com/jinxuanzhen…\xa0'
            '（目前该工具是从小打卡现有的cli库中抽离的部分功能）明确痛点也就是我为什么要做这么一个工具，其实最开始我只是为了解决一个问题，就是在整个发布流程中需要人工去改动/确认发布环境和版本信息，大致可以想象下把线下环境发布到线上的尴尬处境后续发现从cli角度触发，很多东西都变得简单了，大致列了下：环境变量切换（线上环境，线下环境）创建启动模版，包括页面，组件自动化发布...准备工作本文会以快速创建页面模版文件为例教你怎么快速撸一个属于自己的cli工具，如果觉得自己做比较麻烦，可以clone下我的仓库自己改装下需要了解的三方库中间会用到一些第三方库commander\xa0'
            '，\xa0一个解析命令行命令和参数工具inquirer\xa0，常用交互式命令行用户界面的集合chalk\xa0'
            '，美化你的终端输出样式fuzzy，字符串模糊匹配的插件，根据输入关键词进行模糊匹配json-format，json美化/格式化工具其他的一些小知识：比如path模块，fs模块，大家可以去node官网自行查看：nodejs.org/api/搭建开发环境创建一个空文件夹，并且npm初始化, '
            '并且创建一个index.js页面，这个index.js将作为你整个包的入口文件npm init -y\r\n'
            '复制代码安装上述的三方包，当然也可以后续按需安装，这样更能清楚每个包是做什么的npm install '
            '@moyuyc/inquirer-autocomplete-prompt commander chalk commander '
            'fuzzy inquirer json-format --save\r\n'
            '复制代码在package.json里添加bin字段, 将自定义的命令软连到全局环境，同时执行npm '
            'link创建链接，这里如果报错{code EACCES，errno:13，...}，是因为权限不足，可以尝试sudo npm '
            'link"bin": {\r\n'
            '    "cli-demo": "./index.js"\r\n'
            '  }\r\n'
            '复制代码在入口文件，index.js 行首加入一行指定当前脚本由node.js进行解析#!/usr/bin/env '
            'node\t\t\t// 指定运行环境\r\n'
            '\r\n'
            '// 输出文本\r\n'
            "console.log('Hello World!!!');\r\n"
            '复制代码这时可以在命令行中执行\xa0cli-demo\xa0'
            '验收一下成果了ok，可以看到当在全局状态下输入自定义命令时，正确运行了入口文件，也就意味着的开发玩具已经搭建完成Let‘ '
            'Go整理逻辑以快速创建页面模版文件为例，就需要考虑需要哪些逻辑:设置页面名称找到已有模版文件copy到项目中修改app.json识别命令行在刚才的\xa0'
            'Hello World!!!\xa0'
            '环节，已经可以正确识别cli-demo，但是需要在一个cli工具中集成更多功能，可能需要有不同的执行策略，以git为例：\xa0'
            'git clone, git status，git push\xa0，所以需要识别不同的命令和参数，是时候就需要用到\xa0'
            'commander\xa0这个第三方包帮助解析命令行参数了，当然你也可以自己撸一个lib，本质上还是方便解析\xa0'
            'process.argvindex.js (本质上这个js就是一个路由)#!/usr/bin/env node\r\n'
            '\r\n'
            'const version                       = '
            "require('./package').version;                 // 版本号\r\n"
            '\r\n'
            '/* = package import\r\n'
            '-------------------------------------------------------------- '
            '*/\r\n'
            '\r\n'
            'const program                       = '
            "require('commander');                         // 命令行解析\r\n"
            '\r\n'
            '/* = task events\r\n'
            '-------------------------------------------------------------- '
            '*/\r\n'
            'const createProgramFs               = '
            "require('./lib/create-program-fs');           // 创建项目文件\r\n"
            '\r\n'
            '\r\n'
            '/* = config\r\n'
            '-------------------------------------------------------------- '
            '*/\r\n'
            '\r\n'
            '// 设置版本号\r\n'
            "program.version(version, '-v, --version');\r\n"
            '\r\n'
            '/* = deal receive command\r\n'
            '-------------------------------------------------------------- '
            '*/\r\n'
            '\r\n'
            'program\r\n'
            "    .command('create')\t\t\r\n"
            "    .description('创建页面或组件')\r\n"
            '    .action((cmd, options) => createProgramFs(cmd));\r\n'
            '\r\n'
            '/* 后续可以根据不同的命令进行不同的处理，可以简单的理解为路由 */\r\n'
            '// program\r\n'
            "//     .command('build [cli]')\r\n"
            "//     .description('执行打包构建')\r\n"
            '//     .action((cmd, env) => callback);\r\n'
            '\r\n'
            '/* = main entrance\r\n'
            '-------------------------------------------------------------- '
            '*/\r\n'
            'program.parse(process.argv)\r\n'
            '复制代码这时候当键入\xa0cli-demo create\xa0'
            '时会自动执行createProgramFscreateProgramFs.jsmodule.exports = function '
            '() {\r\n'
            "    console.log('Hi, create-program-fs.js');\r\n"
            '};\r\n'
            '复制代码命令行输入\xa0cli-demo create可以看到已经成功的\xa0开辟出了一块独立的业务模块\xa0'
            '，后续就只需要依据需求填补相应的内容即可创建交互命令收到执行命令，这个时候按第一张图，是需要开始一系列QA（当然你也可以不做交互式，直接配置命令行参数），引入三方包\xa0\xa0'
            'inquirer\xa0，来指定问题队列const question = [\r\n'
            '  \r\n'
            '    // 选择模式使用 page -> 创建页面 | component -> 创建组件\r\n'
            '    {\r\n'
            "        type: 'list',\r\n"
            "        name: 'mode',\r\n"
            "        message: '选择想要创建的模版',\r\n"
            '        choices: [\r\n'
            "            'page',\r\n"
            "            'component',\r\n"
            '        ]\r\n'
            '    },\r\n'
            '    \r\n'
            '    // 设置名称\r\n'
            '    {\r\n'
            "        type: 'input',\r\n"
            "        name: 'name',\r\n"
            '        message: answer => `设置 ${answer.mode} 名称 (e.g: '
            'index):`,\r\n'
            '    },\r\n'
            '];\r\n'
            '\r\n'
            'module.exports = function() {\r\n'
            '\t\r\n'
            '    // 问题执行\r\n'
            '    inquirer.prompt(question).then(answers => {\r\n'
            '\t\tconsole.log(answers);\r\n'
            '    });\r\n'
            '};\r\n'
            '复制代码、可以看到通过一系列QA交互，\xa0实际输出拿到的是一个json对象，第一步已完成创建模版文件创建一个\xa0'
            '存放模版文件的文件夹template\xa0'
            '，并准备好你希望的模版项目中使用模版文件为了方便阅读，下面的代码，需要明确下面变量的定义， Config.dir_root\xa0 '
            '= 命令行执行目录 Config.root\xa0 = cli项目根目录 Config.appRoot = 小程序项目路径 '
            'Config.template = '
            '模版目录这里有两个点，一个是执行路径的问题，另一个是分包的问题，具体如下：执行路径这里一定要弄明白**__dirname， '
            'process.cwd()**的区别，同时还有一些小程序是自己搭的gulp/webpack，可能小程序项目是在src目录下，一定要分清楚__dirname： '
            '被执行js文件的绝对路径，一般在index.js执行时缓存起来\xa0'
            '作为项目的全局路径，比如找到template文件夹就会使用\xa0'
            '${__dirname}/templateprocess.cwd()：当前\xa0命令行运行时的工作目录\xa0'
            '，比如在/Users/xuan/Documents/cli-demo如果当前项目在src，或其他文件夹里怎么办？可以提供一个给用户项目中的配置文件，类似于gulpfile.js或是webpack.config.js的形式，内容例如（具体可以看\xa0'
            'git仓库\xa0）module.exports = {\r\n'
            '\r\n'
            '    // 小程序路径\r\n'
            "    app: './src',\r\n"
            '\r\n'
            '    // 模版文件夹\r\n'
            "    template: './template'\r\n"
            '};\r\n'
            '复制代码可以看到对象中app属性，可以\xa0'
            '指定你当前小程序项目的路径分包因为小程序的分包机制会导致页面实际路径与在主包的路径不相符，例如：主包：pages/index/index分包：pages/main_module/pages/habit_enlist/habit_enlist解决这个问题一方面是要有页面创建要有一定的\xa0'
            '规范，统一格式\xa0，另一方面需要\xa0'
            '根据规则解析app.json，上面的主包，分包路径差不多是我目前使用的规范解析app.json// 获取app.json\r\n'
            'function getAppJson() {\r\n'
            "    let appJsonRoot = path.join(Config.appRoot, '/app.json');\r\n"
            '    try {\r\n'
            '        return require(appJsonRoot);\r\n'
            '    }catch (e) {\r\n'
            '        Log.error(`未找到app.json, 请检查当前文件目录是否正确，path: '
            '${appJsonRoot}`);\r\n'
            '        process.exit(1);\t\t\t// 异常退出\r\n'
            '    }\r\n'
            '}\r\n'
            '\r\n'
            '// 解析app.json\r\n'
            'let parseAppJson = () => {\r\n'
            '\r\n'
            '    // app Json 原文件\r\n'
            '    let appJson = __Data__.appJson = getAppJson();\r\n'
            '\r\n'
            '    // 获取主包页面\r\n'
            '    appJson.pages.forEach(path => '
            "__Data__.appPagesList[getPathSubSting(path)] = '');\r\n"
            '\r\n'
            '    // 获取分包，页面列表\r\n'
            '    appJson.subPackages.forEach(item => {\r\n'
            '        __Data__.appModuleList[getPathSubSting(item.root)] = '
            'item.root;\r\n'
            '        item.pages.forEach(path => '
            '__Data__.appPagesList[getPathSubSting(path)] = item.root);\r\n'
            '    });\r\n'
            '};\r\n'
            '\r\n'
            '// __Data__.appPagesList = 小程序全部页面\r\n'
            '// __Data__.appModuleList = 小程序全部分包页面\r\n'
            "// item结构 {util_module: 'pages/util_module/'}，这么定义结构是为了方便后续取数\r\n"
            '复制代码question队列里，增加删选分包的选项// 设置page所属module\r\n'
            '    {\r\n'
            "        type: 'autocomplete',\r\n"
            "        name: 'modulePath',\r\n"
            "        message: 'Set page ownership module',\r\n"
            '        choices: [],\r\n'
            '        suggestOnly: false,\r\n'
            '        source(answers, input) {\r\n'
            '            // none 代表放在主包\r\n'
            "            return Promise.resolve(fuzzy.filter(input, ['none', "
            '...Object.keys(__Data__.appModuleList)]).map(el => '
            'el.original));\r\n'
            '        },\r\n'
            '        filter(input) {\r\n'
            "            if (input === 'none') {\r\n"
            "                return '';\r\n"
            '            }\r\n'
            '            return __Data__.appModuleList[input];\r\n'
            '        },\r\n'
            '        when(answer) {\r\n'
            "            return answer.mode === 'page';\r\n"
            '        }\r\n'
            '    }\r\n'
            '复制代码autocomplete类型本质上是个列表，但是可以进行模糊查询，非常方便，像小打卡有接近30个分包的情况下效果尤为明显有了文件名，有了分包路径，有了可供copy的模版，接下来就很简单了，把模版文件塞进项目就可以了，下面是一串从仓库里copy的代码，利用async/await很方便的写出一维代码，基本上的流程:获取路径 '
            '-> 校验 -> 获取文件信息 -> 复制文件 -> 修改app.json -> 输出结果信息async function '
            "createPage(name, modulePath = '') {\r\n"
            '\r\n'
            '    // 获取模版文件路径\r\n'
            "    let templateRoot = path.join(Config.template, '/page');\r\n"
            '    if (!Util.checkFileIsExists(templateRoot)) {\r\n'
            '        Log.error(`未找到模版文件, 请检查当前文件目录是否正确，path: '
            '${templateRoot}`);\r\n'
            '        return;\r\n'
            '    }\r\n'
            '    \r\n'
            '    // 获取业务文件夹路径\r\n'
            '    let page_root = path.join(Config.appRoot, modulePath, '
            "'/pages', name);\r\n"
            '\r\n'
            '    // 查看文件夹是否存在\r\n'
            '    let isExists = await Util.checkFileIsExists(page_root);\r\n'
            '    if (isExists) {\r\n'
            '        Log.error(`当前页面已存在，请重新确认, path: ` + page_root);\r\n'
            '        return;\r\n'
            '    }\r\n'
            '\r\n'
            '    // 创建文件夹\r\n'
            '    await Util.createDir(page_root);\r\n'
            '\r\n'
            '    // 获取文件列表\r\n'
            '    let files = await Util.readDir(templateRoot);\r\n'
            '\r\n'
            '    // 复制文件\r\n'
            '    await Util.copyFilesArr(templateRoot, `${page_root}/${name}`, '
            'files);\r\n'
            '\r\n'
            '    // 填充app.json\r\n'
            '    await writePageAppJson(name, modulePath);\r\n'
            '\r\n'
            '    // 成功提示\r\n'
            '    Log.success(`createPage success, path: ` + page_root);\r\n'
            '}\r\n'
            '复制代码扩展一个基本的快速创建页面模版的cli工具就这样完成，但是有可能需要更多的一些功能自定义模版比如说每个项目的模版都有可能不太一样，很大程度上需要根据项目进行定制，这时候可能就需要前文提到的给用户开放config文件的插槽了项目中的config：// '
            'xdk.config.js\r\n'
            'module.exports = {\r\n'
            '\r\n'
            '    // 小程序路径\r\n'
            "    app: './',\r\n"
            '\r\n'
            '    // 模版文件夹\r\n'
            "    template: './template'\r\n"
            '};\r\n'
            '\r\n'
            '// create-program-fs.js\r\n'
            'module.exports = function() {\r\n'
            '\t\r\n'
            '     // 校验：当前是否存在配置文件\r\n'
            '    let customConfPath = `${Config.dir_root}/xdk.config.js`;\r\n'
            '    if (!Util.checkFileIsExists(customConfPath)) {\r\n'
            "        Log.error('当前项目尚未创建xdk.config.js文件');\r\n"
            '        return;\r\n'
            '    }\r\n'
            '\r\n'
            '    // 获取用户配置项\r\n'
            "    let {app, template = ''} = require(customConfPath);\r\n"
            '\r\n'
            '    // 小程序目录\r\n'
            '    Config.appRoot = path.resolve(path.join(Config.dir_root, '
            'app));\r\n'
            '\r\n'
            '    // 模版文件目录（默认使用cli提供的默认模版，当config文件有设置template路径时，使用自定义路径）\r\n'
            '    !!template && (Config.template = '
            'path.resolve(path.join(Config.dir_root, template))));\r\n'
            '    \r\n'
            '    // 问题执行\r\n'
            '    inquirer.prompt(question).then(answers => {\r\n'
            '\t\tconsole.log(answers);\r\n'
            '    });\r\n'
            '};\r\n'
            '复制代码发布的npm仓库目前从开发到调试本质上是在本地提供服务，利用npm '
            'link提供软连接到全局PATH，其实也可以直接发到npm上，让其他使用的该cli的成员一建安装，比如npm install -g '
            'xxxxxxx, '
            '具体教程的话百度，google有很多，作者表示很懒，遇到问题下面留言吧。。最后可以看到整个功能逻辑相对于平时写的复杂的业务逻辑来说相对简单，主要是工具库的一些使用方面的东西，中间的难点可能就是node中概念性的一些东西，然而这些多看一下文档基本就可以解决，希望大家可以从本文中了解到如何\xa0'
            '快速搭建一个属于自己的cli工具顺便预告下后续的话可能会更新一些如何利用cli工具做到自动化发布，版本号控制，环境变量切换，自动生成文档等一系列有趣的功能',
 'pub_time': '2019-7-19 00:12',
 'title': '1小时带你撸一个小程序cli脚手架 '}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5357-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=2)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5352-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=2)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5386-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5387-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5357-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5358-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=2)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5352-1.html>
{'author': 'Rolan',
 'content': '从技术的发展角度来看，微信小程序是从微信中的\xa0webView\xa0和\xa0JS-SDK\xa0'
            '进化到了今天的形态。那么，小程序和普通的\xa0h5\xa0'
            '页面到底有什么区别呢？运行环境：小程序基于浏览器内核重构的内置解析器，而\xa0h5\xa0'
            '的宿主环境是浏览器。所以小程序中没有\xa0DOM\xa0和\xa0BOM\xa0的相关\xa0API\xa0，\xa0'
            'jQuery\xa0和一些\xa0NPM\xa0'
            '包都不能在小程序中使用；系统权限：小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等；渲染机制：小程序的逻辑层和渲染层是分开的，而\xa0'
            'h5\xa0页面\xa0UI\xa0渲染跟\xa0JavaScript\xa0的脚本执行都在一个单线程中，互斥。所以\xa0'
            'h5\xa0页面中长时间的脚本运行可能会导致页面失去响应。其实，小程序开发过程中我们面对的是\xa0iOS\xa0和\xa0'
            'Android\xa0'
            '微信客户端和辅助开发的小程序开发者工具。根据官方文档，这三大运行环境也是有所区别的：运行环境逻辑层渲染层iOSJavaScriptCoreWKWebViewAndroidX5 '
            'JSCoreX5浏览器小程序开发者工具NWJSChrome WebView所以微信小程序介于\xa0web\xa0端和原生\xa0'
            'App\xa0之间，能够丰富调用功能接口，同时又跨平台。2. 小程序架构2.1 '
            '双线程模型小程序的渲染层和逻辑层分别由2个线程管理：渲染层：界面渲染相关的任务全都在\xa0WebView\xa0'
            '线程里执行。一个小程序存在多个界面，所以渲染层存在多个\xa0WebView\xa0线程。逻辑层：采用\xa0JsCore\xa0'
            '线程运行JS脚本。视图层和逻辑层通过系统层的\xa0WeixinJsBridage\xa0'
            '进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。（页面渲染的具体流程是：在渲染层，宿主环境会把\xa0'
            'WXML\xa0转化成对应的\xa0JS\xa0对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的\xa0'
            'setData\xa0'
            '方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面）双线程模型是小程序框架与业界大多数前端\xa0'
            'Web\xa0'
            '框架不同之处。基于这个模型，可以更好地管控以及提供更安全的环境。缺点是带来了无处不在的异步问题（任何数据传递都是线程间的通信，也就是都会有一定的延时），不过小程序在框架层面已经封装好了异步带来的时序问题。2.2 '
            '组件系统我们知道小程序是有自己的组件的，这些基本组件就是基于\xa0Exparser\xa0框架。\xa0Exparser\xa0'
            '基于\xa0WebComponents\xa0的\xa0ShadowDOM\xa0模型，但是不依赖浏览器的原生支持，而且可在 '
            '纯\xa0JS\xa0环境中运行。小程序中，所有节点树相关的操作都依赖于\xa0Exparser\xa0，包括\xa0'
            'WXML\xa0到页面最终节点树的构建、\xa0CreateSelectorQuery\xa0'
            '调用和自定义组件特性等。现在微信小程序也支持自定义组件了，用法和组件间通信类似于\xa0Vue\xa0。2.3 '
            '原生组件在内置组件中，有一些组件并不完全在\xa0Exparser\xa0'
            '的渲染体系下，而是由客户端原生参与组件的渲染。比如说\xa0Map\xa0组件。它渲染的层级比在\xa0WebView\xa0'
            '层渲染的普通组件要高。引入原生组件的优点是：Web\r\n'
            'WebView\r\n'
            'setData\r\n'
            '2.4 运行机制2.4.1 '
            '启动热启动：：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。2.4.2 '
            '销毁只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。2.5 '
            '更新机制开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 '
            '小时之内下发新版本信息到用户。小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。所以如果想让用户使用最新版本的小程序，可以利用\xa0'
            'wx.getUpdateManager\xa0做个检查更新的功能：checkNewVersion() {\r\n'
            '    const updateManager = wx.getUpdateManager();\r\n'
            '    updateManager.onCheckForUpdate((res) => {\r\n'
            "      console.log('hasUpdate', res.hasUpdate);\r\n"
            '      // 请求完新版本信息的回调\r\n'
            '      if (res.hasUpdate) {\r\n'
            '        updateManager.onUpdateReady(() => {\r\n'
            '          this.setData({\r\n'
            '            hasNewVersion: true\r\n'
            '          });\r\n'
            '        });\r\n'
            '      }\r\n'
            '    });\r\n'
            '  }\r\n'
            '复制代码微信小程序的基础底层架构大概就这么多，有机会再看看源码思考解析吧。',
 'pub_time': '2019-7-12 00:47',
 'title': '微信小程序底层架构 '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5386-1.html>
{'author': 'Rolan',
 'content': '关于网络通信，这里我使用的是wx.request,官方代码示例如下:wx.request({\r\n'
            "  url: 'test.php', //仅为示例，并非真实的接口地址\r\n"
            '  data: {\r\n'
            "    x: '',\r\n"
            "    y: ''\r\n"
            '  },\r\n'
            '  header: {\r\n'
            "    'content-type': 'application/json' // 默认值\r\n"
            '  },\r\n'
            '  success (res) {\r\n'
            '    console.log(res.data)\r\n'
            '  }\r\n'
            '})对于初学者而言，官方示例可能会看不怎么懂，所以我就以我自己当初项目驱动学习的方式(开发个人的记账小程序)来作为学习实例。以登录来说，效果图如下:此次示例包含表单校验和网络请求，代码如下:login.js// '
            'pages/login/login.js\r\n'
            'Page({\r\n'
            '\r\n'
            '  /**\r\n'
            '   * 页面的初始数据\r\n'
            '   */\r\n'
            '  data: {\r\n'
            '    username: "",\r\n'
            '    password: ""\r\n'
            '\r\n'
            '  },\r\n'
            '   register:function(e){\r\n'
            '    wx.navigateTo({\r\n'
            "      url: '../register/register'\r\n"
            '    })\r\n'
            '\r\n'
            '  },\r\n'
            '  formSubmit: function(e) {\r\n'
            '    console.log(e.detail.value.email);\r\n'
            '    console.log(e.detail.value.pwd)\r\n'
            '    var username = e.detail.value.email;\r\n'
            '    var password = e.detail.value.pwd;\r\n'
            '    var emailReg = '
            '/^[A-Za-z\\d]+([-_.][A-Za-z\\d]+)*@([A-Za-z\\d]+[-.])+[A-Za-z\\d]{2,4}$/;\r\n'
            '    if (username == null || username == "") {\r\n'
            '      wx.showToast({\r\n'
            '        title: "用户名不能为空",\r\n'
            "        icon: 'none',\r\n"
            '        duration: 1500\r\n'
            '      })\r\n'
            '    } else if (!emailReg.test(username)) {\r\n'
            '\r\n'
            '      wx.showToast({\r\n'
            '        title: "邮箱有误",\r\n'
            "        icon: 'none',\r\n"
            '        duration: 1500\r\n'
            '      })\r\n'
            '\r\n'
            '    } else if (password == null || password == "") {\r\n'
            '      wx.showToast({\r\n'
            '        title: "密码不能为空",\r\n'
            "        icon: 'none',\r\n"
            '        duration: 1500\r\n'
            '      })\r\n'
            '    } else {\r\n'
            '      wx.request({\r\n'
            '\r\n'
            '        url: getApp().globalData.urlPath + "sysUser/login",\r\n'
            '        method: "POST",\r\n'
            '        data: {\r\n'
            '          username: username,\r\n'
            '          password: password\r\n'
            '        },\r\n'
            '        header: {\r\n'
            '          "Content-Type": "application/x-www-form-urlencoded"\r\n'
            '        },\r\n'
            '        success: function(res) {\r\n'
            '          console.log(res.data);\r\n'
            '          if (res.statusCode == 200) {\r\n'
            '\r\n'
            '            //访问正常\r\n'
            '            if (res.data.code == "000000") {\r\n'
            '              wx.showToast({\r\n'
            '                title: "登陆成功",\r\n'
            "                icon: 'success',\r\n"
            '                duration: 2000,\r\n'
            '                success: function() {\r\n'
            '                  wx.navigateTo({\r\n'
            "                    url: '../manage/manage'\r\n"
            '                  })\r\n'
            '\r\n'
            '                  wx.setStorage({\r\n'
            "                    key: 'userId',\r\n"
            '                    data: res.data.user.userCode\r\n'
            '                  })\r\n'
            '\r\n'
            '                  wx.setStorage({\r\n'
            "                    key: 'userName',\r\n"
            '                    data: res.data.user.userName\r\n'
            '                  })\r\n'
            '                  console.log("test:" + '
            "wx.getStorageSync('userName'));\r\n"
            '                }\r\n'
            '              })\r\n'
            '\r\n'
            '            } else if (res.data.code == "111111") {\r\n'
            '              wx.showToast({\r\n'
            '                title: "密码错误",\r\n'
            "                icon: 'none',\r\n"
            '                duration: 1500\r\n'
            '              })\r\n'
            '            } else {\r\n'
            '              wx.showToast({\r\n'
            '                title: "该用户不存在",\r\n'
            "                icon: 'none',\r\n"
            '                duration: 1500\r\n'
            '              })\r\n'
            '            }\r\n'
            '          } else {\r\n'
            '\r\n'
            '            wx.showLoading({\r\n'
            "              title: '系统异常',\r\n"
            '              fail\r\n'
            '            })\r\n'
            '\r\n'
            '            setTimeout(function() {\r\n'
            '              wx.hideLoading()\r\n'
            '            }, 2000)\r\n'
            '          }\r\n'
            '\r\n'
            '        }\r\n'
            '      })\r\n'
            '    }\r\n'
            '\r\n'
            '  }\r\n'
            '})关于login.js，主要是写通信逻辑的，与咱们平时写js差异并不大，唯一不同的就是api长得不样罢了。关于其中的getApp().globalData.urlPath，相当于全局变量，不用我每次都写一大串https之类的。表单校验的效果如图:\xa0'
            '代码说明:显示消息提示框(相当于js的alert提示):wx.showToast({\r\n'
            '  title: "邮箱有误",\r\n'
            "  icon: 'none',\r\n"
            '  duration: 1500\r\n'
            '})获取input属性为name的值(相当于js中form.email.value,前提是这个表单name要为form，且form中的input要存在一个name=”email”)e.detail.value.email;跳转代码(相当于window.location.href):wx.navigateTo({\r\n'
            " url: '../manage/manage'\r\n"
            '})至于wx.request，我想只要是写过ajax的，都很好理解。login.json:{\r\n'
            '  "usingComponents": {}\r\n'
            '}关于这个login.json有什么用，我唯一想到的是页面的title(其实相当于html中的title)lgoin.wxml:<view '
            "class='container'>\r\n"
            "  <view class='header'>\r\n"
            '    <text>acs系统</text>\r\n'
            '  </view>\r\n'
            '    <view>\r\n'
            '    <text>\\n</text>\r\n'
            '  </view>\r\n'
            "  <view class='header'>\r\n"
            '  </view>\r\n'
            '  <form bindsubmit="formSubmit">\r\n'
            "    <view class='section'>\r\n"
            '      <text>用户名：</text>\r\n'
            '      <input type=\'text\' name="email" placeholder=\'请输入邮箱\' '
            '/>\r\n'
            '    </view>\r\n'
            "    <view class='section'>\r\n"
            '      <text>密码:</text>\r\n'
            '      <input password=\'password\' name="pwd" '
            "placeholder='请输入密码' />\r\n"
            '    </view>\r\n'
            "    <view class='button'>\r\n"
            "      <button type='primary' form-type='submit'>登录</button>\r\n"
            '      <text>\\n</text>\r\n'
            '       <view bindtap=\'register\' class="register">注册</view>\r\n'
            '    </view>\r\n'
            '  </form>\r\n'
            '\r\n'
            '</view>wxml相当于视图(如html或者模板语言(jsp、volocity、freemarker、beetl等))视图除了可以写一些标签之类的，还可以写一些逻辑判断。后面会讲到的。login.wxss:/* '
            'pages/login/login.wxss */\r\n'
            'form{\r\n'
            '  width: 310px;\r\n'
            '  height: 240px;\r\n'
            '  line-height: 40px;\r\n'
            '  /* border: 1px solid red;  */\r\n'
            '}\r\n'
            'input{\r\n'
            '  border: 1px solid #ccc;\r\n'
            '  width: 310px;\r\n'
            '  height: 40px;\r\n'
            '}\r\n'
            '.button{\r\n'
            '  margin-top: 20px;\r\n'
            '}\r\n'
            '.header text{\r\n'
            '  font-size: 25px;\r\n'
            '  color: #666;\r\n'
            '}\r\n'
            'form text{\r\n'
            '  font-size: 20px;\r\n'
            '  color: #666;\r\n'
            '}\r\n'
            '.register{\r\n'
            'color:black;\r\n'
            'display: block;\r\n'
            'width: 310px;\r\n'
            'height: 40px;\r\n'
            'border: 1px solid #ccc;\r\n'
            'text-align: center;\r\n'
            '}这个wxss就相当于css，定义视图的样式，决定视图长什么样(好看不好看)关于微信小程序网络通信，更多信息可以参考官方文档:wx.request',
 'pub_time': '2019-7-22 00:32',
 'title': '微信小程序之网络通信 '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5387-1.html>
{'author': 'Rolan',
 'content': 'getUserInfo较为特殊，不包含在本文范围内，主要针对需要授权的功能性api，例如：wx.startRecord，wx.saveImageToPhotosAlbum，\xa0'
            'wx.getLocation\r\n'
            '\r\n'
            '仓库地址：github.com/jinxuanzhen…\r\n'
            '\r\n'
            '背景\r\n'
            '小程序内如果要调用部分接口需要用户进行授权，例如获取地理位置信息，收获地址，录音等等，但是小程序对于这些需要授权的接口并不是特别友好，最明显的有两点：\r\n'
            '\r\n'
            '如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口 fail 回调，\r\n'
            '没有统一的错误信息提示，例如错误码\r\n'
            '\r\n'
            '一般情况而言，每次授权时都应该激活弹窗进行提示，是否进行授权，例如：\r\n'
            '\r\n'
            '而小程序内只有第一次进行授权时才会主动激活弹窗（微信提供的），其他情况下都会直接走fail回调，微信文档也在句末添加了一句请开发者兼容用户拒绝授权的场景这种未做兼容的情况下如果用户想要使用录音功能，第一次点击拒绝授权，那么之后无论如何也无法再次开启录音权限**，很明显不符合我们的预期。\r\n'
            '所以我们需要一个可以进行二次授权的解决方案\r\n'
            '\r\n'
            '常见处理方法\r\n'
            '\r\n'
            '官方demo\r\n'
            '下面这段代码是微信官方提供的授权代码, 可以看到也并没有兼容拒绝过授权的场景查询是否授权（即无法再次调起授权）\r\n'
            '// 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope\r\n'
            'wx.getSetting({\r\n'
            '  success(res) {\r\n'
            "    if (!res.authSetting['scope.record']) {\r\n"
            '      wx.authorize({\r\n'
            "        scope: 'scope.record',\r\n"
            '        success () {\r\n'
            '          // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n'
            '          wx.startRecord()\r\n'
            '        }\r\n'
            '      })\r\n'
            '    }\r\n'
            '  }\r\n'
            '})\r\n'
            '复制代码\r\n'
            '一般处理方式\r\n'
            '那么正常情况下我们该怎么做呢？以地理位置信息授权为例：\r\n'
            'wx.getLocation({\r\n'
            '   success(res) { \r\n'
            "      console.log('success', res);\r\n"
            '   },\r\n'
            '   fail(err) {\r\n'
            '      // 检查是否是因为未授权引起的错误\r\n'
            '      wx.getSetting({\r\n'
            '         success (res) {               \r\n'
            '            // 当未授权时直接调用modal窗进行提示\r\n'
            "            !res.authSetting['scope.userLocation'] && "
            'wx.showModal({\r\n'
            "               content: '您暂未开启权限，是否开启',\r\n"
            "               confirmColor: '#72bd4a',\r\n"
            '               success: res => {              \r\n'
            '                  // 用户确认授权后，进入设置列表\r\n'
            '                  if (res.confirm) {\r\n'
            '                     wx.openSetting({\r\n'
            '                        success(res){\r\n'
            '                           // 查看设置结果\r\n'
            '                           '
            "console.log(!!res.authSetting['scope.userLocation'] ? '设置成功' : "
            "'设置失败');\r\n"
            '                        },\r\n'
            '                     });\r\n'
            '                  }\r\n'
            '               }\r\n'
            '            });\r\n'
            '         }\r\n'
            '      });\r\n'
            '   }\r\n'
            '});\r\n'
            '复制代码上面代码，有些同学可能会对在fail回调里直接使用wx.getSetting有些疑问，这里主要是因为\r\n'
            '\r\n'
            '微信返回的错误信息没有一个统一code\r\n'
            'errMsg又在不同平台有不同的表现\r\n'
            '从埋点数据得出结论，调用这些api接口出错率基本集中在未授权的状态下\r\n'
            '\r\n'
            '这里为了方便就直接调用权限检查了 ，也可以稍微封装一下，方便扩展和复用，变成：\r\n'
            '  bindGetLocation(e) {\r\n'
            '        let that = this;\r\n'
            '        wx.getLocation({\r\n'
            '            success(res) {\r\n'
            "                console.log('success', res);\r\n"
            '            },\r\n'
            '            fail(err) {\r\n'
            "                that.__authorization('scope.userLocation');\r\n"
            '            }\r\n'
            '        });\r\n'
            '    },\r\n'
            '    bindGetAddress(e) {\r\n'
            '        let that = this;\r\n'
            '        wx.chooseAddress({\r\n'
            '            success(res) {\r\n'
            "                console.log('success', res);\r\n"
            '            },\r\n'
            '            fail(err) {\r\n'
            "                that.__authorization('scope.address');\r\n"
            '            }\r\n'
            '        });\r\n'
            '    },\r\n'
            '    __authorization(scope) {\r\n'
            '\t\t  \t/** '
            '为了节省行数，不细写了，可以参考上面的fail回调，大致替换了下变量res.authSetting[scope] **/ \r\n'
            '    }\r\n'
            '复制代码看上去好像没有什么问题，fail里只引入了一行代码，\r\n'
            '这里如果只针对较少页面的话我认为已经够用了，毕竟**‘如非必要，勿增实体’，但是对于小打卡这个小程序来说可能涉及到的页面，需要调用的场景偏多**，我并不希望每次都人工去调用这些方法，毕竟人总会犯错\r\n'
            '\r\n'
            '梳理目标\r\n'
            '上文已经提到了背景和常见的处理方法，那么梳理一下我们的目标，我们到底是为了解决什么问题？列了下大致为下面三点：\r\n'
            '\r\n'
            '兼容用户拒绝授权的场景，即提供二次授权\r\n'
            '解决多场景，多页面调用没有统一规范的问题\r\n'
            '在底层解决，业务层不需要关心二次授权的问题\r\n'
            '\r\n'
            '\r\n'
            '扩展wx[funcName]方法\r\n'
            '为了节省认知成本和减少出错概率，我希望他是这个api默认携带的功能，也就是说因未授权出现错误时自动调起是否开启授权的弹窗\r\n'
            '为了实现这个功能，我们可能需要对wx的原生api进行一层包装了（关于页面的包装可以看：如何基于微信原生构建应用级小程序底层架构）\r\n'
            '\r\n'
            '为wx.getLocation添加自己的方法\r\n'
            '这里需要注意的一点是直接使用常见的装饰模式是会出现报错，因为wx这个对象在设置属性时没有设置set方法，这里需要单独处理一下\r\n'
            '// 直接装饰，会报错 Cannot set property getLocation of #<Object> which '
            'has only a getter \r\n'
            'let $getLocation = wx.getLocation;\r\n'
            'wx.getLocation = function (obj) {\r\n'
            '    $getLocation(obj);\t\r\n'
            '};\r\n'
            '\r\n'
            '// 需要做一些小处理\r\n'
            'wx = {...wx};\t\t\t\t\t\t\t\t\t\t// \t对wx对象重新赋值\r\n'
            'let $getLocation = wx.getLocation;\r\n'
            'wx.getLocation = function (obj) {\t\t\t\t\t\r\n'
            "    console.log('调用了wx.getLocation');\r\n"
            '    $getLocation(obj);\t\r\n'
            '};\r\n'
            '\r\n'
            "// 再次调用时会在控制台打印出 '调用了wx.getLocation' 字样\r\n"
            'wx.getLocation()\r\n'
            '复制代码\r\n'
            '劫持fail方法\r\n'
            '第一步我们已经控制了wx.getLocation这个api，接下来就是对于fail方法的劫持，因为我们需要在fail里加入我们自己的授权逻辑\r\n'
            '// 方法劫持\r\n'
            'wx.getLocation = function (obj) {\r\n'
            '    let originFail = obj.fail;\r\n'
            '\r\n'
            '    obj.fail = async function (errMsg) {\r\n'
            '        // 0 => 已授权 1 => 拒绝授权 2 => 授权成功\r\n'
            '        let authState = await '
            "authorization('scope.userLocation');\r\n"
            '        \r\n'
            '        // 已授权报错说明并不是权限问题引起，所以继续抛出错误\r\n'
            '        // 拒绝授权，走已有逻辑，继续排除错误\r\n'
            '        authState !== 2 && originFail(errMsg);\r\n'
            '    };\r\n'
            '    $getLocation(obj);\r\n'
            '};\r\n'
            '\r\n'
            '// 定义检查授权方法\r\n'
            'function authorization(scope) {\r\n'
            '    return new Promise((resolve, reject) => {\r\n'
            '        wx.getSetting({\r\n'
            '            success (res) {\r\n'
            '                !res.authSetting[scope]\r\n'
            '                    ? wx.showModal({\r\n'
            "                        content: '您暂未开启权限，是否开启',\r\n"
            "                        confirmColor: '#72bd4a',\r\n"
            '                        success: res => {\r\n'
            '                            if (res.confirm) {\r\n'
            '                                wx.openSetting({\r\n'
            '                                    success(res){\r\n'
            '                                        !!res.authSetting[scope] '
            '? resolve(2) : resolve(1)\r\n'
            '                                    },\r\n'
            '                                });\r\n'
            '                            }else {\r\n'
            '                                resolve(1);\r\n'
            '                            }\r\n'
            '                        }\r\n'
            '                    })\r\n'
            '                    : resolve(0);\r\n'
            '            }\r\n'
            '        })\r\n'
            '    });\r\n'
            '}\r\n'
            '\r\n'
            '// 业务代码中的调用\r\n'
            '  bindGetLocation(e) {\r\n'
            '        let that = this;\r\n'
            '        wx.getLocation({\r\n'
            "            type: 'wgs84',\r\n"
            '            success(res) {\r\n'
            "                console.log('success', res);\r\n"
            '            },\r\n'
            '            fail(err) {\r\n'
            "                console.warn('fail', err);\r\n"
            '            }\r\n'
            '        });\r\n'
            '  }\r\n'
            '\r\n'
            '复制代码可以看到现在已实现的功能已经达到了我们最开始的预期，即因授权报错作为了wx.getLocation默认携带的功能，我们在业务代码里再也不需要处理任何再次授权的逻辑\r\n'
            '也意味着wx.getLocation这个api不论在任何页面，组件，出现频次如何，**我们都不需要关心它的授权逻辑（**效果本来想贴gif图的，后面发现有图点大，具体效果去git仓库跑一下demo吧）\r\n'
            '\r\n'
            '让我们再优化一波\r\n'
            '上面所述大致是整个原理的一个思路，但是应用到实际项目中还需要考虑到整体的扩展性和维护成本，那么就让我们再来优化一波\r\n'
            '代码包结构：本质上只要在app.js这个启动文件内，引用./x-wxx/index文件对原有的wx对象进行覆盖即可\r\n'
            '\r\n'
            '**简单的代码逻辑：\xa0**\r\n'
            '// 大致流程：\r\n'
            '\r\n'
            '//app.js\r\n'
            "wx = require('./x-wxx/index');\t\t\t\t\t\t// 入口处引入文件\r\n"
            '\r\n'
            '// x-wxx/index \r\n'
            "const apiExtend = require('./lib/api-extend')；\r\n"
            'module.exports = (function (wxx) {\t\t\t\t    // 对原有方法进行扩展\r\n'
            '    wxx = {...wxx};\r\n'
            '    for (let key in wxx) {\r\n'
            '        !!apiExtend[key] && (()=> {\r\n'
            '\r\n'
            '            // 缓存原有函数\r\n'
            '            let originFunc = wxx[key];\r\n'
            '\r\n'
            '            // 装饰扩展的函数\r\n'
            '            wxx[key] = (...args) => apiExtend[key](...args, '
            'originFunc);\r\n'
            '        })();\r\n'
            '    }\r\n'
            '    return wxx;\r\n'
            '})(wx);\r\n'
            '\r\n'
            '// lib/api-extend\r\n'
            "const Func = require('./Func');\r\n"
            '(function (exports) {\t\t\t\t\t\t\t\t// 需要扩展的api（类似于config）\r\n'
            '    // 获取权限\r\n'
            '    exports.authorize = function (opts, done) {\r\n'
            '        // 当调用为"确认授权方法时"直接执行，避免死循环\r\n'
            "        if (opts.$callee === 'isCheckAuthApiSetting') {\r\n"
            "            console.log('optsopts', opts);\r\n"
            '            done(opts);\r\n'
            '            return;\r\n'
            '        }\r\n'
            '        Func.isCheckAuthApiSetting(opts.scope, () => '
            'done(opts));\r\n'
            '    };\r\n'
            '\r\n'
            '    // 选择地址\r\n'
            '    exports.chooseAddress = function (opts, done) {\r\n'
            "        Func.isCheckAuthApiSetting('scope.address', () => "
            'done(opts));\r\n'
            '    };\r\n'
            '\r\n'
            '    // 获取位置信息\r\n'
            '    exports.getLocation = function (opts, done) {\r\n'
            "        Func.isCheckAuthApiSetting('scope.userLocation', () => "
            'done(opts));\r\n'
            '    };\r\n'
            '\r\n'
            '    // 保存到相册\r\n'
            '    exports.saveImageToPhotosAlbum = function (opts, done) {\r\n'
            "        Func.isCheckAuthApiSetting('scope.writePhotosAlbum', () "
            '=> done(opts));\r\n'
            '    }\r\n'
            '\r\n'
            '    // ...more\r\n'
            '})(module.exports);\r\n'
            '复制代码\r\n'
            '更多的玩法\r\n'
            '可以看到我们无论后续扩展任何的微信api，都只需要在lib/api-extend.js '
            '配置即可，这里不仅仅局限于授权，也可以做一些日志，传参的调整，例如：\r\n'
            ' // 读取本地缓存(同步)\r\n'
            'exports.getStorageSync = (key, done) => {\r\n'
            '        let storage = null;\r\n'
            '        try {\r\n'
            '            storage = done(key);\r\n'
            '        } catch (e) {\r\n'
            "            wx.$logger.error('getStorageSync', {msg: e.type});\r\n"
            '        }\r\n'
            '        return storage;\r\n'
            '};\r\n'
            '复制代码这样是不是很方便呢，至于Func.isCheckAuthApiSetting这个方法具体实现，为了节省文章行数请自行去git仓库里查看吧\r\n'
            '\r\n'
            '关于音频授权\r\n'
            '录音授权略为特殊，以wx.getRecorderManager为例，它并不能直接调起录音授权，所以并不能直接用上述的这种方法，不过我们可以曲线救国，达到类似的效果，还记得我们对于wx.authorize的包装么，本质上我们是可以直接使用它来进行授权的，比如将它用在我们已经封装好的录音管理器的start方法进行校验\r\n'
            'wx.authorize({\r\n'
            "   scope: 'scope.record'\r\n"
            '});\r\n'
            '复制代码实际上，为方便统一管理，Func.isCheckAuthApiSetting方法其实都是使用wx.authorize来实现授权的\r\n'
            'exports.isCheckAuthApiSetting = async function(type, cb) {\r\n'
            '\r\n'
            '        // 简单的类型校验\r\n'
            "        if(!type && typeof type !== 'string') return;\r\n"
            '\r\n'
            '        // 声明\r\n'
            '        let err, result;\r\n'
            '\r\n'
            '        // 获取本地配置项\r\n'
            '        [err, result] = await to(getSetting());         // '
            '这里可以做一层缓存，检查缓存的状态，如果已授权可以不必再次走下面的流程，直接return出去即可\r\n'
            '        if (err) {\r\n'
            "            return cb('fail');\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n"
            '        }\r\n'
            '\r\n'
            '        // 当授权成功时，直接执行\r\n'
            '        if (result.authSetting[type]) {\r\n'
            "            return cb('success');\r\n"
            '        }\r\n'
            '\r\n'
            '        // 调用获取权限\r\n'
            '        [err, result] = await to(authorize({scope: type, $callee: '
            "'isCheckAuthApiSetting'}));\r\n"
            '        if (!err) {\r\n'
            "            return cb('success');\r\n"
            '        }\r\n'
            '}\r\n'
            '复制代码\r\n'
            '关于用户授权\r\n'
            '用户授权极为特殊，因为微信将wx.getUserInfo升级了一版，没有办法直接唤起了，详见《公告》，所以需要单独处理，关于这里会拆出单独的一篇文章来写一些有趣的玩法\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '总结\r\n'
            '最后稍微总结下，通过上述的方案，我们解决了最开始目标的同时，也为wx这个对象上的方法提供了统一的装饰接口（lib/api-extend文件），便于后续其他行为的操作比如埋点，日志，参数校验\r\n'
            '还是那么一句话吧，小程序不管和web开发有多少不同，本质上都是在js境上进行开发的，希望小程序的社区环境更加活跃，带来更多有趣的东西',
 'pub_time': '2019-7-22 00:42',
 'title': '小程序开发另类小技巧 --用户授权篇 '}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5359-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=2)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5358-1.html>
{'author': 'Rolan',
 'content': '需求背景在最近的项目中，使用了transition和定时器实现了随机走动物体的功能，走动的物体还会有animation的动画。我发现在手机中，按home键或者切换应用，使页面不在屏幕中，也就是页面不可见，过一段时间切回来，会出现物体移动但是没有播放animaiton的动画的情况。我就想到了visibilitychange。结合react使用，添加类似onShow/onHide生命周期额外生命周期浏览器document有个visibilitychange的事件，由于存在兼容性问题，所以代码里也做了兼容处理。该事件会在document.visibilityState发生变化时触发，visibilityState有两个状态值——visible和hidden，表示页面是否在屏幕当中。let '
            'changeState;\r\n'
            'let visibilityChange;\r\n'
            '\r\n'
            "if (typeof document.hidden !== 'undefined') {\r\n"
            "    visibilityChange = 'visibilitychange';\r\n"
            "    changeState = 'visibilityState';\r\n"
            "} else if (typeof document.mozHidden !== 'undefined') {\r\n"
            "    visibilityChange = 'mozvisibilitychange';\r\n"
            "    changeState = 'mozVisibilityState';\r\n"
            "} else if (typeof document.msHidden !== 'undefined') {\r\n"
            "    visibilityChange = 'msvisibilitychange';\r\n"
            "    changeState = 'msVisibilityState';\r\n"
            "} else if (typeof document.webkitHidden !== 'undefined') {\r\n"
            "    visibilityChange = 'webkitvisibilitychange';\r\n"
            "    changeState = 'webkitVisibilityState';\r\n"
            '}知道了当前浏览器的状态属性和事件名称后，就可以添加时间监听了。const visibleCallbackList = '
            '[];\r\n'
            'const hiddenCallbackList = [];\r\n'
            '\r\n'
            'document.addEventListener(\r\n'
            '    visibilityChange,\r\n'
            '    () => {\r\n'
            "        if (document[changeState] === 'visible') {\r\n"
            '            for (let i = 0; i < visibleCallbackList.length; i++) '
            '{\r\n'
            "                if (typeof visibleCallbackList[i] === 'function') "
            '{\r\n'
            '                    visibleCallbackList[i]();\r\n'
            '                }\r\n'
            '            }\r\n'
            "        } else if (document[changeState] === 'hidden') {\r\n"
            '            for (let i = 0; i < hiddenCallbackList.length; i++) '
            '{\r\n'
            "                if (typeof hiddenCallbackList[i] === 'function') "
            '{\r\n'
            '                    hiddenCallbackList[i]();\r\n'
            '                }\r\n'
            '            }\r\n'
            '        }\r\n'
            '    },\r\n'
            '    false\r\n'
            ');上述代码中，维护了两个数组，分别代表页面进入可见状态时需要执行的回调列表和进入不可见状态时需要执行的回调列表。这两个列表在下面会讲到。因为我们是使用react开发，所以想在组件级别做到该组件是否能使用该功能，所以想到让组件具有类似小程序的onShow和onHide的生命周期，在这个生命周期中执行组件内部的逻辑。export '
            'const h5OnShow = callback => {\r\n'
            '    visibleCallbackList.push(callback);\r\n'
            '};\r\n'
            '\r\n'
            'export const h5OnHide = callback => {\r\n'
            '    hiddenCallbackList.push(callback);\r\n'
            '};\r\n'
            '\r\n'
            '/**\r\n'
            ' *\r\n'
            ' * @param {Object}\r\n'
            ' *   {Function} h5OnShowCallback h5需要注销的显示回调\r\n'
            ' *   {Function} h5OnHideCallback h5需要注销的隐藏回调\r\n'
            ' */\r\n'
            'export const h5ExtraLifecycleWillUnmount = ({ h5OnShowCallback, '
            'h5OnHideCallback }) => {\r\n'
            '    if (h5OnShowCallback) {\r\n'
            '        '
            'visibleCallbackList.splice(visibleCallbackList.indexOf(h5OnShowCallback), '
            '1);\r\n'
            '    }\r\n'
            '    if (h5OnHideCallback) {\r\n'
            '        '
            'hiddenCallbackList.splice(hiddenCallbackList.indexOf(h5OnHideCallback), '
            '1);\r\n'
            '    }\r\n'
            '\r\n'
            '};如上述代码中，h5OnShow方法中将传入的callback '
            'push至visibleCallbackList数组，h5OnHide方法将callback '
            'push到hiddenCallbackList。h5ExtraLifecycleWillUnmount是在组件即将要卸载的时候调用，将回调列表里的方法删除。额外生命周期的使用componentDidMount() '
            '{\r\n'
            '        h5OnShow(this.pageShow);\r\n'
            '        h5OnHide(this.pageHide);\r\n'
            '    }\r\n'
            '    componentWillUnmount() {\r\n'
            '        h5ExtraLifecycleWillUnmount({\r\n'
            '            h5OnShowCallback: this.pageShow,\r\n'
            '            h5OnHideCallback: this.pageHide\r\n'
            '        });\r\n'
            '    }\r\n'
            '    pageShow = () => {\r\n'
            '        // 开启随机走动定时器\r\n'
            '    }\r\n'
            '    pageHide = () => {\r\n'
            '        // 关闭随机走动定时器\r\n'
            '    '
            '}在组件里，注册onSHow和onHide，在页面显示时开启定时器，在页面隐藏时关闭定时器并把transition设置为none，这样在页面不可见时不会做无用的逻辑处理，这也是符合用户的预期，因为页面隐藏时并不关心在这期间做了生命动画变更。可优化点：1.visibleCallbackList和hiddenCallbackList使用WeakSet更好，保证了不会出现内存泄漏。2.如果组件实例化多次，pageShow和pageHide使用箭头函数并不友好，可使用修饰器模式改变原型上的方法的this指向。',
 'pub_time': '2019-7-15 00:23',
 'title': '页面可见与不可见的事件——visibilitychange '}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5360-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=2)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5365-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=2)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5359-1.html>
{'author': 'Rolan',
 'content': '问题来源最近工作需要写小程序页面，其中有个页面情况为：父页面中包含了一个组件页面，组件页面中又包含了另外一个组件页面。需求为：点击最后一个组件页面中的一个view，需要显示最外层父页面中的一个弹出层，并且动态的展示值，这个值的来源就是最后一个组件页面中的内容。处理办法当时想到的就是使用全局变量，在 '
            'app.js '
            '中定义好全局变量，点击组件页面时就修改全局变量的值，父页面同样使用全局变量的值，这样一来就可以动态打开/关闭弹出层且传递值了。下面先看看 '
            'app.js 中怎么定义的：globalData: {\r\n'
            "    openid: '',\r\n"
            '    userInfo: null,\r\n'
            '    _showPictureDetail: false,\r\n'
            "    _pictureTime: '',\r\n"
            "    _pictureAddress: '',\r\n"
            '    //改变量用户存放全局变量修改过程中的值传递, 传递对象\r\n'
            '    data: {}\r\n'
            '  }在其他页面就使用 getApp().globalData.参数名 = 值 的形式来改变参数值， 使用 '
            'getApp().globalData.参数名 '
            '的形式来获取值。这样能正常赋值，但是由于都是在同一个界面展示，我需要更新值后，马上得到最新的值。上面简单的设置获取就不起作用了。那么，就需要监听 '
            'globalData 中的属性了。首先是 app.js：//app 全局属性监听\r\n'
            '  watch: function (method) {\r\n'
            '    var obj = this.globalData;\r\n'
            '    Object.defineProperty(obj, "data", {  //这里的 data 对应 上面 '
            'globalData 中的 data\r\n'
            '      configurable: true,\r\n'
            '      enumerable: true,\r\n'
            '      set: function (value) {  //动态赋值，传递对象，为 globalData '
            '中对应变量赋值\r\n'
            '        this._showPictureDetail = value.showPictureDetail;\r\n'
            '        this._pictureTime = value.pictureTime;\r\n'
            '        this._pictureAddress = value.pictureAddress;\r\n'
            '        method(value);\r\n'
            '      },\r\n'
            '      get: function () {  //获取全局变量值，直接返回全部\r\n'
            '        return this.globalData;\r\n'
            '      }\r\n'
            '    })\r\n'
            '  },接下来就是在组件页面事件中动态赋值：//图片拍摄详情查看\r\n'
            '    viewPictureDetailInfo: function (e) {\r\n'
            '      // 修改 app 全局属性值， 由于 globalData.data '
            '是个对象，因为涉及到修改多个参数，所以需要传递对象\r\n'
            '      app.globalData.data = {\r\n'
            "        '_showPictureDetail': true,\r\n"
            "        '_pictureTime': e.currentTarget.dataset.phototime,\r\n"
            "        '_pictureAddress': e.currentTarget.dataset.address\r\n"
            '      }\r\n'
            '    },最后就是在最外层父页面添加 app.js 监听回调，动态修改变量值，以达到动态打开/关闭弹出层和展示内容了：// '
            '首先需要在父页面 onLoad() 方法中添加监听以及指定监听回调方法\r\n'
            '// 设置 App 监听回调\r\n'
            '// 如果其他页面修改了 app.js 中的 showPictureDetail 值, 就会触发回调\r\n'
            'getApp().watch(self.watchBack)\r\n'
            '\r\n'
            '//定义监听回调方法\r\n'
            '//app 监听回调方法\r\n'
            '  watchBack: function (value) {  //这里的value 就是 app.js 中 watch '
            '方法中的 set, 返回整个 globalData\r\n'
            '    this.setData({\r\n'
            '      showPictureDetail: value._showPictureDetail,\r\n'
            '      pictureTime: value._pictureTime,\r\n'
            '      pictureAddress: value._pictureAddress\r\n'
            '    });\r\n'
            '  },这样，在父页面中使用 '
            'showPictureDetail..这几个变量就可以动态展示了。PS：我这边的业务需求涉及到多个变量的监听，如果你只有一个变量的监听，那么只需要修改 '
            'app.js 中 watch 方法的 Object.defineProperty '
            '内容由对象传递变为单个值传递即可。在更新值和获取值时传递就是一个值，而不是对象。',
 'pub_time': '2019-7-15 00:58',
 'title': '微信小程序全局变量改变监听 '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5365-1.html>
{'author': 'Rolan',
 'content': '前言微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能。在小程序内可调用微信的API完成支付功能，方便、快捷。小程序开发者在开发小程序时，支付流程是必然要接触到，今天胡哥就小程序支付的全流程为大家一一细说，让小伙伴能快速得掌握小程序支付能力，避免踩坑！知己知彼，方能百战不殆 '
            '- '
            '小程序支付流程图举个栗子:chestnut:：某用户小明在某电商小程序上购买一块肥皂，从浏览、下单到支付经历了什么样的过程呢？打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单wx.login获取用户临时登录凭证code，发送到后端服务器换取openId在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付小结进行微信支付，在小程序端我们主要做三件事：注：服务端调用统一下单API、签名算法不再本次分享讨论范围内，请期待胡哥的另外一次分享。使用\xa0'
            'wx.login\xa0获取临时登录凭证code,发送到后端获取openIdwx.login({\r\n'
            '  success (res) {\r\n'
            '    if (res.code) {\r\n'
            '      // 发起请求，换取openId\r\n'
            '      wx.request({\r\n'
            "        url: '',\r\n"
            '        data: {\r\n'
            '          code: res.code\r\n'
            '        }\r\n'
            '      })\r\n'
            '    }\r\n'
            '  }\r\n'
            '})将\xa0openId\xa0以及相应需要的商品信息发送到后端，换取服务端进行的签名等信息wx.request({\r\n'
            "  url: '',\r\n"
            '  data: {\r\n'
            "    openId: '',\r\n"
            '    num: 1,\r\n'
            "    id: '111'\r\n"
            '  }\r\n'
            '})接收返回的信息（必须要包含发起微信支付\xa0wx.requestPayment的参数\xa0'
            '），发起微信支付wx.requestPayment({\r\n'
            '  // 时间戳\r\n'
            "  timeStamp: '',\r\n"
            '  // 随机字符串\r\n'
            "  nonceStr: '',\r\n"
            '  // 统一下单接口返回的 prepay_id 参数值\r\n'
            "  package: '',\r\n"
            '  // 签名类型\r\n'
            "  signType: '',\r\n"
            '  // 签名\r\n'
            "  paySign: '',\r\n"
            '  // 调用成功回调\r\n'
            '  success () {},\r\n'
            '  // 失败回调\r\n'
            '  fail () {},\r\n'
            '  // 接口调用结束回调\r\n'
            '  complete () {}\r\n'
            '})注意：以上信息中\xa0timeStamp\xa0、\xa0nonceStr\xa0、\xa0prepay_id\xa0'
            '、\xa0signType\xa0、\xa0paySign\xa0'
            '各参数均建议必须都由服务端返回（这样会尽最大可能性保证签名数据一致性），小程序端不做任何处理基于Taro的微信支付实例import '
            "Taro, { Component } from '@tarojs/taro'\r\n"
            "import { View, Text, Button } from '@tarojs/components'\r\n"
            "import './index.scss'\r\n"
            '\r\n'
            'export default class Index extends Component {\r\n'
            '\r\n'
            '  config = {\r\n'
            "    navigationBarTitleText: '首页'\r\n"
            '  }\r\n'
            '\r\n'
            '  componentWillMount () { }\r\n'
            '\r\n'
            '  async componentDidMount () { \r\n'
            '  }\r\n'
            '\r\n'
            '  componentWillUnmount () { }\r\n'
            '\r\n'
            '  componentDidShow () { }\r\n'
            '\r\n'
            '  componentDidHide () { }\r\n'
            '\r\n'
            '  /**\r\n'
            '   * sendOrderInfo()\r\n'
            '   * @description 提交订单信息，获取支付凭证，唤起支付\r\n'
            '   */\r\n'
            '  async sendOrderInfo () {\r\n'
            '    // 获取临时登录凭证code\r\n'
            '    let codeData = await Taro.login()\r\n'
            '    // 换取openId\r\n'
            "    let openId = ''\r\n"
            '    if (codeData.code) {\r\n'
            '      let res = await Taro.request({\r\n'
            '        // 定义的后端换取openId的接口\r\n'
            "        url: 'https://www.justbecoder.com/getLogin',\r\n"
            '        data: {\r\n'
            '          code: codeData.code\r\n'
            '        }\r\n'
            '      })\r\n'
            '      if (res && res.code === 0) {\r\n'
            '        openId = res.openId\r\n'
            '      }\r\n'
            '    }\r\n'
            '    // 发送openId以及对应的商品信息\r\n'
            '    let data = await Taro.requrest({\r\n'
            "      url: 'https://www.justbecoder.com/createdOrder',\r\n"
            '      data: {\r\n'
            '        openId,\r\n'
            '        // 实际情况的商品数量\r\n'
            '        num: 1,\r\n'
            '        // 实际情况的商品Id\r\n'
            '        id: 111,\r\n'
            '      }\r\n'
            '    })\r\n'
            '    // code === 0 表示提交订单成功，返回需要的签名信息等\r\n'
            '    if (data && data.code === 0) {\r\n'
            '      let {\r\n'
            '        timeStamp,\r\n'
            '        nonceStr,\r\n'
            '        prepay_id,\r\n'
            '        signType,\r\n'
            '        paySign\r\n'
            '      } = data.payInfo\r\n'
            '      // 唤起支付，按小程序要求格式发送参数\r\n'
            '      let payData = await Taro.requestPayment({\r\n'
            '        timeStamp,\r\n'
            '        nonceStr,\r\n'
            "        package: 'prepay_id=' + prepay_id,\r\n"
            '        signType,\r\n'
            '        paySign\r\n'
            '      })\r\n'
            "      if (payData && payData.errMsg === 'requestPayment:ok') {\r\n"
            '        Taro.showModal({\r\n'
            "          title: '操作提示',\r\n"
            "          content: '支付成功',\r\n"
            '          showCancel: false,\r\n'
            "          confirmText: '确定'\r\n"
            '        })\r\n'
            '      } else {\r\n'
            '        Taro.showModal({\r\n'
            "          title: '操作提示',\r\n"
            "          content: '支付失败，请重新尝试',\r\n"
            '          showCancel: false,\r\n'
            "          confirmText: '确定'\r\n"
            '        })\r\n'
            '      }\r\n'
            '    }\r\n'
            '  }\r\n'
            '\r\n'
            '  render () {\r\n'
            '    return (\r\n'
            "      <View className='index'>\r\n"
            '        <Button onClick={this.sendOrderInfo}>立即下单</Button>\r\n'
            '      </View>\r\n'
            '    )\r\n'
            '  }\r\n'
            '}效果图结语在实际项目操作中，大家把接口换成自己的可用接口即可。后记以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得\xa0'
            '收藏\xa0、\xa0转发\xa0、点击右下角按钮\xa0在看\xa0'
            '，推荐给更多小伙伴呦，欢迎多多留言交流...胡哥有话说，一个有技术，有情怀的胡哥！京东开放平台首席前端攻城狮。与你一起聊聊大前端，分享前端系统架构，框架实现原理，最新最高效的技术实践！',
 'pub_time': '2019-7-16 00:31',
 'title': '微信小程序支付功能全流程实践 '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5360-1.html>
{'author': 'Rolan',
 'content': '前言这几天去面试，多次碰到同一个知识点。而且有一次面试挺有趣的，是关于小程序的。共有3个问题。1、小程序中Page.watch()方法是做什么用的？2、小程序中如何在其他页面中监听到globalData中值的变化？3、如果在app.js执行登录部分的代码，由于时序问题，如何处理其他页面请求时未获取到身份识别标记的情况。（session，userid等）。（大意是：怎么能够保证其他页面请求是在登录之后？）知识点有经验的同学可能一下子就看出来了，这其实说的是同一个东西，那就是Object.defineproperty()这个方法。下面我来尝试回答一下：第一题：小程序中并没有Page.watch()方法，但其实这里面试官的要问的东西就是第二题的题目，也就是属性监听器。第二题：由于要监听到globalData中的值的变化，所以一般要在globalData改变时回调一个方法。例如我们监听一个name属性，大致代码如下：// '
            'app.js中//app.jsApp({  onLaunch: function () {    let that = '
            'this    // 在这里用定时器模拟网络请求的过程    setTimeout(function(){      '
            "that.globalData.name = 'pxh'    },3000)   }, // "
            '这里这么写，是要在其他界面监听，而不是在app.js中监听，而且这个监听方法，需要一个回调方法。  '
            'watch:function(method){    var obj = this.globalData;    '
            'Object.defineProperty(obj,"name", {      configurable: true,      '
            'enumerable: true,      set: function (value) {        this._name '
            "= value;        console.log('是否会被执行2')        method(value);      "
            '},      get:function(){      // '
            '可以在这里打印一些东西，然后在其他界面调用getApp().globalData.name的时候，这里就会执行。        '
            'return this._name      }    })  },  globalData: {    userInfo: '
            "null,    _name:'msr'  }})  // 然后在index.js中的声明周期中实现onLoad: "
            'function (options) {    let that = this;    '
            'getApp().watch(that.watchBack)  },  watchBack: function '
            "(name){    console.log(22222);    console.log('this.name==' + "
            'name)  '
            '}看看执行效果（可以看到，我们在其他界面完美实现了监听到globalData的变化）image.png第三题：emmm。第二题的答案就是第三题的答案啦。我们可以在index.js中的回调方法中再进行网络请求，请求需要识别身份的资源。',
 'pub_time': '2019-7-15 00:45',
 'title': '小程序如何在其他页面监听globalData中值的变化？ '}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5238-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=6)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5242-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=6)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5241-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=6)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5238-1.html>
{'author': 'Rolan',
 'content': '前言商城没几个营销活动能叫商城吗？这里你能找到的有：1.红包雨2.大转盘3.九宫格翻牌4...所以就来几个组件吧，写的不好轻踩，对你有帮助记得给个小星星哦直接上链接github链接运行例子git '
            'clone https://github.com/sunnie1992/soul-weapp.git\r\n'
            '复制代码微信开发者工具打开项目营销组件大转盘 "pages/wheel/index"\xa0九宫格翻牌 '
            '"pages/gridCard/index"\xa0红包雨 "pages/packetRain/index"\xa0'
            '页面"pages/filter/index" 功能筛选筛选预览',
 'pub_time': '2019-6-12 00:23',
 'title': '小程序营销组件：红包雨、大转盘、九宫格翻牌…… '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5242-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5173-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5241-1.html>
{'author': 'Rolan',
 'content': '目前手上有一个小程序的项目，希望转发时分享消息的界面能够自定义,然而微信小程序只提供设置图片的url和title。/**\r\n'
            '     * 用户点击右上角分享\r\n'
            '     */\r\n'
            '    onShareAppMessage: function() {\r\n'
            '        return {\r\n'
            "          imageUrl:'',\r\n"
            "          title:''\r\n"
            '        };\r\n'
            '    }\r\n'
            '复制代码实现我们要转发的显示内容多了一点东西:\xa0头像\xa0，\xa0用户名\xa0和\xa0'
            '点赞数。好在这个排版不是很复杂，所以我们思考了一下通过canvas去生成一张图片再return '
            'canvas所生成的图片url。代码如下（其实还要作出一些显示上的优化，具体你们自己去调试）： 先在页面里新建一个canvas '
            '标签<canvas canvas-id="canvasid" style="width: 375px; height: '
            '500px;" wx:if="{{canvasShow}}"></canvas>\r\n'
            "复制代码let context = wx.createCanvasContext('canvasid')\r\n"
            '     context.drawImage(back.path, 0, 60, backWidth, backHeight) '
            '//绘制下方背景图\r\n'
            '     //绘制圆形头像，参考教程：https://www.jianshu.com/p/9a6ee2648d6f '
            '第二种方法\r\n'
            '\r\n'
            '      context.save();\r\n'
            '      var d = 2 * 25;\r\n'
            '      var cx = 0 + 25;\r\n'
            '      var cy = 0 + 25;\r\n'
            '      context.arc(cx, cy,25, 0, 2 * Math.PI);\r\n'
            '      context.clip();\r\n'
            '      context.drawImage(avatar.path, 0,0, d, d);\r\n'
            '      context.restore();\r\n'
            '      //绘制名字和点赞数\r\n'
            '      context.setFontSize(14)\r\n'
            "      context.fillText('userName', 70, 32)\r\n"
            "      let zanLength = ('100' + '次赞').length\r\n"
            "      context.fillText('100'+ '次赞', 375 - 14 * zanLength, 32)\r\n"
            '      //执行draw进行渲染 并返回图片url\r\n'
            '      context.draw(true, () => {\r\n'
            '        //此方法应执行在draw的回调中\r\n'
            '        wx.canvasToTempFilePath({\r\n'
            '          x: 0,\r\n'
            '          y: 0,\r\n'
            '          width: 375,\r\n'
            '          height: 400,\r\n'
            '          destWidth: 375,\r\n'
            '          destHeight: 400,\r\n'
            "          canvasId: 'canvasid',\r\n"
            '          success(res) {\r\n'
            '        //设置onShareAppMessage所返回的数据格式\r\n'
            '           let shareInfo = {\r\n'
            "              title: 'customTitle',\r\n"
            '              imageUrl\r\n'
            '            }\r\n'
            '           //隐藏画布\r\n'
            '            that.setData({\r\n'
            '              canvasShow: false\r\n'
            '            })\r\n'
            '          }\r\n'
            '        })\r\n'
            '      });\r\n'
            '复制代码然而！ '
            '在canvas中绘制的图片要在真机上显示出来是有问题的（画布污染），非同源的图片在canvas不会显示出来的。后来我们使用\xa0'
            'wx.getImageInfo\xa0'
            '去获取图片信息，通过里面的地址去显示图片(相当于是把图片转了一道)。wx.getImageInfo({\r\n'
            '                src: imgUrl,\r\n'
            '                success: function(res) {\r\n'
            '                     /**拿到返回值res[0].path,再把该值作为canvas绘制图片的路径 \r\n'
            '                        '
            'context.drawImage(res[0].path,x,x,x)**/\r\n'
            '                    let drawImgUrl =  res[0].path\r\n'
            '                }\r\n'
            '            }); \r\n'
            '复制代码emmmm....文章很短暂，这里只是提供一下解决的思路，希望能帮助到大家~',
 'pub_time': '2019-6-13 00:06',
 'title': '微信小程序前端实现自定义分享 '}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5171-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5146-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=9)
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5250-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5173-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5171-1.html>
{'author': 'Rolan',
 'content': '在做过一系列小程序之后，对小程序的登陆鉴权的流程也有一定的理解，类似于 B '
            '端小程序自不必说，要用户信息手机号地址可以一把梭，做一个引导页面进行判断然后要求用户给与绑定，用户自然不会多说什么，毕竟这是企业级别应用。但是当涉及到 '
            'C '
            '端小程序时候。想让用户进行绑定，就势必要给与用户便利。这里我列出一些我觉得较为不错的小程序应用方案以供参考。预先绑定类该类小程序在使用之前就需要绑定用户信息。常见于线下门店类功能性小程序。线下操作时有大量的优惠活动来支持小程序的流量。功能介绍例如 '
            '便利蜂。之前在上海经常使用，价格和优惠都非常不错，这类小程序属于线下功能类小程序，内部有抽奖，付款等一系列功能。该小程序第一次打开就先用户直接要求用户绑定信息和地址，考虑到线下门店都会有一定的店员辅助。所以该小程序的绑定操作实际上用户都是可以接受的。图片如下所示。技术要点技术1： '
            '使用自定义导航栏让头部可以配置全局配置"window": {\r\n'
            '  "navigationStyle": "custom"\r\n'
            '}如果微信 app 的版本在 7.0.0之上，我们就可以使用页面级别的配置了。{\r\n'
            '  "usingComponents": {},\r\n'
            '  "navigationStyle": "custom"\r\n'
            '}该配置默认时default，当使用custom时候可以自定义导航，可以在头部配置 loading。第二种这个需要 app '
            '版本，所以如果是想简化，反而在全局下定义，再使用微信官方的组件\xa0avigation-bar\xa0'
            '即可。技术2：使用小程序骨架屏骨架屏方案在后端不能很快给与前端数据时候采用这种方案，亦或者前端可以使用 Service '
            'Worker '
            '把上次缓存数据返回到前端，等到从后端获取数据之后刷新页面也是一种方案，但是因为这是第一次打开小程序，所以采用骨架屏是一个很好的方法。采用\xa0'
            '小程序骨架屏\xa0'
            '组件，如果不需要骨架屏动画效果，可以试试直接加载图片作为骨架屏。惰性绑定类该类小程序在展示时无需绑定用户信息，但是当用户进行操作时在询问绑定。常用于线上商城等一系列无需专人引导的用户项目。功能介绍基本上线上大部分 '
            'c 端小程序都采用此做法，功能上倒是没什么可以介绍的，但是实践上却有不同做法。实践方式方式 1: 页面跳转 '
            '(京东购物)在每个需要绑定的按钮上添加跳转逻辑，如果当前小程序没有绑定，可以跳转到另外一个页面上确认授权。方式2: 按钮控制 '
            '(华为商城+)在每个需要绑定按钮上添加 '
            "open-type='getuserinfo'，后续可以根据状态变化，切换掉按钮(也可以不切换，因为第二次绑定数据不会跳出组件)。方式3: "
            '遮罩层拦截 (抽奖助手)在需要绑定的页面添加一个 '
            '透明模态框，增加以整个页面大小的button。用fixed布局，还可以向下滚动。无论在当前页面点击任何地方都会出现需要绑定选项。组件代码：// '
            'wxml\r\n'
            '<view style="z-index: {{zIndex}}" class="mask">\r\n'
            '  <button open-type="{{ openType }}"\r\n'
            '          bindtap="onClick"\r\n'
            '          bindgetuserinfo="bindGetUserInfo"\r\n'
            '          bindgetphonenumber="bindGetPhoneNumber"\r\n'
            '          bindopensetting="bindOpenSetting"\r\n'
            '          binderror="bindError"\r\n'
            '          class="mask"/>\r\n'
            '</view>\r\n'
            '\r\n'
            '// wxss\r\n'
            '.mask{\r\n'
            '  position: fixed;\r\n'
            '  top: 0;\r\n'
            '  bottom:0;\r\n'
            '  left:0;\r\n'
            '  right:0;\r\n'
            '  background-color: inherit;\r\n'
            '  opacity: 0;\r\n'
            '}然后在绑定后令 mask '
            '消失。该方案初看起来不是那么的合适，但是仔细想想却也没什么问题，因为用户99%可能点击所需求的按钮，就算点击到按钮之间的空隙之处跳出要求绑定也没有什么问题。上面方式实际上都没有太大的问题，需要在不同场景下做最合适的选择。结语人机交互功能是决定计算机系统“友善性”的一个重要因素。读书学习时候要先把书读厚，再把书读薄，做程序也是一样，如何把系统做的复杂而更加复杂，如何让用户的体验简单而更为简单都不是那么容易的一件事。',
 'pub_time': '2019-5-15 00:16',
 'title': '小程序绑定用户方案 优化 '}
2019-07-25 14:24:56 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5251-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5146-1.html>
{'author': 'Rolan',
 'content': '在一些需要用户填写资料的业务场景中，有时会让用户选择某个业务的范围，这时就需要用到滑块进度条。然后你们最爱的产品经理会说，给我整一个颜色可控，滑块按钮可大可小，滑块边框也要可大可小的滑动条来..emmm，一看这样的设计需求就意味着小程序原生的slider组件就不能用了。因为这玩意在样式上就不能自由的配置，只好来手动实现一个。结构设计行吧，那说干就干。首先滑动条可以从俯视图角度来看，分为三层。分别是底部滑轨区域，进度条区域以及供用户操作的滑块本身。在结构设计中，可以将底部滑轨区域，进度条区域分为一块，这样进度条区域可以根据随着滑动条的高度变化而变化, '
            '宽度则由js控制。除此之外还需要暴露一些参数给外部，让它自己定义长粗宽。Component({\r\n'
            '    /**\r\n'
            '     * 组件的属性列表\r\n'
            '     */\r\n'
            '    properties: {\r\n'
            '        // 滑块大小\r\n'
            '        blockSize: {\r\n'
            '            type: Number,\r\n'
            '            value: 32,\r\n'
            '        },\r\n'
            '\r\n'
            '        // 滑块宽度\r\n'
            '        blockBorderWidth: {\r\n'
            '            type: Number,\r\n'
            '            value: 3\r\n'
            '        },\r\n'
            '\r\n'
            '        // 滑轨高度\r\n'
            '        height: {\r\n'
            '            type: Number,\r\n'
            '            value: 2\r\n'
            '        },\r\n'
            '\r\n'
            '        // 滑轨进度\r\n'
            '        step: {\r\n'
            '            type: Number,\r\n'
            '            value: 0,\r\n'
            '        },\r\n'
            '\r\n'
            '        // 进度值小数位\r\n'
            '        digits: {\r\n'
            '            type: Number,\r\n'
            '            value: 0,\r\n'
            '        },\r\n'
            '    },\r\n'
            '});<view id="slider-wrap" class="slider-wrap">\r\n'
            '    <view class="silder-bg" style="height: {{height}}rpx;">\r\n'
            '        <view  class="silder-bg-inner"></view>\r\n'
            '    </view>\r\n'
            '    <view\r\n'
            '        class="silder-block"\r\n'
            '        style="height: {{blockSize}}rpx; border-width: '
            '{{blockBorderWidth}}rpx;"\r\n'
            '    ></view>\r\n'
            '</view>.slider-wrap {\r\n'
            '    position: relative;\r\n'
            '    display: flex;\r\n'
            '    align-items: center;\r\n'
            '    width: 100%;\r\n'
            '}\r\n'
            '\r\n'
            '.silder-bg,\r\n'
            '.silder-bg-inner,\r\n'
            '.silder-block {\r\n'
            '    position: absolute;\r\n'
            '    left: 0;\r\n'
            '}\r\n'
            '\r\n'
            '.silder-bg,\r\n'
            '.silder-bg-inner {\r\n'
            '    width: 100%;\r\n'
            '    height: 2rpx;\r\n'
            '    flex: 1;\r\n'
            '}\r\n'
            '\r\n'
            '.silder-bg {\r\n'
            '    overflow: hidden;\r\n'
            '    background-color: #eeeeee;\r\n'
            '    border-radius: 8rpx;\r\n'
            '    z-index: 0;\r\n'
            '}\r\n'
            '\r\n'
            '.silder-bg-inner {\r\n'
            '    height: 100%;\r\n'
            '    background-color: #66a6ff;\r\n'
            '    /* border-radius: 8rpx; */\r\n'
            '    z-index: 1;\r\n'
            '    border-bottom-left-radius: 8rpx;\r\n'
            '    border-top-left-radius: 8rpx;\r\n'
            '}\r\n'
            '\r\n'
            '.silder-block {\r\n'
            '    width: 32rpx;\r\n'
            '    height: 32rpx;\r\n'
            '    background-color: #ffffff;\r\n'
            '    border: solid 3rpx #66a6ff;\r\n'
            '    z-index: 2;\r\n'
            '    border-radius: 50%;\r\n'
            '    box-sizing: border-box;\r\n'
            '}\r\n'
            '点击行为事件滑块进度条的滑块是一个听话的小朋友，就是说我们叫它去哪它就听话的过去。所以就不要抓它去煲汤了~在组件外部容器中绑定一个点击事件，我们必须得要知道用户点击位置，在bind:tap事件中取到clientX属性。除此之外还需要取到进度条的位置信息。得到两个关键数据后，将用户点击的位置ClintX与进度条组件的偏移量offset相减，得出相对于组件内的进度progress.再用组件的宽度width减去progress乘于100得到目前进度的百分比percentage。同时为了防止进度条超出进度条如下图所示：((191 '
            '- 36) / 301) * 100 ≈ 52<view class="slider-wrap" '
            'bindtap="tappingSlider">\r\n'
            '    <!-- ...other -->\r\n'
            '</view>Component({\r\n'
            '    // ...\r\n'
            '\r\n'
            '    /**\r\n'
            '     * 组件的初始数据\r\n'
            '     */\r\n'
            '    data: {\r\n'
            '        containerInfo: null,\r\n'
            '        percentage: 0,\r\n'
            '    },\r\n'
            '\r\n'
            '    ready() {\r\n'
            '        // 取到滑块进度条的位置信息\r\n'
            '        wx.createSelectorQuery().in(this)\r\n'
            "            .select('.slider-wrap')\r\n"
            '            .boundingClientRect((rect) => {\r\n'
            '                if (!rect) return;\r\n'
            '\r\n'
            '                this.data.container = rect;\r\n'
            '                this._initBloackPos();\r\n'
            '            }).exec()\r\n'
            '    },\r\n'
            '\r\n'
            '    // 点击进度条\r\n'
            '    tappingSlider(evt) {\r\n'
            '        const { containerInfo } = this.data;\r\n'
            '        if (!containerInfo) return;\r\n'
            '\r\n'
            '        const { clientX } = evt.changedTouches[0];\r\n'
            '        const { digits, _maxDistance } = this.data;\r\n'
            '\r\n'
            '        // 需要做边界处理\r\n'
            '        const perc = this._computeOffset(clientX, '
            'containerInfo.left, 100);\r\n'
            '        const percentage = this._boundaryHandler(perc);\r\n'
            '\r\n'
            '        this.setData({ percentage });\r\n'
            "        this.triggerEvent('change', {\r\n"
            '              value: percentage.toFixed(digits) * 1\r\n'
            '          });\r\n'
            '    },\r\n'
            '\r\n'
            '    /**\r\n'
            '     * 计算相对容器的偏移距离\r\n'
            '     *\r\n'
            '     * @param { Number } x - X 坐标\r\n'
            '     * @param { Number } offset - 偏移量\r\n'
            '     * @param { Number } maxVal - 在 maxVal 范围内求百分比\r\n'
            '     */\r\n'
            '    _computeOffset(x, offset, maxVal) {\r\n'
            '        const { width } = this.data.containerInfo;\r\n'
            '\r\n'
            '        // 底层保证一定精度\r\n'
            '        return (((x - offset) / width) * maxVal).toFixed(4) * '
            '1;\r\n'
            '    },\r\n'
            '\r\n'
            '    /**\r\n'
            '     * 边界处理\r\n'
            '     * @param { Number } num - 待处理的最值\r\n'
            '     * @param { Number } maxNum - num 最大值\r\n'
            '     * @param { Number } minNum - num 最小值\r\n'
            '     */\r\n'
            '    _boundaryHandler(num, maxNum = 100, minNum = 0) {\r\n'
            '        return num > maxNum ? maxNum : (num < minNum ? minNum : '
            'num);\r\n'
            '    },\r\n'
            '});<view class="slider-wrap" bindtap="tappingSlider" '
            'bindtouchmove="onTouchMove">\r\n'
            '    <view class="silder-bg" style="height: {{height}}rpx;">\r\n'
            '        <view\r\n'
            '            class="silder-bg-inner"\r\n'
            '            style="width: {{percentage}}%; height: '
            '{{height}}rpx;"\r\n'
            '        ></view>\r\n'
            '    </view>\r\n'
            '    <view\r\n'
            '        class="silder-block"\r\n'
            '        style="left: {{percentage}}%;width: '
            '{{blockSize}}rpx;height: {{blockSize}}rpx; border-width: '
            '{{blockBorderWidth}}rpx;"\r\n'
            '    ></view>\r\n'
            '</view>虽然实现了点击滑动到指定位置的功能，但仔细一看还是有一些瑕疵的~ '
            '当我们点击到百分百时，滑块超出原先设定的容器宽度。超出的原因是因为在布局上，我们使用绝对定位absolute，通过设置滑块left属性来控制滑块位置的。偏移量中还包含了滑块自身的宽度，因此还需要对滑块的偏移量做一定的处理，去掉自身宽度再获取百分比。在文章开头我们已经暴露了一个blockSize的属性，利用该属性可以计算滑块的最大偏移量：Component({\r\n'
            '    // ...\r\n'
            '    data: {\r\n'
            '        // other data...\r\n'
            '\r\n'
            '        _blockOffset: 0,\r\n'
            '        _maxDistance: 100,\r\n'
            '    },\r\n'
            '\r\n'
            '    methods: {\r\n'
            '        // 点击进度条\r\n'
            '        tappingSlider(evt) {\r\n'
            '            const { containerInfo } = this.data;\r\n'
            '            if (!containerInfo) return;\r\n'
            '\r\n'
            '            const { clientX } = evt.changedTouches[0];\r\n'
            '            const { digits, _maxDistance } = this.data;\r\n'
            '            const computeOffset = (maxVal) => {\r\n'
            '                return this._computeOffset(clientX, '
            'containerInfo.left, maxVal);\r\n'
            '            }\r\n'
            '\r\n'
            '            // 滑块偏移度\r\n'
            '            const _blockOffset = this._boundaryHandler(\r\n'
            '                computeOffset(_maxDistance), _maxDistance\r\n'
            '            );\r\n'
            '\r\n'
            '            // 实际百分比\r\n'
            '            const percentage = '
            'this._boundaryHandler(computeOffset(100));\r\n'
            '\r\n'
            '            this.setData({ _blockOffset, percentage });\r\n'
            "            this.triggerEvent('change', { value: "
            'percentage.toFixed(digits) * 1 });\r\n'
            '        },\r\n'
            '    }\r\n'
            '\r\n'
            '})<!-- other code -->\r\n'
            '<view\r\n'
            '    class="silder-block"\r\n'
            '    style="left: {{_blockOffset}}%;width: '
            '{{blockSize}}rpx;height: {{blockSize}}rpx; border-width: '
            '{{blockBorderWidth}}rpx;"\r\n'
            '></view>如此，该事件就完成啦~滑动事件完成点击事件后，我们还得让它能进行自由的滑动。进度条组件的拖动的流程大致是：点击滑块\xa0'
            '->\xa0拖动滑块\xa0->\xa0'
            '释放滑块这三个步骤。因此跟H5的思路一样，我们只需监听touchmove、touchstatr、touchend三个事件。首先先监听touchmove，用户点击滑块后，记录当前的clientX属性, '
            '随后还需要记录当前进度和滑块的偏移量；touchmove事件则由外层容器相关联，并更新滑动的距离。由于touchmove里针对拖动事件逻辑不能被随便触发，因此需要加一个标识的锁；在touchend事件触发后释放锁即可：Component({\r\n'
            '    methods: {\r\n'
            '        onTouchStart(evt) {\r\n'
            '            this.data.moving = true;\r\n'
            '\r\n'
            '            // 记录原始坐标\r\n'
            '            this.data.originPos = this.data._blockOffset;\r\n'
            '            this.data.originPercentage = this.data.percentage;\r\n'
            '\r\n'
            '            this.data._startTouchX = '
            'evt.changedTouches[0].clientX;\r\n'
            '        },\r\n'
            '\r\n'
            '        // 滑块移动\r\n'
            '        onTouchMove(evt) {\r\n'
            '            const { moving, containerInfo } = this.data;\r\n'
            '            if (!moving || !containerInfo) return;\r\n'
            '\r\n'
            '            const { clientX } = evt.changedTouches[0];\r\n'
            '            const {\r\n'
            '                digits,\r\n'
            '                originPos,\r\n'
            '                originPercentage,\r\n'
            '                _startTouchX,\r\n'
            '                _maxDistance\r\n'
            '            } = this.data;\r\n'
            '\r\n'
            '            // 计算偏移量\r\n'
            '            const computeOffset = (maxVal) => {\r\n'
            '                return this._computeOffset(clientX, _startTouchX, '
            'maxVal);\r\n'
            '            }\r\n'
            '\r\n'
            '            // 实际百分比\r\n'
            '            const perc = originPercentage + '
            'computeOffset(100);\r\n'
            '            const percentage = this._boundaryHandler(perc);\r\n'
            '\r\n'
            '            // 滑块偏移度\r\n'
            '            const offset = originPos + '
            'computeOffset(_maxDistance);\r\n'
            '            const _blockOffset = this._boundaryHandler(offset, '
            '_maxDistance);\r\n'
            '\r\n'
            '            this.setData({ percentage, _blockOffset });\r\n'
            "            this.triggerEvent('change', {\r\n"
            '                value: percentage.toFixed(digits) * 1\r\n'
            '            });\r\n'
            '        },\r\n'
            '\r\n'
            '        onTouchEnd(evt) {\r\n'
            '            this.data.moving = false;\r\n'
            '        },\r\n'
            '    }\r\n'
            '})<view class="slider-wrap" bindtap="tappingSlider" '
            'bindtouchmove="onTouchMove">\r\n'
            '    <view class="silder-bg" style="height: {{height}}rpx;">\r\n'
            '        <view\r\n'
            '            class="silder-bg-inner"\r\n'
            '            style="width: {{percentage}}%; height: '
            '{{height}}rpx;"\r\n'
            '        ></view>\r\n'
            '    </view>\r\n'
            '    <view\r\n'
            '        class="silder-block"\r\n'
            '        style="left: {{_blockOffset}}%;width: '
            '{{blockSize}}rpx;height: {{blockSize}}rpx; border-width: '
            '{{blockBorderWidth}}rpx;"\r\n'
            '        bindtouchstart="onTouchStart"\r\n'
            '        bindtouchend="onTouchEnd"\r\n'
            '    ></view>\r\n'
            '</view>总结以上就是滑块进度条组件的实现~ '
            '实际上该组件还有更多可供配置的地方，如颜色值，背景控制等这些比较基础的东西就不继续展开讲啦~本文是以小程序进行示例。但思路是共通的，也可以使用同样思路在H5实现，只不过是 '
            'API 的差异罢了~微信代码片段, 可以直接拿来就用。2019/05/04 '
            '更新：后面又重新看了一遍，发现该组件还是有可优化的空间：操作不必局限于滑块上，可以将bindtap事件废弃，其余的所有事件都代理到最外部的节点中。touchstar的同时就渲染位置信息，还允许它自由的滑动:<view '
            'class="slider-wrap"\r\n'
            '    bindtouchstart="onTouchStart"\r\n'
            '    bindtouchmove="onTouchMove"\r\n'
            '    bindtouchend="onTouchEnd"\r\n'
            '>\r\n'
            '    <view class="silder-bg" style="height: {{height}}rpx;">\r\n'
            '        <view\r\n'
            '            class="silder-bg-inner"\r\n'
            '            style="width: {{percentage}}%; height: '
            '{{height}}rpx;"\r\n'
            '        ></view>\r\n'
            '    </view>\r\n'
            '    <view\r\n'
            '        class="silder-block"\r\n'
            '        style="left: {{_blockOffset}}%;width: '
            '{{blockSize}}rpx;height: {{blockSize}}rpx; border-width: '
            '{{blockBorderWidth}}rpx;"\r\n'
            '    ></view>\r\n'
            '</view>Component({\r\n'
            '    // other options ...\r\n'
            '\r\n'
            '    methods: {\r\n'
            '        // other method ...\r\n'
            '        onTouchStart(evt) {\r\n'
            '            this.data.moving = true;\r\n'
            '\r\n'
            '            const { containerInfo } = this.data;\r\n'
            '            if (!containerInfo) return;\r\n'
            '\r\n'
            '            const { clientX } = evt.changedTouches[0];\r\n'
            '            const { digits, _maxDistance } = this.data;\r\n'
            '            const computeOffset = (maxVal) => {\r\n'
            '                return this._computeOffset(clientX, '
            'containerInfo.left, maxVal);\r\n'
            '            }\r\n'
            '\r\n'
            '            // 滑块偏移度\r\n'
            '            const _blockOffset = this._boundaryHandler(\r\n'
            '                computeOffset(_maxDistance), _maxDistance\r\n'
            '            );\r\n'
            '\r\n'
            '            // 实际百分比\r\n'
            '            const percentage = '
            'this._boundaryHandler(computeOffset(100));\r\n'
            '\r\n'
            '            // 记录原始坐标\r\n'
            '            this.data.originPos = _blockOffset;\r\n'
            '            this.data.originPercentage = percentage;\r\n'
            '\r\n'
            '            this.data._startTouchX = clientX;\r\n'
            '\r\n'
            '            this.setData({ _blockOffset, percentage });\r\n'
            "            this.triggerEvent('change', { value: "
            'percentage.toFixed(digits) * 1 });\r\n'
            '        },\r\n'
            '    }\r\n'
            '});微信代码片段 v0.0.2',
 'pub_time': '2019-5-7 00:32',
 'title': '[UI组件] 来做一个可配置的滑块进度条吧 '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5250-1.html>
{'author': 'Rolan',
 'content': '小程序特点：用完即走、低频使用、性能要求低，不支持webview；以iphone6尺寸（750*1334）为视觉稿进行设计；iphone6下1px=1rpx=0.5pt \xa0 \xa0 '
            'iphone6 '
            'plux下1px=0.6rpx；使用rpx，小程序会自动在不同的分辨率下进行转换，而使用px为单位不会；1.设置全局字体样式app.wxss：text{\r\n'
            'font-family:MicroSoft yahei;\r\n'
            '}2.设置弹性盒子模型：.container{\r\n'
            '/*弹性模型*/\r\n'
            'display:flex;\r\n'
            '/*垂直方向 列方向 排布*/\r\n'
            'flex-direction:column;\r\n'
            '/*居中*/\r\n'
            'align-items:center;\r\n'
            '/*要从整体解决排布的问题是最好的方案*/\r\n'
            '}3.设置页面全屏样式及背景色：page{\r\n'
            'height:100%;\r\n'
            'background:#b3d4db;\r\n'
            '}4.全局设置导航条颜色app.json："window": {\r\n'
            '"navigationBarBackgroundColor": "#405f80"\r\n'
            '}5.页面设置导航条颜色和标题*.json:{\r\n'
            '"navigationBarBackgroundColor": "#405f80",\r\n'
            '"navigationBarTitleText":"文与字"\r\n'
            '}6.设置字体属性：.user-name{\r\n'
            'font-size:32rpx;\r\n'
            'font-weight:bold;\r\n'
            '}7.创建圆角矩形边框：.moto-container{\r\n'
            'border:1px solid #405f80;\r\n'
            'width:200rpx;\r\n'
            'height:80rpx;\r\n'
            'border-radius:5rpx;\r\n'
            'text-align:center;\r\n'
            '}8.外边距设置：margin-top:20rpx;\r\n'
            'margin-bottom:40rpx;9.内边距设置：padding-bottom:20rpx;10.上、下边线设置：border-bottom:1px '
            'solid #ededed;\r\n'
            'border-top:1px solid '
            '#ededed;11.文字间距设置：letter-spacing:2rpx;12.垂直居中（此元素放置在父元素的中部）：vertical-align: '
            'middle;\xa013.设置子元素Image样式：.circle-img image{\r\n'
            '    width:90rpx;\r\n'
            '    height: 90rpx\r\n'
            '}14.最底层垂直居中横线样式：.horizon{\r\n'
            '    width:660rpx;\r\n'
            '    height: 2rpx;\r\n'
            '    background-color: #e5e5e5;\r\n'
            '    vertical-align: middle;\r\n'
            '    position:relative;\r\n'
            '    top:46rpx;\r\n'
            '    margin: 0 auto;\r\n'
            '    z-index: -99\r\n'
            '}15.图片居中覆盖:.audio{\r\n'
            '    width:102rpx;\r\n'
            '    height:110rpx;\r\n'
            '    position: absolute;\r\n'
            '    left: 50%;\r\n'
            '    margin-left: -51rpx;//经典水平居中方式\r\n'
            '    top:180rpx;\r\n'
            '    margin-top: 20rpx;\r\n'
            '    opacity:0.6;//透明度\r\n'
            '}',
 'pub_time': '2019-6-17 00:13',
 'title': '微信小程序常用样式汇总 '}
2019-07-25 14:24:56 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5251-1.html>
{'author': 'Rolan',
 'content': '<view class="upload_view">\u3000\u3000<block wx:for="{{pics}}" '
            'wx:key="*this">\r\n'
            '\u3000\u3000\u3000\u3000<view class="q_image_wrap">\r\n'
            '\u3000\u3000\u3000\u3000\u3000\u3000<!-- 图片缩略图  -->\r\n'
            '\u3000\u3000\u3000\u3000\u3000\u3000<image class="q_image" '
            'src="{{item}}" mode="aspectFill" data-idx="{{index}}" '
            'bindtap="handleImagePreview"></image>\r\n'
            '\u3000\u3000\u3000\u3000\u3000\u3000<!-- 移除图片的按钮  -->\r\n'
            '\u3000\u3000\u3000\u3000\u3000\u3000<view class="q_image_remover" '
            'data-idx="{{index}}" bindtap="removeImage">\r\n'
            '\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000<i-icon '
            'type="close" size="14" class="icon" />\r\n'
            '\u3000\u3000\u3000\u3000\u3000\u3000</view>\r\n'
            '\u3000\u3000\u3000\u3000</view>\u3000\u3000</block>\r\n'
            '\u3000\u3000<view class=\'uploadImg_btn\' bindtap="chooseImage" '
            'wx:if="{{pics.length < 9}}">\r\n'
            '\u3000\u3000\u3000\u3000<image '
            'src="../../img/upload.png"></image>\r\n'
            '\u3000\u3000</view>\r\n'
            '</view> //选择图片\r\n'
            '    chooseImage(e) {\r\n'
            '        console.log(e)\r\n'
            '        var that = this;\r\n'
            '        var pics = this.data.pics;\r\n'
            '        '
            '//---------------------多张上传----------------------------------------------------------------------------------------\r\n'
            '        wx.chooseImage({\r\n'
            '            count: 9 - pics.length, // 最多可以选择的图片张数，默认9\r\n'
            "            sizeType: ['original', 'compressed'], // original "
            '原图，compressed 压缩图，默认二者都有\r\n'
            "            sourceType: ['album', 'camera'], // album "
            '从相册选图，camera 使用相机，默认二者都有\r\n'
            '            success: function (photo) {\r\n'
            '                //图片大小，限制10M以内\r\n'
            '                for (var i = 0; i < photo.tempFiles.length; i++) '
            '{\r\n'
            '                    if (photo.tempFiles[i].size >= 10 * 1024 * '
            '1024) {\r\n'
            "                        console.log('请上传10M以内的图片');\r\n"
            '                        return;\r\n'
            '                    }\r\n'
            '                }\r\n'
            '                var imgsrc = photo.tempFilePaths;\r\n'
            '                //页面上展示的是原图片========pics数组\r\n'
            '                pics = pics.concat(imgsrc);\r\n'
            '                that.setData({\r\n'
            '                    pics: pics\r\n'
            '                });\r\n'
            '                console.log(that.data.pics)\r\n'
            '                that.getCanvasImg(0, 0, photo.tempFilePaths);  '
            '//进行压缩\r\n'
            '            },\r\n'
            '            fail: function () {\r\n'
            '                // fail\r\n'
            '            },\r\n'
            '            complete: function () {\r\n'
            '                // complete\r\n'
            '            }\r\n'
            '        })\r\n'
            '    }, //压缩并获取图片，这里用了递归的方法来解决canvas的draw方法延时的问题\r\n'
            '    getCanvasImg: function (index, failNum, tempFilePaths) {\r\n'
            '        var that = this;\r\n'
            '        let imagesPress = that.data.imagesPress;\r\n'
            '        if (index < tempFilePaths.length) {\r\n'
            '            wx.getImageInfo({\r\n'
            '                src: tempFilePaths[index],\r\n'
            '                success: function (res) {\r\n'
            '                    //---------利用canvas压缩图片--------------\r\n'
            '                    var ratio = 2;\r\n'
            '                    var canvasWidth = res.width //图片原始长宽\r\n'
            '                    var canvasHeight = res.height\r\n'
            '                    while (canvasWidth > 400 || canvasHeight > '
            '400) {// 保证宽高在400以内\r\n'
            '                        canvasWidth = Math.trunc(res.width / '
            'ratio)\r\n'
            '                        canvasHeight = Math.trunc(res.height / '
            'ratio)\r\n'
            '                        ratio++;\r\n'
            '                    }\r\n'
            '                    that.setData({\r\n'
            '                        canvasWidth: canvasWidth,\r\n'
            '                        canvasHeight: canvasHeight,\r\n'
            '                    })\r\n'
            '                    const ctx = '
            "wx.createCanvasContext('photo_canvas');\r\n"
            '                    ctx.drawImage(tempFilePaths[index], 0, 0, '
            'canvasWidth, canvasHeight);\r\n'
            '                    ctx.draw(false, function () {\r\n'
            '                        index = index + 1;//上传成功的数量，上传成功则加1\r\n'
            '                        wx.canvasToTempFilePath({\r\n'
            "                            canvasId: 'photo_canvas',\r\n"
            '                            success: function success(res) {\r\n'
            "                                console.log('最终图片路径' + "
            'res.tempFilePath)//最终图片路径\r\n'
            '                                '
            'imagesPress.push(res.tempFilePath);\r\n'
            '                                '
            'console.log(that.data.imagesPress)\r\n'
            '                                that.setData({\r\n'
            '                                    imagesPress: imagesPress\r\n'
            '                                })\r\n'
            '                                '
            'that.uploadCanvasImg(res.tempFilePath);\r\n'
            '                                that.getCanvasImg(index, failNum, '
            'tempFilePaths);\r\n'
            '                            }, fail: function (e) {\r\n'
            '                                failNum += 1;//失败数量，可以用来提示用户\r\n'
            '                                that.getCanvasImg(inedx, failNum, '
            'tempFilePaths);\r\n'
            '                            }\r\n'
            '                        });\r\n'
            '                    });\r\n'
            '                }\r\n'
            '            })\r\n'
            '\r\n'
            '        }\r\n'
            '    },//上传图片\r\n'
            '    uploadCanvasImg: function (canvasImg) {\r\n'
            "        const {$Toast} = require('../../dist/base/index');\r\n"
            '        var that = this;\r\n'
            '        let attachmentId = that.data.attachmentId\r\n'
            '        var tempImg = canvasImg;\r\n'
            '        wx.showLoading({\r\n'
            "            title: '上传中...',\r\n"
            '        });\r\n'
            '        wx.uploadFile({\r\n'
            '            url: app.globalData.baseUrl + '
            "'/api/upload',//文件服务器的地址\r\n"
            '            filePath: tempImg,\r\n'
            '            header: {\r\n'
            "                'Content-type': 'multipart/form-data',\r\n"
            "                'token': wx.getStorageSync('token')\r\n"
            '            },\r\n'
            '            // formData: {\r\n'
            '            // },\r\n'
            "            name: 'file',\r\n"
            '            success: function (res) {\r\n'
            '                wx.hideLoading()\r\n'
            '                $Toast({\r\n'
            "                    content: '上传成功！'\r\n"
            '                });\r\n'
            '                console.log(res)\r\n'
            '            }\r\n'
            '        })\r\n'
            '    },//删除图片\r\n'
            '    removeImage(e) {\r\n'
            '        var that = this;\r\n'
            '        var pics = that.data.pics;\r\n'
            '        var imagesPress = that.data.imagesPress;\r\n'
            '        // 获取要删除的第几张图片的下标\r\n'
            '        const idx = e.currentTarget.dataset.idx\r\n'
            '        // splice  第一个参数是下表值  第二个参数是删除的数量\r\n'
            '        pics.splice(idx, 1)\r\n'
            '        imagesPress.splice(idx, 1)\r\n'
            '        this.setData({\r\n'
            '            pics: pics,\r\n'
            '            imagesPress: imagesPress\r\n'
            '        })\r\n'
            '        console.log(that.data.imagesPress)\r\n'
            '    },\r\n'
            '    //预览图片\r\n'
            '    handleImagePreview(e) {\r\n'
            '        const idx = e.target.dataset.idx\r\n'
            '        const pics = this.data.pics\r\n'
            '        wx.previewImage({\r\n'
            '            current: pics[idx],  //当前预览的图片\r\n'
            '            urls: pics,  //所有要预览的图片\r\n'
            '        })\r\n'
            '    },',
 'pub_time': '2019-6-17 00:42',
 'title': '小程序多图上传并压缩,带预览删除功能 '}
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5253-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5253-1.html>
{'author': 'Rolan',
 'content': '小程序开发中，需要用户授权登陆并获取用户的数据，快速对接用户系统。openId与unionid的区别openId : '
            '用户在当前小程序的唯一标识 unionId : '
            '如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionId是相同的。详情登录微信开放平台(open.weixin.qq.com) '
            '。GET  '
            'https://api.weixin.qq.com/sns/jscode2session?appid=xx&secret=xx&js_code=xx&grant_type=authorization_code\r\n'
            '\r\n'
            '属性类型默认值必填说明\r\n'
            'appid    string    是    小程序 appId    \r\n'
            'secret    string    是    小程序 appSecret    \r\n'
            'js_code    string    是    登录时获取的 code    \r\n'
            'grant_type    string    是    授权类型，此处只需填写 '
            'authorization_code    \r\n'
            '\r\n'
            '\r\n'
            'Object\r\n'
            '返回的 JSON 数据包\r\n'
            '属性类型说明\r\n'
            'openid    string    用户唯一标识    \r\n'
            'session_key    string    会话密钥    \r\n'
            'unionid    string    用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 '
            'UnionID 机制说明。    \r\n'
            'errcode    number    错误码    \r\n'
            'errmsg    string    错误信息解密类class WxBizDataCrypt\r\n'
            '{\r\n'
            '    private $appid;\r\n'
            '    private $sessionKey;\r\n'
            '\r\n'
            '    /**\r\n'
            '     * 构造函数\r\n'
            '     * @param $sessionKey string 用户在小程序登录后获取的会话密钥\r\n'
            '     * @param $appid string 小程序的appid\r\n'
            '     */\r\n'
            '    public function __construct( $appid, $sessionKey)\r\n'
            '    {\r\n'
            '        $this->sessionKey = $sessionKey;\r\n'
            '        $this->appid = $appid;\r\n'
            '    }\r\n'
            '\r\n'
            '\r\n'
            '    /**\r\n'
            '     * 检验数据的真实性，并且获取解密后的明文.\r\n'
            '     * @param $encryptedData string 加密的用户数据\r\n'
            '     * @param $iv string 与用户数据一同返回的初始向量\r\n'
            '     * @param $data string 解密后的原文\r\n'
            '     *\r\n'
            '     * @return int 成功0，失败返回对应的错误码\r\n'
            '     */\r\n'
            '    public function decryptData( $encryptedData, $iv, &$data )\r\n'
            '    {\r\n'
            '        if (strlen($this->sessionKey) != 24) {\r\n'
            '            return ErrorCode::$IllegalAesKey;\r\n'
            '        }\r\n'
            '        $aesKey=base64_decode($this->sessionKey);\r\n'
            '\r\n'
            '\r\n'
            '        if (strlen($iv) != 24) {\r\n'
            '            return ErrorCode::$IllegalIv;\r\n'
            '        }\r\n'
            '        $aesIV=base64_decode($iv);\r\n'
            '\r\n'
            '        $aesCipher=base64_decode($encryptedData);\r\n'
            '\r\n'
            '        $result=openssl_decrypt( $aesCipher, "AES-128-CBC", '
            '$aesKey, 1, $aesIV);\r\n'
            '\r\n'
            '        $dataObj=json_decode( $result );\r\n'
            '        if( $dataObj  == NULL )\r\n'
            '        {\r\n'
            '            return ErrorCode::$IllegalBuffer;\r\n'
            '        }\r\n'
            '        if( $dataObj->watermark->appid != $this->appid )\r\n'
            '        {\r\n'
            '            return ErrorCode::$IllegalBuffer;\r\n'
            '        }\r\n'
            '        $data = $result;\r\n'
            '        return ErrorCode::$OK;\r\n'
            '    }\r\n'
            '}代码如下仅供参考转载时请注明出处及相应链接，本文永久地址：https://blog.yayuanzi.com/25402.html',
 'pub_time': '2019-6-19 00:13',
 'title': '小程序登录数据解密 '}
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5254-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5268-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5254-1.html>
{'author': 'Rolan',
 'content': '在前端开发应用程序中，性能一直都是被大家所重视的一点，然而判断一个应用程序的性能最直观的就是看页面打开的速度。其中提高页页面反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短页面请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。前端常用缓存技术在这里我就不再描述，下面基于Storage对其进行增强，采用Map '
            '基本相同的api。阅读以下内容时遇到不懂的，请先科普阮一峰老师的ECMAScript 6 '
            '入门下面是基本代码，会在此基础上进行增强class MinCache {\r\n'
            '  // 将数据存储在本地缓存中指定的 name 中\r\n'
            '  set (name, data) {\r\n'
            '    try {\r\n'
            '      uni.setStorageSync(name, data)\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '  }\r\n'
            '  // 从本地缓存中获取指定 name 对应的内容\r\n'
            '  get (name) {\r\n'
            '    let data\r\n'
            '    try {\r\n'
            '      data = uni.getStorageSync(name)\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '    return data\r\n'
            '  }\r\n'
            '  // 从本地缓存中移除指定 key\r\n'
            '  delete (name) {\r\n'
            '    try {\r\n'
            '      uni.removeStorageSync(name)\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '  }\r\n'
            '  // 返回一个布尔值，表示 name 是否在本地缓存之中\r\n'
            '  has (name) {\r\n'
            '    const value\r\n'
            '    try {\r\n'
            '      const res = uni.getStorageInfoSync()\r\n'
            '      value = res.keys.includes(name)\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '    return value\r\n'
            '  }\r\n'
            '  // 清理本地数据缓存\r\n'
            '  clear () {\r\n'
            '    try {\r\n'
            '      uni.clearStorageSync()\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            'export default MinCache复制代码我们知道缓存往往是有危害的，那么我们最好规定个时间来去除数据。class '
            'CacheCell {\r\n'
            '  constructor (data, timeout) {\r\n'
            '    this.data = data\r\n'
            '    // 设置超时时间，单位秒\r\n'
            '    this.timeout = timeout\r\n'
            '    // 对象创建时候的时间\r\n'
            '    this.createTime = Date.now()\r\n'
            '  }\r\n'
            '}复制代码set (name, data, timeout = 1200) {\r\n'
            '    const cachecell = new CacheCell(data, timeout)\r\n'
            '    try {\r\n'
            '      uni.setStorageSync(name, cachecell)\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '  }\r\n'
            '  get (name) {\r\n'
            '    let data = null\r\n'
            '    try {\r\n'
            '      data = uni.getStorageSync(name)\r\n'
            '      if (!data) return null\r\n'
            '      const currentTime = Date.now()\r\n'
            '      const overTime = (currentTime - data.createTime) / 1000\r\n'
            '      if (overTime > data.timeout) {\r\n'
            '        try {\r\n'
            '          uni.removeStorageSync(name)\r\n'
            '          data = null\r\n'
            '        } catch (e) {\r\n'
            '          console.log(e)\r\n'
            '        }\r\n'
            '      }\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '    return data\r\n'
            '  '
            '}复制代码使用了过期时间进行缓存的方式，已经可以满足绝大部分的业务场景。uni-app的Storage在不同端的实现不同：H5端为localStorage，浏览器限制5M大小，是缓存概念，可能会被清理App端为原生的plus.storage，无大小限制，不是缓存，持久化各个小程序端为其自带的storage '
            'api，数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。微信小程序单个 key '
            '允许存储的最大数据长度为 1MB，所有数据存储上限为 '
            '10MB。支付宝小程序单条数据转换成字符串后，字符串长度最大200*1024。同一个支付宝用户，同一个小程序缓存总上限为10MB。百度、头条小程序文档未说明大小限制除此之外，H5端还支持websql、indexedDB、sessionStorage；App端还支持SQLite、IO文件等本地存储方案。我们可以看出来Storage在一些端中是有大小限制的，其实我们的数据只是想要缓存，不一定要持久化。也就是说在应用程序生命周期内使用就行，而且直接操作Storage也不是很好。我们知道ES6中有Map可以做缓存下面代码时基于Map封装的let '
            'cacheMap =  new Map()\r\n'
            'let instance = null\r\n'
            'let timeoutDefault = 1200\r\n'
            '\r\n'
            'function isTimeout (name) {\r\n'
            '  const data = cacheMap.get(name)\r\n'
            '  if (!data) return true\r\n'
            '  if (data.timeout === 0) return false\r\n'
            '  const currentTime = Date.now()\r\n'
            '  const overTime = (currentTime - data.createTime) / 1000\r\n'
            '  if (overTime > data.timeout) {\r\n'
            '    cacheMap.delete(name)\r\n'
            '    return true\r\n'
            '  }\r\n'
            '  return false\r\n'
            '}\r\n'
            '\r\n'
            'class CacheCell {\r\n'
            '  constructor (data, timeout) {\r\n'
            '    this.data = data\r\n'
            '    this.timeout = timeout\r\n'
            '    this.createTime = Date.now()\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            'class Cache {\r\n'
            '  set (name, data, timeout = timeoutDefault) {\r\n'
            '    const cachecell = new CacheCell(data, timeout)\r\n'
            '    return cacheMap.set(name, cachecell)\r\n'
            '  }\r\n'
            '  get (name) {\r\n'
            '    return isTimeout(name) ? null : cacheMap.get(name).data\r\n'
            '  }\r\n'
            '  delete (name) {\r\n'
            '    return cacheMap.delete(name)\r\n'
            '  }\r\n'
            '  has (name) {\r\n'
            '    return !isTimeout(name)\r\n'
            '  }\r\n'
            '  clear () {\r\n'
            '    return cacheMap.clear()\r\n'
            '  }\r\n'
            '  setTimeoutDefault (num) {\r\n'
            '    if (timeoutDefault === 1200) {\r\n'
            '      return timeoutDefault = num\r\n'
            '    }\r\n'
            "    throw Error('缓存器只能设置一次默认过期时间')\r\n"
            '  }\r\n'
            '}\r\n'
            '\r\n'
            'class ProxyCache {\r\n'
            '  constructor () {\r\n'
            '    return instance || (instance = new Cache())\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            'export default '
            'ProxyCache复制代码对Storage和Map封装的缓存进行整合我们来分析一下Storage和Map共用一套api在命名上解决以下划线_开头命名的缓存到Storage，并且Map也有副本尽量不操作Storage(读取速度慢)那就必须在应用程序初始化的时候把Storage加载进Map像Vue插件一样使用let '
            'cacheMap =  new Map()\r\n'
            'let timeoutDefault = 1200\r\n'
            '\r\n'
            'function isTimeout (name) {\r\n'
            '  const data = cacheMap.get(name)\r\n'
            '  if (!data) return true\r\n'
            '  if (data.timeout === 0) return false \r\n'
            '  const currentTime = Date.now()\r\n'
            '  const overTime = (currentTime - data.createTime) / 1000\r\n'
            '  if (overTime > data.timeout) {\r\n'
            '    cacheMap.delete(name)\r\n'
            "    if (name.startsWith('_')) {\r\n"
            '      try {\r\n'
            '        uni.removeStorageSync(name)\r\n'
            '      } catch (e) {\r\n'
            '        console.log(e)\r\n'
            '      }\r\n'
            '    }\r\n'
            '    return true\r\n'
            '  }\r\n'
            '  return false\r\n'
            '}\r\n'
            '\r\n'
            'class CacheCell {\r\n'
            '  constructor (data, timeout) {\r\n'
            '    this.data = data\r\n'
            '    this.timeout = timeout\r\n'
            '    this.createTime = Date.now()\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            'class MinCache {\r\n'
            '  constructor (timeout) {\r\n'
            '    try {\r\n'
            '      const res = uni.getStorageInfoSync()\r\n'
            '      res.keys.forEach(name => {\r\n'
            '        try {\r\n'
            '          const value = uni.getStorageSync(name)\r\n'
            '          cacheMap.set(name, value)\r\n'
            '        } catch (e) {\r\n'
            '          console.log(e)\r\n'
            '        }\r\n'
            '      })\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '    timeoutDefault = timeout\r\n'
            '  }\r\n'
            '  set (name, data, timeout = timeoutDefault) {\r\n'
            '    const cachecell = new CacheCell(data, timeout)\r\n'
            '    let cache = null\r\n'
            "    if (name.startsWith('_')) {\r\n"
            '      try {\r\n'
            '        uni.setStorageSync(name, cachecell)\r\n'
            '        cache = cacheMap.set(name, cachecell)\r\n'
            '      } catch (e) {\r\n'
            '        console.log(e)\r\n'
            '      }\r\n'
            '    } else {\r\n'
            '      cache = cacheMap.set(name, cachecell)\r\n'
            '    }\r\n'
            '    return cache\r\n'
            '  }\r\n'
            '  get (name) {\r\n'
            '    return isTimeout(name) ? null : cacheMap.get(name).data\r\n'
            '  }\r\n'
            '  delete (name) {\r\n'
            '    let value = false\r\n'
            "    if (name.startsWith('_')) {\r\n"
            '      try {\r\n'
            '        uni.removeStorageSync(name)\r\n'
            '        value = cacheMap.delete(name)\r\n'
            '      } catch (e) {\r\n'
            '        console.log(e)\r\n'
            '      }\r\n'
            '    } else {\r\n'
            '      value = cacheMap.delete(name)\r\n'
            '    }\r\n'
            '    return value\r\n'
            '  }\r\n'
            '  has (name) {\r\n'
            '    return !isTimeout(name)\r\n'
            '  }\r\n'
            '  clear () {\r\n'
            '    let value = false\r\n'
            '    try {\r\n'
            '      uni.clearStorageSync()\r\n'
            '      cacheMap.clear()\r\n'
            '      value = true\r\n'
            '    } catch (e) {\r\n'
            '      console.log(e)\r\n'
            '    }\r\n'
            '    return value\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            'MinCache.install = function (Vue, {timeout = 1200} = {}) {\r\n'
            '  Vue.prototype.$cache = new MinCache(timeout)\r\n'
            '}\r\n'
            '\r\n'
            'export default '
            'MinCache复制代码使用方法name以下划线_开头命名的缓存到Storage，并且Map也有副本事件名参数说明返回值setname缓存的key,data缓存的数据,timeout(必须数字单位s)缓存时间，默认缓存1200s, '
            'timeout设置为0表示永久缓存设置缓存数据Map集合getname缓存的key获取数据(缓存过期将返回null)返回缓存的数据datahasname缓存的key检查值true/falsedeletename缓存的key删除数据true/falseclear-清空Storage和Map缓存数据true/false// '
            '注册缓存器\r\n'
            'Vue.use(MinCache)\r\n'
            '// 设置默认缓存时间\r\n'
            '// Vue.use(MinCache, {timeout: 600})复制代码// '
            "'name'不是以下划线开头的表示会缓存到Map中，在程序生命周期内有并且在有效时间内有效\r\n"
            "this.$cache.set('name', 'MinCache')\r\n"
            '\r\n'
            '// 过期时间设置为0表示不会过期\r\n'
            "// 注意：'test'并不是以下划线命名表示在程序生命周期永久缓存\r\n"
            "this.$cache.set('test', 'testdemo', 0)\r\n"
            '\r\n'
            '// 过期时间设置为0表示不会过期\r\n'
            "// 注意：'_imgURL'是以下划线命名表示永久缓存到Storage\r\n"
            "this.$cache.set('_imgURL', 'data', 0)复制代码// 获取缓存的数据\r\n"
            "this.imgURL = this.$cache.get('_imgURL')\r\n"
            "this.name = this.$cache.get('name')\r\n"
            "this.test = this.$cache.get('test')复制代码具体使用方法可以参考\t"
            'githubuni-app路由的封装',
 'pub_time': '2019-6-19 00:34',
 'title': '基于uni-app的缓存器 '}
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5268-1.html>
{'author': 'Rolan',
 'content': 'halo，大家好，我是 132 ，好久不贱~今天给大家带来的是一个 fre 转小程序的新框架，叫 '
            'fard，它使用了非常精彩的思路，将 fre 代码跑到小程序环境里背景当下国内前端环境中，几乎每一个框架作者最终都会研究小程序，如 '
            'nerv 和 taro，anu 和 nanachi加上前阵子某人发微博说出 “hooks 无法用于别处，想用就得重新实现” '
            '这种膝盖言论我急迫的想要给 fre 一个归宿，寻找适用于 fre 的小程序方案现有方案在做 fard '
            '之前，我看了几乎所有的小程序框架，以下：编译型封装型tarowepynanachimpxmpvueuniappchameleon以上列举的只是常见的，还有很多小众的没有写出，小程序框架比小程序还多::>_<::编译型对于编译型框架，基本上就是 '
            'AST 转译，写 react/vue 的语法，编译出小程序的语法这样做的好处是理论上无所不能，啥都能转，甚至使用 parcel '
            '的策略能让编译速度很快但是致命缺陷是，全程写的不是真的 react，react '
            '内部的遍历过程根本没走，而且还需要制定足够严格的语法约定我认为，这个方向是走投无路的方向封装型封装型框架，基本就是对小程序的 '
            'API 进行封装，使其长得像 '
            'vue优点是能够最大程度的接近原生，缺点是没有足够的抽象层，无法跨端跨端了解完两种类型的框架，我们来探讨一下“跨端”跨端一直是很多人乐此不疲的事情，跨端的关键点在于寻找一个【抽象中间层】比如 '
            'taro 等使用 AST 作为抽象中间层flutter 使用各个端都支持的渲染引擎作为抽象中间层RN 自己搞了个 '
            'bridge，把桥作为抽象中间层weex 利用 v8 搞了个 runtime '
            '作为抽象中间层(以上仅仅是举例，不要深究他们的原理)所以，fard 只需要寻找一个中间层，就完事了Fard '
            '原理好吧，通篇，就这段是重点 ::>_<::首先，fard 是 fre 转小程序的框架，fre 是 react like '
            '框架，它包含了整个 reconcilerreconciler 全程都是 js 的遍历行为，能够跑在任何 js '
            '环境中，小程序也不例外所以最终 fard 的方案，就和 RN 类似，在小程序端跑 fre reconciler '
            '过程，跑完再通过某个【桥】反馈给小程序视图好吧，上图如图，首先，在小程序里，跑 fre reconciler '
            '的所有逻辑，hooks 就位于这个阶段，所以 hooks 所有逻辑，都是在 fre 中跑完的跑完后就好说了，我们拿到了一个 '
            'vdom (也可以说 fiber，但是我们只需要子集 vdom )拿到这个 vdom 后，就去 setData，附加给 '
            'Page好的，到这里，可以说全程 js 逻辑，该拿到的都拿到了，就差怎么反馈给视图了小程序自身也是 vdom '
            '机制的，如果说它默认提供 vdom 的接口的话，我们直接将 vdom 附加过去即可但是并没有，小程序开放的唯一的修改视图的方法就是 '
            'template所以我们需要根据 vdom 改造 template，使其成为桥梁这个也非常简单，比如 vdom 长这个样子：let '
            'vdom = {\r\n'
            "    name:'@2',\r\n"
            "    type:'view',\r\n"
            '    children:[\r\n'
            '        {\r\n'
            "            name:'@1',\r\n"
            "            type:'text'\r\n"
            '        }\r\n'
            '    ]\r\n'
            '}\r\n'
            '复制代码我们完全可以通过 template 模拟出来<template is="@2">\r\n'
            '    <view>\r\n'
            '        <block wx:for="{{props.children}}" wx:key="">\r\n'
            '            <template is="{{item.name}}"></template>\r\n'
            '      </block>\r\n'
            '    </view>\r\n'
            '</template>\r\n'
            '\r\n'
            '<template is="@1">\r\n'
            '    <text></text>\r\n'
            '</template>\r\n'
            '\r\n'
            '复制代码我们可以通过 template 模拟出整个 vdom，很好，bridge 就这么搞定了其实到这里，fard '
            '就搞定了剩下的就是，增加更多的 case，封装更多的通用 API，提高性能了综合分析我们看到 fard 是类似 RN '
            '的原理，我们高度抽象 fre 的 reconciler 层和小程序的 template '
            'bridge，使得整个设计非常的简单却精彩而且它能够完美的支持 jsx 和 hooks '
            'API，不存在任何约定任何限制任何规范毕竟，这才是 jsx 真正的意义同样的，hooks API '
            '自出现以来，关于它内部的黑魔法也一直令人津津乐道，我用实际行动证明，hooks API 完全可以用到任何端，也包括 '
            'webgl前提是要有设计精巧的抽象中间层',
 'pub_time': '2019-6-24 00:07',
 'title': '小程序框架原理综合分析和 fard 的新思路 '}
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5269-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5260-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5269-1.html>
{'author': 'Rolan',
 'content': '今天下午花了一下午时间把之前项目添加了对海报生成的支持,本代码已提交到微信，已通过审核，已发布，已经过本人验收，以下功能可用需要的同学可以移步下面链接https://gitee.com/jgl1210/eas...本代码实现功能1、海报上添加图片2、海报上添加文字3、海报下载4、海报保存到本地',
 'pub_time': '2019-6-24 00:26',
 'title': '小程序生成海报代码分享 '}
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5259-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5264-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5266-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5260-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5259-1.html>
{'author': 'Rolan',
 'content': '小程序目录结构关于小程序的目录结构，可以说一开始大家都有各自的开发习惯和命名规则，但一旦项目变得复杂庞大的时候，你就发现管理起来和后期维护变得很麻烦，如果是\xa0'
            '协同开发\xa0的话，更容易出现\xa0“互坑”\xa0'
            '的情况。智库君在一年多的小程序开发中也跳过不少的坑，总结了一套还算好维护的目录结构跟大家分享（仅供\xa0参考\xa0'
            '，觉得好拿去，觉得不好欢迎提出意见），以下是实战项目中的结构示例：├─  app.js    --- '
            '小程序加载时优先加载的入口JS\r\n'
            '├─  app.json   ---入口文件和公共配置\r\n'
            '├─  app.wxss     ---公共样式表\r\n'
            '├─  project.config.json     ---小程序全局配置文件\r\n'
            '├─  sitemap.json     ---允许微信索引文件\r\n'
            '│  \r\n'
            '├─cloud-functions     ---云函数\r\n'
            '│  └─setCrypto      ---数据加密模块，用户加密一些数据\r\n'
            '│          index.js\r\n'
            '│          package.json\r\n'
            '│          ...\r\n'
            '│          ...\r\n'
            '│          \r\n'
            '├─components      ---小程序自定义组件\r\n'
            '│  ├─plugins      --- （重点）可独立运行的大型模块，可以打包成plugins\r\n'
            '│  │  ├─comment         ---评论模块\r\n'
            '│  │  │  │  index.js\r\n'
            '│  │  │  │  index.json\r\n'
            '│  │  │  │  index.wxml\r\n'
            '│  │  │  │  index.wxss\r\n'
            '│  │  │  │  services.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n'
            '│  │  │  │      \r\n'
            '│  │  │  └─submit    ---评论模块子模块：提交评论\r\n'
            '│  │  │          index.js\r\n'
            '│  │  │          index.json\r\n'
            '│  │  │          index.wxml\r\n'
            '│  │  │          index.wxss\r\n'
            '│  │  │      \r\n'
            '│  │  └─canvasPoster     ---canvas海报生成模块\r\n'
            '│  │          index.js\r\n'
            '│  │          index.json\r\n'
            '│  │          index.wxml\r\n'
            '│  │          index.wxss\r\n'
            '│  │          services.js    '
            '---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n'
            '│  │     ...\r\n'
            '│  │     ...\r\n'
            '│  │          \r\n'
            '│  └─templates   ---（重点）模板，通过外部传参的容器，不做过多的数据处理\r\n'
            '│      │      \r\n'
            '│      ├─slideshow     ---滚屏切换模板\r\n'
            '│      │      index.js\r\n'
            '│      │      index.json\r\n'
            '│      │      index.wxml\r\n'
            '│      │      index.wxss\r\n'
            '│      │      service.js    '
            '---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n'
            '│      │      \r\n'
            '│      └─works       ---作品模板\r\n'
            '│          │  index.js\r\n'
            '│          │  index.json\r\n'
            '│          │  index.wxml\r\n'
            '│          │  index.wxss\r\n'
            '│          │  service.js\r\n'
            '│          │  \r\n'
            '│          ├─articlePlugin    ---作品模板中的文章类型\r\n'
            '│          │      index.js\r\n'
            '│          │      index.json\r\n'
            '│          │      index.wxml\r\n'
            '│          │      index.wxss\r\n'
            '│          │      \r\n'
            '│          ├─galleryPlugin    ---作品模板中的九宫格类型\r\n'
            '│          │      index.js\r\n'
            '│          │      index.json\r\n'
            '│          │      index.wxml\r\n'
            '│          │      index.wxss\r\n'
            '│          │      \r\n'
            '│          └─videoPlugin     ---作品模板中的视频类型\r\n'
            '│                  index.js\r\n'
            '│                  index.json\r\n'
            '│                  index.wxml\r\n'
            '│                  index.wxss\r\n'
            '│                  ...\r\n'
            '│                  ...\r\n'
            '│                  \r\n'
            '├─config     ---自定义配置文件\r\n'
            '│      config.js    ---存放基础配置\r\n'
            '│      constants.js   ---存储常量\r\n'
            '│      weui.wxss   ---第三方文件wxss，js等\r\n'
            '│      ...\r\n'
            '│      ...\r\n'
            '│      \r\n'
            '├─pages     ---小程序页面\r\n'
            '│  ├─user      ---用户页面\r\n'
            '│  │      index.js\r\n'
            '│  │      index.json\r\n'
            '│  │      index.wxml\r\n'
            '│  │      index.wxss\r\n'
            '│  ├─news      ---新闻页面\r\n'
            '│  │      index.js\r\n'
            '│  │      index.json\r\n'
            '│  │      index.wxml\r\n'
            '│  │      index.wxss\r\n'
            '│  │      \r\n'
            '│  └─home      ---首页\r\n'
            '│         index.js\r\n'
            '│         index.json\r\n'
            '│         index.wxml\r\n'
            '│         index.wxss\r\n'
            '│         ...   \r\n'
            '│         ...   \r\n'
            '│          \r\n'
            '├─request      ---https请求管理（根据switch tab分类会比较好）\r\n'
            '│      common.js    ---一些公共请求获取，如兑换openId,unionId 等\r\n'
            '│      news.js\r\n'
            '│      uri.js     --- （重点）总的URI请求管理，方便切换和配置DEV,QA,PROD环境\r\n'
            '│      user.js\r\n'
            '│      ...\r\n'
            '│      ...\r\n'
            '│      \r\n'
            '└─utils       ---功能组件\r\n'
            '        logger.js    ---日志管理\r\n'
            '        util.js       ---公共小组件库\r\n'
            '        ...\r\n'
            '        ...\r\n'
            '        \r\n'
            '复制代码例如微信自己的wepy的官方文档，现在也添加了目录结构说明：为什么一定要写这个目录结构呢？不知道大家有没有发现，在以往的老项目交接和多人协同开发中，容易遇到别人写的模块，变量命名不准确，或者资料缺损，一次十来个方法/组件间的互相调用，直接把接（盘）手的人整懵逼了，所以智库君觉得，无论是独立开发，还是协同开发，留一份完整的目录说明文档是很有必要的，\xa0'
            '勿坑他人 OR '
            '未来的自己~~~component使用心得大家在开发过程中肯定会去看官方文档，但不可能全看完才开始写代码，大多数情况都是用到了再看，本人也是，所以下面抽一些开发中遇到的重点来讲：一、引用组件模板页面的自定义组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。 '
            '在组件模板中可以提供一个 节点，用于承载组件引用时提供的子节点。<!-- 组件模板 -->\r\n'
            '<view class="wrapper">\r\n'
            '  <view>这里是组件的内部节点</view>\r\n'
            '  <slot></slot>\r\n'
            '</view>\r\n'
            '复制代码<!-- page页/父页面引用组件的页面模板 -->\r\n'
            '<view>\r\n'
            '  <component-tag-name>\r\n'
            '    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->\r\n'
            '    <view>这里是插入到组件slot中的内容</view>\r\n'
            '    <view>在加载组件的页面里自定义内容，将没有复用性的内容写在这里</view>\r\n'
            '  </component-tag-name>\r\n'
            '</view>\r\n'
            '复制代码页面自定义部分默认是加载在组件\xa0上方\xa0'
            '。为什么要在引用组件的页面添加这些内容呢？因为组件其中一个重要的特点是\xa0复用性\xa0'
            '，但是有的时候可能要根据不同场景做一些\xa0自定义\xa0'
            '，如果在组件中写大量的场景/逻辑判断，会增加组件的冗余，而且这些方法只是被\xa0复用一次\xa0'
            '的话，完全可以不写到组件里。二、“一键换肤”根据不同场景给组件引入外部样式<!-- 外部引用组件的页面传入样式 -->\r\n'
            '<WorkComponent extra-class="style1" '
            'j-data="{{workData}}"></WorkComponent>\r\n'
            '复制代码//组件中js\r\n'
            'Component({\r\n'
            '    /**\r\n'
            '    * 引入外部样式，可传多个class\r\n'
            '    */\r\n'
            "    externalClasses: ['extra-class','extra-class2'],\r\n"
            '})\r\n'
            '复制代码extra-class从外部引入父级css，可用根据不同场景配置不同的样式方案，这样使得组件自定义能力更强。三、数据清洗与容错//service.js  '
            '思路示例\r\n'
            'module.exports = {\r\n'
            '    /**\r\n'
            '     * 功能：处理作者列表\r\n'
            '     * @param list\r\n'
            '     * @returns {Array}\r\n'
            '     */\r\n'
            '    authorList: function (list = []) {\r\n'
            '        let result = [];\r\n'
            '        list.forEach(item => {\r\n'
            '            result.push({\r\n'
            "                guid: item.recommend_obj_id || '',\r\n"
            "                type: item.recommend_type || '',\r\n"
            "                logo: (item.theme_pic || '').trim() || '',\r\n"
            "                title: item.title || ''\r\n"
            '            });\r\n'
            '        });\r\n'
            '        return result;\r\n'
            '    }\r\n'
            '};\r\n'
            '复制代码如果外部传入的数据要分别导入多个组件中，可以在组件中建立一个对应的service.js，有2个作用：清洗数据，避免setData()的时有过多的脏数据错误数据的兼容，添加数据缺省值，增加代码健壮性四、canvas在component组件中无法选中的问题//这里只需要在后面 '
            '添加this对象\r\n'
            "    let ctx = wx.createCanvasContext('myCanvas', this);\r\n"
            '复制代码其他一些默认组件，遇到类似的问题，一般只要引用时传入this对象即可解决。五、组件之间的通讯在实际生产环境中，我们常常需要控制各个组件之间的互相通信/传参，下面介绍下具体的用法：WXML '
            '数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 '
            '开始，还可以在数据中包含函数）。具体在 组件模板和样式 '
            '章节中介绍。事件：用于子组件向父组件传递数据，可以传递任意数据。如果以上两种方式不足以满足需要，父组件还可以通过 '
            'this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。设置监听事件：<!-- '
            'wxml 中 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->\r\n'
            '<component-tag-name bindmyevent="setMyEvent" />\r\n'
            '<!-- 或者可以写成 -->\r\n'
            '<component-tag-name bind:myevent="setMyEvent" />\r\n'
            '复制代码// index.js 父页面中\r\n'
            'Page({\r\n'
            '  setMyEvent: function(e){\r\n'
            '    let self = this;\r\n'
            '    if (e.detail) { // 自定义组件触发事件时提供的detail对象\r\n'
            '      switch (e.detail) {\r\n'
            '        case "hidden":  //隐藏 悬浮框上的评论\r\n'
            '          this.setData({\r\n'
            '            isFixCommentShow: false\r\n'
            '          });\r\n'
            '          break;\r\n'
            '        case "fixRefresh":   //刷新悬浮框\r\n'
            '          this.setData({\r\n'
            '            fixRefresh: true\r\n'
            '          });\r\n'
            '          break;\r\n'
            '        case "commentRefresh":  //刷新评论\r\n'
            '          this.setData({\r\n'
            '            commentRefresh: Math.random()\r\n'
            '          });\r\n'
            '          break;\r\n'
            '        case "createPoster":  //生成海报组件\r\n'
            '          self.setPosterSave();\r\n'
            '          break;\r\n'
            '      }\r\n'
            '    }\r\n'
            '  }\r\n'
            '})\r\n'
            '复制代码父页面引用子组件，子组件发送的信息，可以通过bind的方法监听到，来获取到具体的传参值。触发事件自定义组件触发事件时，需要使用 '
            'triggerEvent方法，指定事件名、detail对象和事件选项：<!-- 页面 page.wxml -->\r\n'
            '<another-component bindcustomevent="pageEventListener1">\r\n'
            '   <my-component '
            'bindcustomevent="pageEventListener2"></my-component>\r\n'
            '</another-component>\r\n'
            '<!-- 组件 another-component.wxml -->\r\n'
            '<view bindcustomevent="anotherEventListener">\r\n'
            '   <slot />\r\n'
            '</view>\r\n'
            '<!-- 组件 my-component.wxml -->\r\n'
            '<view bindcustomevent="myEventListener">\r\n'
            '  <slot />\r\n'
            '</view>\r\n'
            '复制代码//组件中js\r\n'
            'Component({\r\n'
            '  properties: {},\r\n'
            '  methods: {\r\n'
            '    onTap: function(){\r\n'
            '        var myEventDetail = {} // detail对象，提供给事件监听函数\r\n'
            '        var myEventOption = {} // 触发事件的选项\r\n'
            "        this.triggerEvent('myevent', myEventDetail, "
            'myEventOption)\r\n'
            '        //myEventOption的一些配置：\r\n'
            "        this.triggerEvent('customevent', {}, { bubbles: true }) "
            '// 会依次触发 pageEventListener2 、 pageEventListener1\r\n'
            "        this.triggerEvent('customevent', {}, { bubbles: true, "
            'composed: true }) // 会依次触发 pageEventListener2 、 '
            'anotherEventListener 、 pageEventListener1\r\n'
            '    }\r\n'
            '  }\r\n'
            '});\r\n'
            '复制代码myEventOption '
            '的配置：bubbles（Boolean）：事件是否冒泡composed（Boolean）：事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部capturePhase（Boolean）：事件是否拥有捕获阶段需要强调一点：建议大家不要在组件上bind太多的监听，一方面以后管理起来会比较麻烦，另一方面首次加载如果调用过多方法会引起数据渲染的卡顿。Component官方文档：\xa0'
            'developers.weixin.qq.com/miniprogram…往期回顾：[填坑手册]小程序Canvas生成海报（一）[拆弹时刻]小程序Canvas生成海报（二）',
 'pub_time': '2019-6-20 00:14',
 'title': '[填坑手册]小程序目录结构和组件化使用心得 '}
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5264-1.html>
{'author': 'Rolan',
 'content': '趁着最近下班比较早，还是有时间看下其他知识点。于是，自己屁颠屁颠的玩了下微信小程序。环境安装我使用的是\xa0mac\xa0'
            '电脑来开发，那我简单说下我自己的准备工作吧～首先，你需要一个良好的编辑器工具，我这里下载了\xa0'
            'sublime、vscode和微信开发者工具\xa0。我选择使用\xa0微信开发者工具\xa0'
            '进行开发，因为对开发者友好。有说vscode比较友好的，需要配置些东西，这就要百度一下了。然后，如果你的小程序要上线或需要使用里面比较完整的功能，你需要注册一个微信小程序，获取\xa0'
            'appId\xa0。我这里是学习而已，所以只是用微信提供的测试\xa0appId\xa0，这个测试\xa0appId\xa0'
            '在使用\xa0微信开发者工具\xa0新建项目的时候有得选择。嗯～就是这么简单，惊喜不～意外不:hushed:项目结构当你使用\xa0'
            '微信开发者工具\xa0'
            '新建项目的时候，它会自动帮你新建一个规范的项目目录结构。当然，我们也可以从零开始进行搭建啦。我下面简单罗列下我项目中的结构(截止2019年06月21日)：- '
            'app.js\r\n'
            '- app.json\r\n'
            '- assets\r\n'
            '  - tabbar\r\n'
            '\t- home_active.png\r\n'
            '\t- home.png\r\n'
            '\t- profile_active.png\r\n'
            '\t- profile.png\r\n'
            '- pages\r\n'
            '  - home\r\n'
            '\t- home.js\r\n'
            '\t- home.json\r\n'
            '\t- home.wxml\r\n'
            '\t- home.wxss\r\n'
            '  - profile\r\n'
            '\t- profile.js\r\n'
            '\t- profile.json\r\n'
            '\t- profile.wxml\r\n'
            '\t- profile.wxss\r\n'
            '- page.wxss\r\n'
            '- project.config.json\r\n'
            '- README.md\r\n'
            '复制代码也许你已经注意到了文件后缀名\xa0js, json, wxml, wxss\xa0'
            '。那么它们具体是干什么用的呢？js后缀名的文件是你写\xa0javascript\xa0'
            '的地方了，项目的一些逻辑代码。json后缀名的文件是你写页面的配置的地方，\xa0app.json\xa0是应用的整体配置，\xa0'
            'home.json\xa0是\xa0home\xa0页面的配置，\xa0profile.json\xa0是\xa0'
            'profile\xa0页面的配置。wxml后缀名的文件是你写页面骨架的地方，类似我们的\xa0html\xa0'
            '。wxss后缀名的文件是你写页面样式的地方，类似我们的\xa0css\xa0'
            '。练手项目在看了文档，百度了些资料，就开始想一个练手的项目 --\xa0github信息展示\xa0'
            '。首先，我们搭建好项目的目录，之后就是根据文档啥的进行我们的项目构思的实现了。具体的过程我这里就不赘述了，毕竟在文章后面会配上项目代码的github地址啦:dog:～我们来看下效果吧：',
 'pub_time': '2019-6-21 00:21',
 'title': '玩玩微信小程序（多图预警） '}
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5266-1.html>
{'author': 'Rolan',
 'content': '作者：wwayne原文：\xa0'
            '基于Proxy的小程序状态管理Fundebug经授权转载，版权归原作者所有。微信小程序的市场在进一步的扩大，而背后的技术社区仍在摸索着最好的实践方案。我在帮助Nike，沃尔玛以及一些创业公司开发小程序后，依旧认为使用小程序原生框架是一个更高效，稳定的选择，而使用原生框架唯独缺少一个好的状态管理库，如果不引入状态管理则会让我们在模块化，项目结构以及单元测试上都有些捉襟见肘。目前相对比较稳健的做法是针对redux或者mobx做一个adaptor应用到小程序中，但这样需要自己想办法打包引入外部库，还要想怎么去写这个adaptor，总显得有些麻烦。于是我迸发出一个想法去写一个专用于小程序的状态管理库，它使用起来足够简单并且可以通过小程序自己的npm机制安装。目前我已经用这个开源库开发了两个电商小程序，在提高我开发效率的同时亦保证了程序的性能，所以接下来我想谈谈这背后的理念以启发更多开发者尝试新的解决方案。基于Proxy的状态管理实现Proxy在小程序中已经得到了足够好的支持，目前并没有发现在任何iPhone或者Android上不能使用Proxy的情况。而基于Proxy的状态管理其实也就是订阅监听的模式，一方面监听数据的变化，另一方面将这些变化传达给订阅的小程序页面。举一个比较常见的例子，当一个用户从自己的主页进入用户编辑页面，然后更改了自己的用户名点击保存后，用户主页和用户编辑页上的用户名这时候都应该被更新。这背后的程序逻辑则是：更新这个行为将触发Proxy去通知状态管理库，然后状态管理库负责检查此时还在页面栈中的所有页面，更新订阅了用户名这个数据的页面，如下图：Part1: '
            '监听数据变化监听数据变化其实就是监听各个Store的属性变化，实现上就是在各个Store前面加了一层Proxy，用更直观的图片来表示就是这样：当一个Store被观察以后，它的属性就都变成了Proxy实例，当这个属性值是Object或者Array的时候，它内部的值也会被包装成Proxy实例，这样无论多深层的数据变动都能被监听到。而在Proxy的后面，Store的属性其实是被另一套数据(紫色部分)所维护，这套数据不负责监听，它就是纯数据，针对属性的任何变动最后都会应用到这套数据上来，它的作用是维护和返回最新的数据。实现细节：\xa0'
            'https://github.com/wwayne/min…Part2: '
            '页面数据绑定因为小程序每个页面的js都是向Page中传递一个对象，这就让我们有机会包装这个对象，从而实现：进入页面后，将页面保存在页面栈中将来自状态管理库的数据映射到这个页面的data上来页面退出时，将页面从页面栈中移除实现细节：\xa0'
            'https://github.com/wwayne/min…Part3： '
            '页面订阅更新当数据被监听到变化后，我们需要依次做两件事，先是找到所有存储在页面栈里的页面，然后根据各个页面订阅的数据来检查变化，如果有变化就通知这些页面，从而让它们去触发setData更新页面。实现细节：\xa0'
            'https://github.com/wwayne/min…使用状态管理的例子有了状态管理库，现在我们就来实现一开始举例的更新用户信息的操作，我们的文件路径如下：stores/\r\n'
            '  user.js\r\n'
            'pages/\r\n'
            '  userEdit/\r\n'
            '     index.js\r\n'
            '     index.wxml\r\n'
            '1. 首先我们创建一个Store保存用户的信息，并且监听它的变化：// stores/user.js\r\n'
            "import { observe } from 'minii'\r\n"
            '\r\n'
            'Class UserStore {\r\n'
            '  constructor () {\r\n'
            "     this.name = 'bob'\r\n"
            '  }\r\n'
            '\r\n'
            '  changeName (name) {\r\n'
            '     this.name = name\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            "export default observe(new UserStore(), 'user')\r\n"
            '2. 接着在我们的小程序页面订阅Store的信息// pages/userEdit/index.js\r\n'
            "import { mapToData } from 'minii'\r\n"
            "import userStore from '../../stores/user'\r\n"
            '\r\n'
            'const connect = mapToData(state => (({\r\n'
            '  myName: state.user.name\r\n'
            '}))\r\n'
            'Page(connect({\r\n'
            '  updateNameToJames () {\r\n'
            "    userStore. changeName('james')\r\n"
            '  }\r\n'
            '}))\r\n'
            '3. 完成，现在可以在页面中使用和更新数据了// pages/userEdit/index.wxml\r\n'
            '<text>{{ myName }}</text>\r\n'
            '<button bindtap="updateNameToJames">update name to '
            'James</button>\r\n'
            '最后小程序因为有体积的限制，所以我希望在代码量上也尽量做到轻量和便捷，所以目前这个状态管理库并没有太多很复杂的功能，在小程序打包后所占用的体积也不到1kb，颇有点够用就好的意思。我也已经用它开发了两款小程序，在经历了一段时间的用户使用后，我也更有信心说这个方案在小程序中是可行的。如果你有任何想法和建议，都欢迎告诉我。项目Github:\xa0'
            'https://github.com/wwayne/minii关于作者Hi, '
            '我是wwayne，是一名居住在上海的独立软件工程师，我正在开发我的新产品\xa0talk-to-kim\xa0, 你可以在\xa0'
            'Github\xa0或者专栏\xa0一个人写代码\xa0找到我',
 'pub_time': '2019-6-21 00:34',
 'title': '基于Proxy的小程序状态管理 '}
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5174-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5270-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5174-1.html>
{'author': 'Rolan',
 'content': '用小程序的animation属性实现循环动画的开启与暂停，并封装到组件。\r\n'
            '\r\n'
            '实现一个字体图标组件的循环旋转动画开启/暂停\r\n'
            '\r\n'
            '\r\n'
            '用于点击图标，字体颜色变换，开始循环旋转动画，并刷新内容\r\n'
            '\r\n'
            '\r\n'
            '刷新结束，停止动画，并设置字体颜色为原来的\r\n'
            '\r\n'
            '\r\n'
            '主要利用setInterval定时器循环执行动画\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '首先，组件写出来\r\n'
            '添加点击事件，动画属性，style属性（用来动态修改样式）\r\n'
            '\r\n'
            'src/components/refresh.vue\r\n'
            '\r\n'
            '<template>\r\n'
            '  <div>\r\n'
            '    <div\r\n'
            '      class="iconfont icon-shuaxin"\r\n'
            "      :animation='refreshA'\r\n"
            '      @click="refresh"\r\n'
            "      :style='style'></div>\r\n"
            '  </div>\r\n'
            '</template>\r\n'
            '复制代码设置初始数据\r\n'
            '使用一个 布尔 数据refreshing判断动画的状态为开启true/暂停false\r\n'
            '<script>\r\n'
            'export default {\r\n'
            '  data () {\r\n'
            '    return {\r\n'
            '      refreshA: null,\r\n'
            "      style: 'color: #eee;',\r\n"
            '      // 用来设置存储旋转的度数\r\n'
            '      rotate: 0,\r\n'
            '      // 存储定时器id\r\n'
            '      refreshI: null\r\n'
            '    }\r\n'
            '  },\r\n'
            "  props: ['refreshing']\r\n"
            '}\r\n'
            '</script>\r\n'
            '复制代码添加点击事件函数\r\n'
            '<script>\r\n'
            'export default {\r\n'
            '  methods: {\r\n'
            '    // 刷新按钮点击\r\n'
            '    refresh () {\r\n'
            '      // 正在刷新 则跳出，避免在循环动画执行时，再次出发点击刷新事件\r\n'
            '      if (this.refreshing) return\r\n'
            '      // 否则提交刷新事件\r\n'
            "      this.$emit('refresh')\r\n"
            '    },\r\n'
            '    // 刷新动画结束\r\n'
            '    refreshend () {\r\n'
            '    \t// 当动画结束，字体颜色恢复原来\r\n'
            "      this.style = 'color: #eee;'\r\n"
            '    }\r\n'
            '  }\r\n'
            '}\r\n'
            '</script>\r\n'
            '复制代码监听refreshing状态\r\n'
            '<script>\r\n'
            'export default {\r\n'
            '  watch: {\r\n'
            '    refreshing (newV, oldV) {\r\n'
            '      // 没有正在刷新 > 正在刷新 设置循环动画\r\n'
            '      if (newV && !oldV) {\r\n'
            "        this.style = 'color: #fff;'\r\n"
            '        this.refreshI = setInterval(() => {\r\n'
            '        // 每次 +360 实现每 300 毫秒旋转 360 度  \r\n'
            '          this.rotate += 360\r\n'
            '          let animation = wx.createAnimation()\r\n'
            '          animation.rotateZ(this.rotate).step()\r\n'
            '          this.refreshA = animation.export()\r\n'
            '        }, 300)\r\n'
            '        return\r\n'
            '      }\r\n'
            '      // 从正在刷新 > 刷新完成  清空循环定时器动画\r\n'
            '      if (!newV && oldV) {\r\n'
            '        // 防止网速过快，动画队列还没生成就刷新完成，这里判断动画队列是否为空\r\n'
            '        // 为空，就重置一下样式\r\n'
            "        this.style = 'color: #eee;'\r\n"
            '        \r\n'
            '        clearInterval(this.refreshI)\r\n'
            '        this.refreshA = null\r\n'
            '      }\r\n'
            '    }\r\n'
            '  }\r\n'
            '}\r\n'
            '</script>\r\n'
            '复制代码\r\n'
            '需要注意的是定时器时间必须和动画的过渡时间设置为相同\r\n'
            '\r\n'
            '组件调用\r\n'
            '\r\n'
            'src/pages/index/index.vue\r\n'
            '\r\n'
            '<template>\r\n'
            '  <div>\r\n'
            "    <Refresh @refresh='refresh' :refreshing='refreshing'/>\r\n"
            '  </div>\r\n'
            '</template>\r\n'
            '\r\n'
            '<script>\r\n'
            "import Refresh from '@/components/refresh'\r\n"
            '\r\n'
            'export default {\r\n'
            '  data: {\r\n'
            '    // 初始状态肯定为 false ,点击刷新组件后，在事件函数中再设置为 true\r\n'
            '    refreshing: false\r\n'
            '  },\r\n'
            '  components: {\r\n'
            '    Refresh\r\n'
            '  },\r\n'
            '  methods: {\r\n'
            '    async refresh () {\r\n'
            '    this.refreshing = true\r\n'
            '    // 这里为一个异步请求api\r\n'
            '    let data = await api.getData()\r\n'
            '    // 请求完成，执行想要操作的代码后，设置动画为 false\r\n'
            '    // this.data = data\r\n'
            '    this.refreshing = false\r\n'
            '    }\r\n'
            '  }\r\n'
            '}\r\n'
            '</script>\r\n'
            '\r\n'
            '<style lang="stylus" scoped>\r\n'
            '</style>\r\n'
            '复制代码refresh组件完整代码\r\n'
            '<template>\r\n'
            '  <div>\r\n'
            '    <div\r\n'
            '      class="iconfont icon-shuaxin"\r\n'
            "      :animation='refreshA'\r\n"
            '      @click="refresh"\r\n'
            "      :style='style'></div>\r\n"
            '  </div>\r\n'
            '</template>\r\n'
            '\r\n'
            '<script>\r\n'
            'export default {\r\n'
            '  data () {\r\n'
            '    return {\r\n'
            '      refreshA: null,\r\n'
            "      style: 'color: #eee;',\r\n"
            '      rotate: 0,\r\n'
            '      refreshI: null\r\n'
            '    }\r\n'
            '  },\r\n'
            "  props: ['refreshing'],\r\n"
            '  watch: {\r\n'
            '    refreshing (newV, oldV) {\r\n'
            '      if (newV && !oldV) {\r\n'
            "        this.style = 'color: #fff;'\r\n"
            '        this.refreshI = setInterval(() => {\r\n'
            '          this.rotate += 360\r\n'
            '          let animation = wx.createAnimation()\r\n'
            '          animation.rotateZ(this.rotate).step()\r\n'
            '          this.refreshA = animation.export()\r\n'
            '        }, 300)\r\n'
            '        return\r\n'
            '      }\r\n'
            '      if (!newV && oldV) {\r\n'
            "        this.style = 'color: #eee;'\r\n"
            '        clearInterval(this.refreshI)\r\n'
            '        this.refreshA = null\r\n'
            '      }\r\n'
            '    }\r\n'
            '  },\r\n'
            '  methods: {\r\n'
            '    refresh () {\r\n'
            '      if (this.refreshing) return\r\n'
            "      this.$emit('refresh')\r\n"
            '    },\r\n'
            '    refreshend () {\r\n'
            "      this.style = 'color: #eee;'\r\n"
            '    }\r\n'
            '  }\r\n'
            '}\r\n'
            '</script>\r\n'
            '\r\n'
            '<style lang="stylus" scoped>\r\n'
            '</style>\r\n'
            '\r\n'
            '复制代码效果\r\n'
            '\r\n'
            '正常效果，看图中右上角\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '网速太快',
 'pub_time': '2019-5-15 00:35',
 'title': 'mpvue小程序循环动画开启暂停 '}
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5175-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:57 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5270-1.html>
{'author': 'Rolan',
 'content': '解决办法：在自定义组件内获取必须用SelectorQuery.in()Component({\r\n'
            '  lifetimes: {\r\n'
            '    ready() {\r\n'
            '      const query = wx.createSelectorQuery().in(this)\r\n'
            '      const num = Math.ceil(this.data.picList.length / '
            'LINE_LENGTH)\r\n'
            "      query.select('.tab-content-item').boundingClientRect((rect) "
            '=> {\r\n'
            '        this.setData({\r\n'
            "          swiperHeight: rect.height * num + 'rpx'\r\n"
            '        })\r\n'
            '      }).exec()\r\n'
            '    }\r\n'
            '  },\r\n'
            '})const query = '
            'wx.createSelectorQuery().in(this)这一句是最重要的，要用.in(this)，this传入的是自定义组件的实例。否则获取到的rect值为null',
 'pub_time': '2019-6-24 00:36',
 'title': '微信小程序自定义组件boundingClientRect获取到的rect值为null '}
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5178-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:57 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5177-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5175-1.html>
{'author': 'Rolan',
 'content': '问题描述：在前端想获取数据库某集合中的数据时，返回的参数data始终为空数组，如下：相关代码如下：const db = '
            'wx.cloud.database();\r\n'
            "const activityInfo = db.collection('activityInfo');\r\n"
            '\r\n'
            'Page({\r\n'
            '    ...省略不相干代码...\r\n'
            '        \r\n'
            '        onLoad(){\r\n'
            '            activityInfo.get().then((res)=>{\r\n'
            '                console.log(res)\r\n'
            '            })\r\n'
            '        }\r\n'
            '            \r\n'
            '    \r\n'
            '    ...省略不相干代码...\r\n'
            '})解决方案:数据库新建的collectioin需要设置权限，没有问题就可以读取和更新了;小程序云开发控制台->你的集合名称->权限设置->所有用户可读，仅创建者可读写结果:成功获取到数据！',
 'pub_time': '2019-5-15 00:49',
 'title': '解决微信小程序云开发中获取数据库的内容为空 '}
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5183-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5178-1.html>
{'author': 'Rolan',
 'content': '说明最近有些空余时间开始着手优化我那个\xa0吉他自学小助手\xa0'
            '的微信小程序，其中有一个功能是下载吉他谱到本地，开始以为只是很简单的拿到图片url然后down下来就好了，其实不然…最终通过google解决了这个问题，现在记录一下，以便后续翻阅。少废话先看东西流程梳理获取图片远程地址数组–>遍历拿到图片缓存（临时地址）(wx.getImageInfo)–>保存缓存图片到本地（wx.saveImageToPhotosAlbum）完整代码子组件代码逻辑//子组件download-file.vue\r\n'
            '<template>\r\n'
            '  <div></div>\r\n'
            '</template>\r\n'
            '\r\n'
            '<script>\r\n'
            'export default {\r\n'
            '  props: {\r\n'
            '    urls: {\r\n'
            '      default: ""//通过父组件传递远程图片路径数组\r\n'
            '    }\r\n'
            '  },\r\n'
            '  watch: {\r\n'
            '    urls() {\r\n'
            '      if (this.urls.length > 0) {\r\n'
            '        this.downLoadImage(this.urls);//监听变化\r\n'
            '      }\r\n'
            '    }\r\n'
            '  },\r\n'
            '  methods: {\r\n'
            '  \t//拿到图片的临时路径\r\n'
            '    getImageInfo(url) {\r\n'
            '      var cache = {};\r\n'
            '      return new Promise((resolve, reject) => {\r\n'
            '        /* 获得要在画布上绘制的图片 */\r\n'
            '        if (cache[url]) {\r\n'
            '          resolve(cache[url]);\r\n'
            '        } else {\r\n'
            '          const objExp = new RegExp(\r\n'
            '            /^http(s)?:\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- '
            '.\\/?%&=]*)?/\r\n'
            '          );\r\n'
            '          if (objExp.test(url)) {\r\n'
            '            wx.getImageInfo({\r\n'
            '              src: url,\r\n'
            '              complete: res => {\r\n'
            '                if (res.errMsg === "getImageInfo:ok") {\r\n'
            '                  cache[url] = res.path;\r\n'
            '                  resolve(res.path);\r\n'
            '                } else {\r\n'
            '                  reject(new Error("getImageInfo fail"));\r\n'
            '                }\r\n'
            '              }\r\n'
            '            });\r\n'
            '          } else {\r\n'
            '            this.cache[url] = url;\r\n'
            '            resolve(url);\r\n'
            '          }\r\n'
            '        }\r\n'
            '      });\r\n'
            '    },\r\n'
            '    downLoadImage(urls) {\r\n'
            '      const vm = this;\r\n'
            '      let temp = [];\r\n'
            '      if (urls.length > 0) {\r\n'
            '        urls.map((item, index) => {\r\n'
            '          vm.getImageInfo(item).then(res => {\r\n'
            '            temp.push(res);\r\n'
            '            vm.saveImageToLocal(res);\r\n'
            '          });\r\n'
            '        });\r\n'
            '      }\r\n'
            '    },\r\n'
            '    saveImageToLocal(path) {\r\n'
            '      //保存临时图片到本地\r\n'
            '      wx.saveImageToPhotosAlbum({\r\n'
            '        filePath: path,\r\n'
            '        success(res) {\r\n'
            '          console.log("success");\r\n'
            '        },\r\n'
            '        fail: function(res) {\r\n'
            '          console.log(res);\r\n'
            '        }\r\n'
            '      });\r\n'
            '    }\r\n'
            '  }\r\n'
            '};\r\n'
            '</script>\r\n'
            '\r\n'
            '<style>\r\n'
            '</style>在父组件中引用//news/detail.vue\r\n'
            '//省略代码...\r\n'
            '<button @click="download">下载</button>\r\n'
            '//省略代码...\r\n'
            '<download-file :urls="downLoadUrls" '
            'ref="myDownload"></download-file>\r\n'
            '//省略代码...\r\n'
            'async download() {\r\n'
            '    let vm = this;\r\n'
            '    const temp = [];\r\n'
            '    let data = await vm.$net.get(vm.$apis.articleDetails, {\r\n'
            '        id: vm.item.id\r\n'
            '    });\r\n'
            '    if (data.article.body.length > 0) {\r\n'
            '      data.article.body.map((item, index) => {\r\n'
            '        if (item.type == "img") {\r\n'
            '          temp.push(item.data);\r\n'
            '        }\r\n'
            '    });\r\n'
            '  }\r\n'
            '  vm.downLoadUrls = temp;\r\n'
            '},Previous用weexplus从0到1写一个app(2)-页面跳转和文章列表及文章详情的编写',
 'pub_time': '2019-5-16 00:37',
 'title': '在微信小程序中下载图片到本地解决方案 '}
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5177-1.html>
{'author': 'Rolan',
 'content': '在开发小程序展开全文组件时需要用到节点查询API - wx.createSelectorQuery() '
            '来查询全文内容的高度。wx.createSelectorQuery() 返回一个 SelectorQuery '
            '对象实例。SelectorQuery '
            '有五个方法（in，select，selectAll，selectViewport，exec），第一个返回 '
            'SelectorQuery，后四个返回 NodesRef。NodesRef '
            '有四个方法（fields，boundingClientRect，scrollOffset，context），第一个返回 '
            'NodesRef，后三个返回 SelectorQuery。对照官方提供的示例代码来看const query = '
            'wx.createSelectorQuery() // query 是 SelectorQuery 对象\r\n'
            "query.select('#the-id').boundingClientRect() // select 后是 "
            'NodesRef 对象，然后 boundingClientRect 返回 SelectorQuery 对象\r\n'
            'query.selectViewport().scrollOffset() // selectViewport 后是 '
            'NodesRef 对象，然后 scrollOffset 返回 SelectorQuery 对象\r\n'
            'query.exec(function (res) { // exec 返回 NodesRef 对象\r\n'
            '  res[0].top // #the-id节点的上边界坐标\r\n'
            '  res[1].scrollTop // 显示区域的竖直滚动位置\r\n'
            '})问题：每行执行返回的 SelectorQuery 对象是相同的吗？答案：是的，都是同一个对象。问题：直接执行 '
            "query.select('#the-id').boundingClientRect().exec "
            '也可以吗？答案：可以，boundingClientRect() 返回就是 query。问题：这样连写 '
            "query.select('#the-id').boundingClientRect().selectViewport().scrollOffset() "
            '算两条查询请求吗？答案：是两条请求。问题：query.exec '
            '执行后会清空前面的查询请求吗？再次执行还能拿到结果吗？答案：可以，query不会清空请求。问题：boundingClientRect '
            '和 scrollOffset 可以接受 callback 参数，它与 query.exec 执行顺序是怎样，修改 res '
            '结果会影响到后面的 callback 吗？答案：先执行 boundingClientRect 和 scrollOffset 的 '
            'callback，再执行 query.exec 的 callback；修改 res 结果会影响到后面 exec '
            '的结果。上面的问题通过 WAService.js 源码简单美化后可以了解 SelectorQuery 的代码逻辑class '
            'NodesRef {\r\n'
            '  constructor(selectorQuery, component, selector, single) {\r\n'
            '    this._selectorQuery = selectorQuery;\r\n'
            '    this._component = component;\r\n'
            '    this._selector = selector;\r\n'
            '    this._single = single;\r\n'
            '  }\r\n'
            '  fields(e, t) {\r\n'
            '    this._selectorQuery._push(this._selector, this._component, '
            'this._single,\r\n'
            '      e,\r\n'
            '      t,\r\n'
            '    );\r\n'
            '    return this._selectorQuery\r\n'
            '  }\r\n'
            '  boundingClientRect(callback) {\r\n'
            '    this._selectorQuery._push( this._selector, this._component, '
            'this._single,\r\n'
            '      {\r\n'
            '        id: true,\r\n'
            '        dataset: true,\r\n'
            '        rect: true,\r\n'
            '        size: true,\r\n'
            '      },\r\n'
            '      callback,\r\n'
            '    );\r\n'
            '    return this._selectorQuery;\r\n'
            '  }\r\n'
            '  scrollOffset(callback) {\r\n'
            '    this._selectorQuery._push( this._selector, this._component, '
            'this._single,\r\n'
            '      {\r\n'
            '        id: true,\r\n'
            '        dataset: true,\r\n'
            '        scrollOffset: true,\r\n'
            '      },\r\n'
            '      callback,\r\n'
            '    );\r\n'
            '    return this._selectorQuery;\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            "let pluginId = '';\r\n"
            'class SelectorQuery {\r\n'
            '  constructor(e) {\r\n'
            '    if (e && e.page) {\r\n'
            '      this._component = this._defaultComponent = e.page;\r\n'
            '      this._webviewId = '
            'this._defaultComponent.__wxWebviewId__;\r\n'
            '    } else {\r\n'
            '      var pages = '
            "__internalGlobal__.getCurrentPagesByDomain('');\r\n"
            '      this._defaultComponent = pages[pages.length - 1],\r\n'
            '      this._component = null;\r\n'
            '      this._webviewId = null;\r\n'
            '    }\r\n'
            '    this._queue = [];\r\n'
            '    this._queueCb = [];\r\n'
            '  }\r\n'
            '  in(component) {\r\n'
            '    if (!this._webviewId) {\r\n'
            '      this._webviewId = component.__wxWebviewId__;\r\n'
            '      this._component = component;\r\n'
            '    } else if (this._webviewId !== component.__wxWebviewId__) '
            '{\r\n'
            "      console.error('A single SelectorQuery could not work in "
            'components in different pages. A SelectorQuery#in call has been '
            "ignored.');\r\n"
            '    } else {\r\n'
            '      this._component = component;\r\n'
            '    }\r\n'
            '    return this;\r\n'
            '  }\r\n'
            '  select(selector) {\r\n'
            '    return new NodesRef(this, this._component, selector, '
            'true);\r\n'
            '  }\r\n'
            '  selectAll(selector) {\r\n'
            '    return new NodesRef(this, this._component, selector, '
            'false);\r\n'
            '  }\r\n'
            '  selectViewport() {\r\n'
            "    return new NodesRef(this, 0, '', true);\r\n"
            '  }\r\n'
            '  _push(selector, component, single, fields, callback) {\r\n'
            '    if (!this._webviewId) {\r\n'
            '      this._webviewId = this._defaultComponent ? '
            'this._defaultComponent.__wxWebviewId__ : undefined;\r\n'
            '    }\r\n'
            "    const rootNodeId = pluginId ? '' : "
            'r.getRootNodeId(this._webviewId);\r\n'
            '    this._queue.push({\r\n'
            '      component: null != component ? (0 === component ? 0 : '
            'component.__wxExparserNodeId__) : rootNodeId,\r\n'
            '      selector,\r\n'
            '      single,\r\n'
            '      fields,\r\n'
            '    });\r\n'
            '    this._queueCb.push(callback || null);\r\n'
            '  }\r\n'
            '  exec(callback) {\r\n'
            '    hd(this._webviewId, {\r\n'
            '      pluginId,\r\n'
            '      queue: this._queue,\r\n'
            '    }, (results) => {\r\n'
            '      const queueCb = this._queueCb;\r\n'
            '      results.forEach((res, index) => {\r\n'
            "        if ('function' == typeof queueCb[index]) {\r\n"
            '          queueCb[index].call(this, res);\r\n'
            '        }\r\n'
            '      });\r\n'
            "      if ('function' == typeof callback) {\r\n"
            '        callback.call(this, results);\r\n'
            '      }\r\n'
            '    })\r\n'
            '  }\r\n'
            '}',
 'pub_time': '2019-5-16 00:12',
 'title': '微信小程序之SelectorQuery '}
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5179-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5183-1.html>
{'author': 'Rolan',
 'content': '最终效果\r\n'
            '\r\n'
            '一、要实现的功能\r\n'
            '\r\n'
            '\r\n'
            '展示地图。\r\n'
            '\r\n'
            '参考map组件\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '在地图上展示多个店铺。\r\n'
            '\r\n'
            'marker标记点用于在地图上显示标记的位置。\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '点击店铺放大图标，展示选择的店铺信息。\r\n'
            '\r\n'
            '更改选择店铺的标记尺寸大小。\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '在地图中心点放一个可视化标记。\r\n'
            '\r\n'
            'cover-view标签防止一个标记图片，订到在地图大小的中心，自行调试。\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '移动后获取地图中心点位置，选择最近一个店铺。\r\n'
            '\r\n'
            'map的bindregionchange事件，视野发生变化时触发，重新请求，把最近一家店铺修改标记尺寸大小（有注意事项）。\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '移动后根据屏幕中心点坐标逆地址解析成中文地址（详细看第四）。\r\n'
            '\r\n'
            '\r\n'
            '增加选择其他城市页面（封装成组件了，点击这里查看）。\r\n'
            '\r\n'
            '\r\n'
            '点击其他城市，根据城市名称地址解析成坐标，更新视图（详细看第四）。\r\n'
            '\r\n'
            '\r\n'
            '二、注意事项\r\n'
            '\r\n'
            '每次更新视图都会触发bindregionchange事件，如果在里面获取到地图视图中心点坐标重新赋值给地图坐标的话，会造成这个事件不断的触发。\r\n'
            '每次拖动视图中心点位置都需要重新请求坐标附件的店铺。注意封装方法\r\n'
            '展示在地图上的标签必须用cover-view或者cover-image\r\n'
            '\r\n'
            '三、涉及到的技术及链接\r\n'
            '\r\n'
            '小程序的map组件\r\n'
            '腾讯地图的微信小程序javaScript SDK，地址的解析(中文地址转坐标)和逆地址解析(坐标转中文地址)\r\n'
            '\r\n'
            '\r\n'
            '四、腾讯地图的微信小程序javaScript SDK 使用\r\n'
            '使用方式直接去看官方文档，引入也非常详细了。直接把下载js文件，然后引入。不改成了es6的expost '
            'default/import来导出引入\r\n'
            'export default QQMapWX\r\n'
            '复制代码然后在使用页面import，在onLoad里实例化api核心类。\r\n'
            '//index.vue\r\n'
            'import QQMapWX from "@/utils/qqmap-wx-jssdk"; '
            '//腾讯地图，reverseGeocoder逆地址转码\r\n'
            'export default {\r\n'
            '    data(){\r\n'
            '        return {\r\n'
            '          qqmapsdk: null, //实例化地图sdk\r\n'
            '        }\r\n'
            '    },\r\n'
            '    onLoad(){\r\n'
            '        // 实例化API核心类\r\n'
            '        this.qqmapsdk = new QQMapWX({\r\n'
            '          key: "3P2BZ-6G***-C***3-***5G-3VDYH-N5BGH" // 必填\r\n'
            '        });\r\n'
            '    }\r\n'
            '}\r\n'
            '复制代码根据坐标逆解析详细地址\r\n'
            '//根据坐标逆解析详细地址\r\n'
            'getCityinfo() {\r\n'
            '      return new Promise((resolved, rejected) => {\r\n'
            '        const that = this;\r\n'
            '        this.qqmapsdk.reverseGeocoder({\r\n'
            '          location: {\r\n'
            '            latitude: this.latitude,\r\n'
            '            longitude: this.longitude\r\n'
            '          },\r\n'
            '          success(res) {\r\n'
            '            console.log("地址转码成功", res);\r\n'
            '            const _res = res.result;\r\n'
            '            that.cityName = _res.address_component.city;\r\n'
            '            that.update({\r\n'
            '              cityName: _res.address_component.city,\r\n'
            '              nowPlace:\r\n'
            '                _res.formatted_addresses.recommend + " - " + '
            '_res.address\r\n'
            '            });\r\n'
            '            that.getShopData();\r\n'
            '          },\r\n'
            '          fail: function(res) {\r\n'
            '            console.log(res);\r\n'
            '          }\r\n'
            '        });\r\n'
            '      });\r\n'
            '    },\r\n'
            '复制代码根据城市/地址解析成坐标\r\n'
            '//根据城市/地址解析成坐标\r\n'
            'cityNameGetPosition() {\r\n'
            '      return new Promise((resolved, rejected) => {\r\n'
            '        const that = this;\r\n'
            '        this.qqmapsdk.geocoder({\r\n'
            '          address: this.cityName,\r\n'
            '          success(res) {\r\n'
            '            console.log("根据地址转换坐标", res);\r\n'
            '            const _res = res.result.location;\r\n'
            '            that.latitude = _res.lat;\r\n'
            '            that.longitude = _res.lng;\r\n'
            '            that.update({\r\n'
            '              latitude: _res.lat,\r\n'
            '              longitude: _res.lng\r\n'
            '            });\r\n'
            '            that.getCityinfo();\r\n'
            '          },\r\n'
            '          fail(err) {\r\n'
            '            console.log("根据地址转换坐标err", err);\r\n'
            '          }\r\n'
            '        });\r\n'
            '      });\r\n'
            '    },\r\n'
            '复制代码五、实现的部分代码\r\n'
            '使用的请求和功能逻辑应该是这样的，做了个思维导图。 (注意：代码跟思维导图可能有出入，图是完成代码后的总结，是比较完善的)\r\n'
            '\r\n'
            '这个项目开发使用的是mpvue开发的小程序，mpvue里bindregionchange事件变成了\r\n'
            '    //不是mpvue开发请无视\r\n'
            '    @regionchange="getCenterMap1"\r\n'
            '    @end="getCenterMap"\r\n'
            '复制代码map组件\r\n'
            '    <div>\r\n'
            '        <!-- 地图组件 -->\r\n'
            '        <map\r\n'
            '          id="map"\r\n'
            '          :longitude="longitude"\r\n'
            '          :latitude="latitude"\r\n'
            '          scale="13"\r\n'
            '          :markers="markers"\r\n'
            '          @markertap="markertap"\r\n'
            '          @regionchange="getCenterMap1"\r\n'
            '          @end="getCenterMap"\r\n'
            '          show-location\r\n'
            '          style="width:750rpx; height:99vh;"\r\n'
            '        >\r\n'
            '        </map>\r\n'
            '        <!-- 中心点 -->\r\n'
            '        <cover-image  class="centerImg"\r\n'
            '        src="/static/images/person.png"\r\n'
            '        ></cover-image>\r\n'
            '        <!-- 回到我的定位 -->\r\n'
            '        <cover-image\r\n'
            '          @click="getMyPosition"\r\n'
            '          class="backMyPosition"\r\n'
            '          src="/static/images/location.png"\r\n'
            '        ></cover-image>\r\n'
            '    </div>\r\n'
            '复制代码获取自身定位wx.getLocation\r\n'
            '// 获取定位\r\n'
            '    getMyPosition() {\r\n'
            '      return new Promise((resolved, rejected) => {\r\n'
            '        wx.getLocation({\r\n'
            '          type: "wgs84",\r\n'
            '          success: data => {\r\n'
            '            // console.log(data,"微信地图")\r\n'
            '            this.latitude = data.latitude;\r\n'
            '            this.longitude = data.longitude;\r\n'
            '            this.$store.commit("update", {\r\n'
            '              latitude: data.latitude,\r\n'
            '              longitude: data.longitude\r\n'
            '            });\r\n'
            '            // 根据坐标获取城市信息\r\n'
            '            this.getCityinfo().then(() => {\r\n'
            '              resolved();\r\n'
            '            });\r\n'
            '          },\r\n'
            '          fail() {\r\n'
            '            //失败回调\r\n'
            '            //如果用户拒绝授权,默认为北京\r\n'
            '            this.cityName = "北京市";\r\n'
            '            this.update({ cityName: "北京市" });\r\n'
            '          }\r\n'
            '        });\r\n'
            '      });\r\n'
            '    },\r\n'
            '复制代码地图视野更新时触发\r\n'
            '    // 地图视野更新时触发\r\n'
            '    getCenterMap() {\r\n'
            '      if (this.active === "上门") {\r\n'
            '        const that = this;\r\n'
            '        console.log("自身位置坐标", this.longitude, this.latitude);\r\n'
            '        const map = wx.createMapContext("map");\r\n'
            '        map.getCenterLocation({\r\n'
            '          success(res) {\r\n'
            '            // 判断坐标一致，不用重复请求数据\r\n'
            '            if (\r\n'
            '              that.longitude === res.longitude &&\r\n'
            '              that.latitude === res.latitude\r\n'
            '            ) {\r\n'
            '              return false;\r\n'
            '            }\r\n'
            '            //  const ress =  '
            'transformFromGCJToWGS(res.latitude,res.longitude)\r\n'
            '            that.latitude = res.latitude;\r\n'
            '            that.longitude = res.longitude;\r\n'
            '\r\n'
            '            that.$store.commit("update", {\r\n'
            '              latitude: res.latitude,\r\n'
            '              longitude: res.longitude\r\n'
            '            });\r\n'
            '            console.log("中心位置坐标", that.longitude, '
            'that.latitude);\r\n'
            "            // console.log('转换后的中心位置坐标',ress)\r\n"
            '            that.getCityinfo();\r\n'
            '          }\r\n'
            '        });\r\n'
            '      }\r\n'
            '    }',
 'pub_time': '2019-5-17 00:49',
 'title': '微信小程序map 地图引入配置+腾讯地图地址坐标解析 '}
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5186-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5179-1.html>
{'author': 'Rolan',
 'content': '在做微信小程序的时候，经常会遇到需要页面间传递参数的情况，根据目前项目经验，总结了以下几种方式：URL传参、缓存和方法调用。\r\n'
            'URL传参\r\n'
            '这种方式是最简单也是最常用的，这里就不做过多介绍了。\r\n'
            '缓存\r\n'
            '虽然URL传参比较简单易用，但也有局限性，就是只能传递简单参数，对于复杂的参数就显得无能为力了，但很多时候我们需要传递的是结构比较复杂的数据，这时候很多开发者都会想到用缓存。\r\n'
            '使用缓存我们有两种方式：小程序自带Storage和vuex。因为我们的项目是基于mpvue的，顺带也用了vuex了\r\n'
            '\r\n'
            'Storage：通过小程序提供的API可以方便的进行缓存操作，如：wx.setStorage、wx.getStorage等。\r\n'
            'Vuex：这就跟我们平时在做vue项目时一样了，在store中声明一个变量存放传递的参数。\r\n'
            '\r\n'
            '不管是用上面哪种方式，想法都是一样的：在跳转页面之前先把参数保存到缓存，进入页面之后先获取缓存的参数，然后清除缓存中的参数，进行业务操作。大致伪代码如下：\r\n'
            '// pageA.vue \r\n'
            'goToPageB() {\r\n'
            '  let arg = {\r\n'
            "    name: 'Jack',\r\n"
            '    age: 9\r\n'
            '  }\r\n'
            '  // 先把参数保存到缓存 比如这里用的是小程序的Storage，这里采用同步的方式\r\n'
            '  wx.setStorageSync({\r\n'
            "    key: 'pageArg',\r\n"
            '    data: arg\r\n'
            '  })\r\n'
            '  wx.navigateTo({\r\n'
            "    url: 'pageB'\r\n"
            '  })\r\n'
            '}\r\n'
            '\r\n'
            '\r\n'
            '// pageB.vue \r\n'
            'mounted() {\r\n'
            '  // 从缓存中取出参数\r\n'
            "  let arg = wx.getStorageSync('pageArg')\r\n"
            '  // 清除缓存中的页面参数\r\n'
            "  wx.removeStorageSync('pageArg')\r\n"
            '  // 进行业务处理\r\n'
            '  // ...\r\n'
            '}\r\n'
            '复制代码大致就是这么个逻辑，可能具体项目中会对存取缓存进行封装，或者在vuex中的做法又不一样，但思想是一样的。\r\n'
            '这样做是可以实现功能，但总感觉不太好，每次都要进行存取操作，感觉很麻烦，而且显得不高端。。。\r\n'
            '于是乎，我们想了个方式传递，就是今天的主角：方法调用。\r\n'
            '方法调用\r\n'
            '这种方式肯定不是最好最优雅的解决方式，因为我们也觉得有欠缺的地方，但目前用起来还是比较方便的，今天放出来也是希望让大家看下怎么进行修改，也以便于我们优化。\r\n'
            '主要是用了小程序提供的getCurrentPages方法，具体内容可查看文档，我这里直接就贴图了，因为文档说的很简单\r\n'
            '\r\n'
            '小程序对页面的管理感觉跟浏览器中的history差不多，也是有一个页面栈，每次跳转页面都是往这个栈里push一个页面对象，返回的时候就pop一个，当然具体实现要复杂很多。\r\n'
            '这里官方重点提示了：不要尝试修改页面栈，这也就是为什么我说我们的这种传参方式不是很好的原因，我们就是通过方法修改了这个页面栈的数据。\r\n'
            '带参数返回上一页\r\n'
            '具体实现方式\r\n'
            '// 往前获取页面对象，类似history.go(-n)\r\n'
            'function getPageByPreCount(n) {\r\n'
            '  let currentPages = getCurrentPages()\r\n'
            '  return currentPages[Math.max(0, currentPages.length - (n + '
            '1))]\r\n'
            '}\r\n'
            '\r\n'
            '/* 返回上一页并带回参数\r\n'
            ' * parameter functionName 上一个页面中用来接收带回参数的方法名称，注意：方法要在data中\r\n'
            ' * parameter args  带回去的参数\r\n'
            '*/\r\n'
            'function returnPrevPage(functionName, ...args) {\r\n'
            '  if (functionName) {\r\n'
            '    let prevPage = getPageByPreCount(1)\r\n'
            '    wx.navigateBack()\r\n'
            '    // 方法里手动调用了页面的方法，并把页面参数在这里作为方法参数传递\r\n'
            '    prevPage.data.$root[0] && typeof '
            "prevPage.data.$root[0][functionName] == 'function' \r\n"
            '    && prevPage.data.$root[0][functionName](...args)\r\n'
            '  } else {\r\n'
            '    wx.navigateBack()\r\n'
            '  }\r\n'
            '}\r\n'
            '复制代码项目中使用，如在搜索页(search.vue)面中有一个过滤条件是用户，但可以选择多个用户，而且选择用户是在另外一个页面(user-pick.vue)里进行的，这就是要从user-picker.vue跳回search.vue，并带回选中的用户列表信息\r\n'
            '// user-pick.vue\r\n'
            'methods: {\r\n'
            '  onSelectConfirm(users) {\r\n'
            "    returnPrevPaeg('onSelectUser', users)\r\n"
            '  }\r\n'
            '}\r\n'
            '\r\n'
            '// user-pick.vue\r\n'
            'data() {\r\n'
            '  return {\r\n'
            '    // 把具体处理还是放到了methods中，如果处理逻辑比较简单也可以直接放这里\r\n'
            '    onSelectUser: this.onUserOk\r\n'
            '  }\r\n'
            '},\r\n'
            'methods: {\r\n'
            '  onUserOk(users) {\r\n'
            '    // 拿到用户信息 进行搜索操作\r\n'
            '    // this.search(user)\r\n'
            '  }\r\n'
            '}\r\n'
            '复制代码带参数跳转页面\r\n'
            '返回上一页还是比较好理解的，因为页面已经在页面栈里存在了，可以取到并调用方法，但对于跳转的就不太好实现了，因为每次跳转页面都是往页面栈里追加一个新的对象，在跳转前无法获取到该对象。\r\n'
            '这里就是我说的做的不太好的地方，因为我们采用的是setTimeout方式。。。\r\n'
            '// 前进页面回调方法\r\n'
            'function navigateTo (url,functionName,...args) {\r\n'
            "  triggerNextPageFn('onHide', functionName, ...args)\r\n"
            '  // 跳转后处理数据\r\n'
            '  wx.navigateTo({url})\r\n'
            '}\r\n'
            'function redirectTo (url,functionName,...args) {\r\n'
            "  triggerNextPageFn('onUnload', functionName, ...args)\r\n"
            '  // 跳转后处理数据\r\n'
            '  wx.redirectTo({url})\r\n'
            '}\r\n'
            '\r\n'
            '// 通用触发后一个页面的方法\r\n'
            'function triggerNextPageFn(type, functionName, ...args) {\r\n'
            '  let prePage = getCurPage()\r\n'
            '  if (functionName) {\r\n'
            '    // 保存当前变量\r\n'
            '    ((..._args) => {\r\n'
            '      let oldEventFn = prePage[type]\r\n'
            '      prePage[type] = () => {\r\n'
            '        // 前进页面改变onReady方法，这里使用了setTimeout\r\n'
            '        setTimeout(() => {\r\n'
            '          let newPage = getCurPage()\r\n'
            '          let oldOnReady = newPage.onReady\r\n'
            '          newPage.onReady = function () {\r\n'
            '            newPage.data.$root[0] && typeof '
            "newPage.data.$root[0][functionName] == 'function' \r\n"
            '            && newPage.data.$root[0][functionName](..._args)\r\n'
            '            oldOnReady.apply(newPage)\r\n'
            '            newPage.onReady = oldOnReady\r\n'
            '          }\r\n'
            '        })\r\n'
            '        prePage[type] = oldEventFn\r\n'
            '      }\r\n'
            '    })(...args)\r\n'
            '  }\r\n'
            '}\r\n'
            '复制代码小结\r\n'
            '传递方式那么多，选择适合自己的才是最重要的。虽然我们写的这个传参方法不是微信官方支持的，因为文档里面明确说了不要修改页面栈，但就目前使用情况来看还是没遇到什么问题的，也许还没遇到吧。\r\n'
            '就本篇文章中介绍的传参方式，如果有不妥的地方或者更好的修改建议，希望大家能帮我们提出来，大家共同进步。',
 'pub_time': '2019-5-16 09:55',
 'title': '微信小程序中页面间跳转传参方式 '}
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5190-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5186-1.html>
{'author': 'Rolan',
 'content': '需求需求需求（重要的事情说三遍）什么时候开始支持微信客户端7.0.0 - 新增 框架 支持页面级自定义导航配置 '
            'navigationStyle: custom。基础版本库 v1.9.5 (2018.01.24)， 新增 配置 '
            'window.navigationStyle 支持全屏显示小程序 '
            '详情目前支持全局的配置和单个页面的配置两种："navigationStyle": "custom"\r\n'
            '复制代码2、如何实现与官方一样效果导航条，以及如何扩展？手机顶部信息栏的高度微信小程序胶囊位置信息微信小程序提供的APIwx.getSystemInfo() '
            '异步获取系统信息wx.getSystemInfoSync() '
            '同步获取用户信息wx.getMenuButtonBoundingClientRect() '
            '小程序胶囊的位置新信息注意我们能够拿到的数值单位是\xa0px\xa0不是\xa0rpx\xa0'
            '。【之后我也写一篇专门探究小程序单位】wx.getSystemInfo({\r\n'
            '    success: (res) => {\r\n'
            '     // iphone6.statusBarHeight = 20\r\n'
            '     this.globalData.statusBarHeight = res.statusBarHeight; \r\n'
            '     let custom = wx.getMenuButtonBoundingClientRect();\r\n'
            '     this.globalData.custom = '
            'wx.getMenuButtonBoundingClientRect();\r\n'
            '     this.globalData.Custom = custom;\r\n'
            '     this.globalData.CustomBar = custom.bottom + custom.top - '
            'res.statusBarHeight;\r\n'
            '     // 另一种计算方式\r\n'
            '     this.globalData.CustomBar =custom.height + ( custom.top - '
            'res.statusBarHeight) * 2;\r\n'
            '    }\r\n'
            '})\r\n'
            '复制代码let custom = wx.getMenuButtonBoundingClientRect();\r\n'
            '复制代码代码演示我们用iphoneX的模拟器为例子，因为iphoneX的信息导航栏比较高与别的不同，我们从特殊的更加明显。<view '
            'class="bg" style="height:{{statusBarHeight}}px"></view>\r\n'
            "<view class='jiaonang' \r\n"
            "      style='margin-top:{{custom.top - statusBarHeight}}px; "
            "height:{{custom.height}}px'>\r\n"
            '</view>\r\n'
            '复制代码let app = getApp();\r\n'
            'Page({\r\n'
            '    data: {\r\n'
            '        statusBarHeight: app.globalData.statusBarHeight,\r\n'
            '        StatusBar: app.globalData.StatusBar,\r\n'
            '        CustomBar: app.globalData.CustomBar,\r\n'
            '        custom: app.globalData.custom\r\n'
            '    }\r\n'
            '})\r\n'
            '复制代码.bg {\r\n'
            '  width: 100%;\r\n'
            '  height: 50rpx;\r\n'
            '  background: teal;\r\n'
            '}\r\n'
            '\r\n'
            '.jiaonang {\r\n'
            '  width: 100%;\r\n'
            '  background: red;\r\n'
            '}\r\n'
            '复制代码以下是微信小程序模拟器的不同的结果iphoneX 的效果iphone6 的效果安卓Nexus5x 的效果平板iPad '
            'Air 2 的效果ipad Pro 12.9-inch '
            '的效果3、如何适配不同的机型？？不同机型的适配一直是前端的最严重的问题，小程序对适配问题提出了rpx的方案。 '
            '但是对于自定义导航栏，我们似乎用不到的自定义导航栏！3、注意客户端\xa06.7.2\xa0版本开始，\xa0'
            'navigationStyle: custom\xa0对\xa0<web-view>\xa0'
            '组件无效。后记其实小程序是特别的适合，没有开发经验入门或者转行前端的同志~学会断点调试，学会排除错误，才是正道啊~我想学的细一点，路才走的广一点~',
 'pub_time': '2019-5-20 00:31',
 'title': '微信小程序_自定义导航 '}
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5191-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5190-1.html>
{'author': 'Rolan',
 'content': '今天有同学在测试小程序的过程中，发现一个问题，调用 微信官方的服务端接口超时 '
            '，比如这个接口，https://api.weixin.qq.com/sns/jscode2session '
            '，因为我们小程序登录的时候，会在自己server端调用微信的API，这个接口超时，导致我们的登录流程也就挂掉了。本来以为是偶尔的网络问题，但是，同学发现在测试服务器上，很稳定的复现超时！但是在我们本地测试过程中，请求微信服务器又很快响应。嗯，理论上微信服务器不会出问题的……\r\n'
            '试着在服务器上去 curl '
            '微信的接口，确实挺慢的，我们代码里配置了超时是3秒，目测确实超过了3秒才返回！抱着侥幸的想法，让同学把超时改成5秒，依然超时……嗯，略微有点尴尬。\r\n'
            '试着 ping api.weixin.qq.com '
            '，发现收到第一个包，隔着挺长时间，后面的包平均几十毫秒，网络应该也没问题吧。\r\n'
            '没办法了，因为是服务端，只能用 '
            'curl，想看看这个工具能不能提供一下，整个请求的各个阶段，时间是怎么分布的。搜了一下，还真有这个功能，具体操作如下：\r\n'
            '\r\n'
            '在某个目录下，新建一个文件，比如 curl-format.txt ，内容如下：\r\n'
            '\r\n'
            ' time_namelookup:  %{time_namelookup}\\n\r\n'
            '       time_connect:  %{time_connect}\\n\r\n'
            '    time_appconnect:  %{time_appconnect}\\n\r\n'
            '   time_pretransfer:  %{time_pretransfer}\\n\r\n'
            '      time_redirect:  %{time_redirect}\\n\r\n'
            ' time_starttransfer:  %{time_starttransfer}\\n\r\n'
            '                    ----------\\n\r\n'
            '         time_total:  %{time_total}\\n\r\n'
            '复制代码\r\n'
            '在同一个目录下，执行 curl 操作：\r\n'
            '\r\n'
            'curl -w "@curl-format.txt" -o /dev/null -s '
            '"https://api.weixin.qq.com/sns/jscode2session?xxx=xxx&xx=aa"\r\n'
            '复制代码拿到的结果如下：\r\n'
            '\xa0\r\n'
            '在网上查阅了下，各个字段含义如下(单位都是 秒 )：\r\n'
            '\r\n'
            'time_namelookup: DNS 域名解析的时候，就是把 https://zhihu.com 转换成 ip '
            '地址的过程\r\n'
            'time_connect: TCP 连接建立的时间，就是三次握手的时间\r\n'
            'time_appconnect: SSL/SSH 等上层协议建立连接的时间，比如 connect/handshake 的时间\r\n'
            'time_pretransfer: 从开始到最后一个请求事务的时间\r\n'
            'time_redirect: 从请求开始到响应开始传输的时间\r\n'
            'time_starttransfer: 从请求开始到第一个字节将要传输的时间\r\n'
            'time_total: 这次请求花费的全部时间\r\n'
            '\r\n'
            '从上面截图中可以看出，我们服务器上，在DNS域名解析阶段，就花了 5秒 ，难怪会超时了……\r\n'
            '找到了问题，那就先在机器上修改 /etc/hosts 文件，写死一个微信域名的IP解析，暂时 把这个问题修复了。\r\n'
            '相关资料\r\n'
            '\r\n'
            '使用curl测试网络请求耗时\r\n'
            '使用 curl 命令分析请求的耗时情况',
 'pub_time': '2019-5-21 00:13',
 'title': '小程序server请求微信服务器超时 '}
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5191-1.html>
{'author': 'Rolan',
 'content': '前言\r\n'
            '这个简单的麦克风demo的创意是来源于“包你说”中的录音效果，实现的方式其实也并不难，但对于小程序中的简易动画的使用的确很实用。\r\n'
            '效果\r\n'
            '先来看个demo，gif帧数比较低，实际效果和真机测试的流畅性还是很OK的\r\n'
            '\r\n'
            '#思路\r\n'
            '通过setTimeout配合this.sedData来改变image中的src路径来生成动画。动画的播放以及隐藏则通过wx:if绑定一个自定义的参数来控制。下面就直接上代码。\r\n'
            '代码\r\n'
            'html\r\n'
            "    <view class='animation-talk'>\r\n"
            "        <image src='../../image/receive{{receiveImg}}.png' "
            'wx:if="{{showTalk}}" mode=\'aspectFill\'></image>\r\n'
            '    </view>\r\n'
            '    <view>\r\n'
            "        <image src='../../image/voice{{voiceNum}}-btn.png' "
            'bindlongpress="longPress" bindtouchend="endTouch" ></image>\r\n'
            '    </view>\r\n'
            '复制代码javascript\r\n'
            '    var playTalk //录音动画定时器\r\n'
            '    Page({\r\n'
            '        data:{\r\n'
            '            showTalk: false, //显示录音动画\r\n'
            '            receiveImg: 3, //按压播放语音动画\r\n'
            '            voiceNum: 2, //按压录音时效果图\r\n'
            '            config: app.globalData.apiUrl,//demo接口\r\n'
            '        },\r\n'
            '        //长按读语音\r\n'
            '        longPress() {\r\n'
            '            var that = this;\r\n'
            '            that.setData({\r\n'
            '                voiceNum: 1,\r\n'
            '                showTalk: true\r\n'
            '            });\r\n'
            '            that.animationTalk();\r\n'
            '            var url = that.data.config;\r\n'
            '            wx.startRecord({\r\n'
            '                success(res) {\r\n'
            '                    const tempFilePath = res.tempFilePath; '
            '//录音成功后的文件\r\n'
            '                    wx.saveFile({\r\n'
            '                        tempFilePath: tempFilePath,  '
            '//保存文件到本地并生成临时路径\r\n'
            '                        success(res) {\r\n'
            '                            wx.uploadFile({         '
            '//上传语音文件到服务器\r\n'
            '                                url: url,\r\n'
            '                                filePath: res.savedFilePath,\r\n'
            "                                name: 'file',\r\n"
            '                                formData: {\r\n'
            '                                    token: that.data.token,\r\n'
            "                                    name: 'file'\r\n"
            '                                },\r\n'
            '                                success(res) {\r\n'
            '                                    that.setData({\r\n'
            '                                        voiceUrl: '
            'JSON.parse(res.data).file_url\r\n'
            '                                    })\r\n'
            '                                    that.receivePage() '
            '//校验语音正确率，此步骤未贴出\r\n'
            '                                }\r\n'
            '                            })\r\n'
            '                        }\r\n'
            '                    })\r\n'
            '                }\r\n'
            '            })\r\n'
            '        },\r\n'
            '        // 播放录音动画\r\n'
            '        animationTalk() {\r\n'
            '            var that = this;\r\n'
            '            if (!that.data.showTalk) {\r\n'
            '                that.setData({\r\n'
            '                    receiveImg: 1\r\n'
            '                });\r\n'
            '                clearTimeout(playTalk)\r\n'
            '            } else {\r\n'
            '                switch (that.data.receiveImg) {\r\n'
            '                    case 1:\r\n'
            '                        that.setData({\r\n'
            '                            receiveImg: 2\r\n'
            '                        })\r\n'
            '                        break\r\n'
            '                    case 2:\r\n'
            '                        that.setData({\r\n'
            '                            receiveImg: 3\r\n'
            '                        })\r\n'
            '                        break\r\n'
            '                    case 3:\r\n'
            '                        that.setData({\r\n'
            '                            receiveImg: 1\r\n'
            '                        })\r\n'
            '                        break\r\n'
            '                }\r\n'
            '                setTimeout(function () {\r\n'
            '                    that.animationTalk()\r\n'
            '                }, 500)\r\n'
            '            }\r\n'
            '        },\r\n'
            '        // 录音结束\r\n'
            '        endTouch() {\r\n'
            '            var that = this;\r\n'
            '            wx.stopRecord();\r\n'
            '            that.setData({\r\n'
            '                voiceNum: 2,\r\n'
            '                showTalk: false,\r\n'
            '            })\r\n'
            '        },\r\n'
            '    })\r\n'
            '复制代码写在之后\r\n'
            '通过this.setData来制造动画事件仅仅适合项目中的简单动画效果，如若要完成其他动画特效，如我们胡建的中秋博饼的动画，则需要使用更为强大的css3中的动画效果，这一点小程序的支持也是十分给力的。',
 'pub_time': '2019-5-21 00:23',
 'title': '小程序实现录音时的麦克风动画效果 '}
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5196-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5187-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-6-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5196-1.html>
{'author': 'Rolan',
 'content': '在很多的产品中，都会存在跨页面间需要数据同步，如下示例：\r\n'
            '\r\n'
            '为了更好的理解该场景，我们再详细描绘一下：\r\n'
            '\r\n'
            '本场景包括4个页面：动态广场、个人中心、我的动态、动态详情\r\n'
            '首先，进入动态广场页，请求加载数据，展示动态列表，其中，我们用绿色内阴影区分该条动态是“我的”，其他未加内阴影的表示是“别人的”；\r\n'
            '然后，进入个人中心页，请求加载数据，展示获赞数量；\r\n'
            '点击我的动态，进入我的动态页，请求加载数据，展示我的动态列表；\r\n'
            '点击其中一条动态，进入动态详情页，请求加载数据，进行点赞操作；\r\n'
            '在第5步中，点赞成功后，回退到我的动态页，可以看到该条动态点赞状态和数量发生变化，已经同步；\r\n'
            '再回到到个人中心页，也可以看到获赞数量发生变化，已经同步；\r\n'
            '再回到动态广场页，也可以看到对应的一条动态点赞状态和数量发生变化，已经同步；\r\n'
            '\r\n'
            '下面我们来探讨一下这个场景的实现，在此之前，我们先要了解在点赞时，该场景中各页面的状态及关系。\r\n'
            '\r\n'
            '\r\n'
            '如上图所示，当我们在点赞时，4个页面都已经在是打开的（4个webview）。当我们点赞成功时，点击左上解返回时，动态详情页的webview关掉，直接看到下一层webview，也就是我的动态页，这个页面是已经存在的。其他页面也是如此。\r\n'
            '那对于这些已经存在的页面，我们应该如何同步更新数据呢？\r\n'
            '当然，如果比较懒，可以直接在onShow的时候重新拉数据渲染页面。但显然这是非常低级、不可取也没必要的做法。重新拉数据需要耗时，页面重新渲染也会看到闪屏，关键是根本没必要重新拉数据，因为数据发生了变化，前端是知道的。\r\n'
            '所以我们可以这样做，在动态详情页点赞成功时，保存一个数据到全局globalData中去，回到我的动态页，在onShow中去检测全局globalData中是否有点赞变化的数据，有的话，就读取出来去更新相应的动态。\r\n'
            '// 动态详情页js\r\n'
            'onLike() {\r\n'
            '  ...\r\n'
            '  success: () => {\r\n'
            '    App.globalData.like = {\r\n'
            '      fid: 10001,\r\n'
            '      likes: 1,\r\n'
            '      hasLike: true         \r\n'
            '    }\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            '// 我的动态页js\r\n'
            'onShow() {\r\n'
            '  if(App.globalData.like !== null) {\r\n'
            '    // 读取globaldata.like数据去更新\r\n'
            '    this.doUpdata()\r\n'
            '    // 特别需要注意，更新完后，需要把globaldata.like清掉，不然下次onShow还会继续走到该逻辑\r\n'
            '    App.globalData.like = null\r\n'
            '  }\r\n'
            '}\r\n'
            '复制代码这样似乎可以达到我们的目的，无请求、纯前端局部更新。\r\n'
            '但这样还存在一个问题，当我们再退回到个人中心页时，要检查下获赞数量是否需要更新，以及回到动态广场页时，也要检查点赞有没有发生变化。但在这两个页面onShow去判断App.globalData.like时，都已经检测不到了，因为该数据已经在我的动态页onShow中置为null了。\r\n'
            '概括来说，在点赞时，只生产了一条数据，但有多个消费者，哪个页面先把数据消费了，其他页面也就无法检测到数据了。\r\n'
            '由此，我们想到那就使用EventBus来处理。\r\n'
            '首先，我们自己实现一套简单的EventBus。\r\n'
            '\r\n'
            '源码见：git.weixin.qq.com/xinyuanliu/…\r\n'
            '\r\n'
            '在小程序启动时，初始化EventBus：\r\n'
            "const Event = require('/util/events.js').default\r\n"
            '\r\n'
            'App({\r\n'
            '  events: null,\r\n'
            '  onLaunch(options) {\r\n'
            '    this.initEvents()\r\n'
            '    // doOtherThings\r\n'
            '  },\r\n'
            '  initEvents() {\r\n'
            '    this.events = new Event()\r\n'
            '  },\r\n'
            '  emitFeedsLike(data) {\r\n'
            "    this.events.emit('feedsLike', data)\r\n"
            '  },\r\n'
            '  emitPublishFeeds(data) {\r\n'
            "    this.events.emit('publishFeeds', data)\r\n"
            '  },\r\n'
            '  ...\r\n'
            '}\r\n'
            '复制代码各个页面在onLoad时，注册监听事件(在此以我的动态页为例)：\r\n'
            '// 我的动态.js\r\n'
            'const App = getApp()\r\n'
            '\r\n'
            'Page({\r\n'
            '  data: {\r\n'
            '    list: []\r\n'
            '  },\r\n'
            '  onLoad: function (options) {\r\n'
            '    ...\r\n'
            '    // 监听点赞事件广播\r\n'
            '    ↓ 重点在这里 ↓\r\n'
            "    App.events.on('feedsLike', data => {\r\n"
            "      console.log('我的动态页面收到点赞变化通知：', data)\r\n"
            '      // 进行更新操作\r\n'
            '    })\r\n'
            '    // 监听发布事件广播\r\n'
            '    ↓ 重点在这里 ↓\r\n'
            "    App.events.on('publishFeeds', data => {\r\n"
            "      console.log('我的动态页面收到发布动态通知：', data)\r\n"
            '      // 进行更新操作\r\n'
            '    })\r\n'
            '  },\r\n'
            '  ...\r\n'
            '})\r\n'
            '复制代码然后在动态点赞时，发出事件通知。（这里一条动态是封装成组件，不属于某一个页面，点赞事件也是封装在组件内）\r\n'
            'const App = getApp()\r\n'
            '\r\n'
            'Component({\r\n'
            '  properties: {...},\r\n'
            '  methods: {\r\n'
            '    // 点赞\r\n'
            '    tapLike(e) {\r\n'
            '      let { likes, hasLike } = this.data\r\n'
            '\r\n'
            '      likes += (hasLike && -1 || 1)\r\n'
            '      hasLike = !hasLike\r\n'
            '\r\n'
            '      this.updateFeeds(likes, hasLike).then(() => {\r\n'
            '        this.setData({\r\n'
            '          likes,\r\n'
            '          hasLike\r\n'
            '        })\r\n'
            '\r\n'
            '        // 广播事件\r\n'
            '        ↓ 重点在这里 ↓\r\n'
            '        App.emitFeedsLike({\r\n'
            '          uid: this.data.uid,\r\n'
            '          fid: this.data.fid,\r\n'
            '          likes,\r\n'
            '          hasLike\r\n'
            '        })\r\n'
            '      })\r\n'
            '    },\r\n'
            '    ...\r\n'
            '  }\r\n'
            '})\r\n'
            '复制代码这样，我们便在小程序中实现了一套跨页面数据同步的方案。\r\n'
            '直观上这已经非常完美的实现了我们的需求。但在小程序中存在一个与我们常规经验不太一致的地方。那就是页面在关掉后，它里面的对象并没有销毁，这点是因为小程序的逻辑层是共用一个进程。\r\n'
            '因此，每次进入页面，都会注册一次监听事件，而退出页面后，该事件并不会销毁。这样的话，多次重复进入页面，就会注册多个重复事件，当事件发生时，就会执行多次响应。请仔细观察下图！\r\n'
            '为了避免该现象出现，我们切记要在页面的onUnload事件中，主动销毁监听事件。\r\n'
            'Page({\r\n'
            '  eventsListener: {},\r\n'
            '  data: {\r\n'
            '    list: []\r\n'
            '  },\r\n'
            '  onLoad: function (options) {\r\n'
            '    ...\r\n'
            '    // 监听点赞事件广播\r\n'
            '    ↓ 重点在这里 ↓\r\n'
            "    this.eventsListener.feedsLike = App.events.on('feedsLike', "
            'data => {\r\n'
            "      console.log('我的动态页面收到点赞变化通知：', data)\r\n"
            '      // 进行更新操作\r\n'
            '    })\r\n'
            '    // 监听发布事件广播\r\n'
            '    ↓ 重点在这里 ↓\r\n'
            '    this.eventsListener.publishFeeds= '
            "App.events.on('publishFeeds', data => {\r\n"
            "      console.log('我的动态页面收到发布动态通知：', data)\r\n"
            '      // 进行更新操作\r\n'
            '    })\r\n'
            '  },\r\n'
            '  ↓ 重点在这里 ↓\r\n'
            '  onUnload() {\r\n'
            '    for (let i in this.eventsListener) {\r\n'
            '      App.events.remove(i, this.eventsListener[i])\r\n'
            '    } \r\n'
            '  },\r\n'
            '  ...\r\n'
            '})\r\n'
            '复制代码至此，我们在小程序中完美的实现了跨页面/组件、多页面数据同步。\r\n'
            '本文研究的demo均可以小程序中体验，项目源码：git.weixin.qq.com/xinyuanliu/',
 'pub_time': '2019-5-22 00:35',
 'title': '小程序开发经验：多页面数据同步 '}
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-6-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5187-1.html>
{'author': 'Rolan',
 'content': '需求：在小程序中展示一个常规动效，点击后执行一个按压动效，执行完成恢复常规动效。\r\n'
            '\r\n'
            '可选方案：\r\n'
            '1. 使用 gif 图\r\n'
            '无法控制 gif 图的执行过程，需要通过切换图片源来实现两个动效的切换。\r\n'
            '图片放在代码包中：动效的 gif 图尺寸一般比较大，放在代码包中会超出代码包 2M 大小的限制。\r\n'
            '使用网络图片：切换的时候需要加载图片，会出现动效不连贯的问题\r\n'
            '缓存在本地：使用 wx.downloadFile 缓存在本地，但本地缓存有 10M 的限制，一不小心也会超哦～\r\n'
            '2. 使用 APNG\r\n'
            '问题同 gif，兼容性也有一定的问题。\r\n'
            '3. 使用 PNG 序列（雪碧图）\r\n'
            '单个动效的实现方案可以参考 张鑫旭大佬的文章：小tips: CSS或JS实现gif动态图片的停止与播放。\r\n'
            '为了避免切换动效时出现短暂的空白的状态，可使用 PNG 序列的方式实现：将两个动效的序列图连接在一起。\r\n'
            '那用一张 PNG 来做两个动效怎么实现呢？以一张 80 帧的 PNG 序列为例，前 40 帧为第一个动效，后 40 '
            '帧为第二个动效。执行时间均为2s。\r\n'
            '@keyframes animate-default {\r\n'
            '  0% {\r\n'
            '    background-position: 0;\r\n'
            '  }\r\n'
            '\r\n'
            '  100% {\r\n'
            '    background-position: 50%;\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            '.animate-default {\r\n'
            '    animation: animate-default steps(39) 2s infinite forwards;\r\n'
            '}\r\n'
            '\r\n'
            '@keyframes animate-click {\r\n'
            '  0% {\r\n'
            '    background-position: 50%;\r\n'
            '  }\r\n'
            '\r\n'
            '  100% {\r\n'
            '    background-position: 100%;\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            '.animate-click {\r\n'
            '    animation: animate-click steps(39) 2s 1 forwards;\r\n'
            '}\r\n'
            '复制代码but，现实总是很残酷，并不是我们想要的效果。\r\n'
            '\r\n'
            '那问题出在哪里呢？\r\n'
            '单帧图片的宽度为 384px，图片执行到第 40 张的时候其实位置为 384 * 39 = 14976，我们将 '
            'animate-default 动效的 100% 位置改为 -14976px，同理将 animate-click 动效的 0% '
            '位置改为 384 * 40 即 -15360px 即可。\r\n'
            '但为了更好的适配不同的设备，我们选用了 rpx 为单位，虽然在 750 '
            '设备上动画正常，但切换设备，动画又坏掉了...摩擦，摩擦，在光滑的地板上...\r\n'
            '请忽略后面的背景～\r\n'
            '\r\n'
            '不能用 px 为单位，不能用 rpx 为单位，那以百分比的形式设置 '
            'background-position，我们该如何实现呢？\r\n'
            '敲黑板，重点来了！！\r\n'
            '敲黑板，重点来了！！\r\n'
            '敲黑板，重点来了！！\r\n'
            'background-position 的计算公式（from《CSS 世界》）是：\r\n'
            'percentX = positionX /（容器宽度 - 图片宽度）;\r\n'
            'percentY = positionY /（容器宽度 - 图片宽度）;\r\n'
            '所以本例中，\r\n'
            '-14976 / （384 - 384 * 80 ），约 0.49367089；\r\n'
            '-15360 / （384 - 384 * 80），约 0.50632911。\r\n'
            '@keyframes animate-default {\r\n'
            '  0% {\r\n'
            '    background-position: 0;\r\n'
            '  }\r\n'
            '\r\n'
            '  100% {\r\n'
            '    background-position: 49.367%;\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            '.animate-default {\r\n'
            '    animation: animate-default steps(39) 2s infinite forwards;\r\n'
            '}\r\n'
            '\r\n'
            '@keyframes animate-click {\r\n'
            '  0% {\r\n'
            '    background-position: 50.633%;\r\n'
            '  }\r\n'
            '\r\n'
            '  100% {\r\n'
            '    background-position: 100%;\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            '.animate-click {\r\n'
            '    animation: animate-click steps(39) 2s infinite forwards;\r\n'
            '}\r\n'
            '复制代码\r\n'
            '在点击后切换 class，再切换回来～OK啦，完美。',
 'pub_time': '2019-5-20 00:41',
 'title': '在小程序中用一张 PNG 实现两个动效 '}
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-10-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-7-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:58 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5192-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-10-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-7-1.html>
{'author': 'admin',
 'content': '先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay '
            '自动播放，interval 轮播的时间，duration '
            '切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg '
            '与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick '
            '来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 '
            'length 集合（cardnum）。其中 '
            'currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var '
            'number = '
            'e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 '
            'getBackStyle，把 changeClick 切换到 imgFullScrenn '
            '待命。再次点击返回原样式，切换后事件又走回到 getBackStyle '
            '了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 '
            'block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            'var chinaMessage = res.card.groups[0].fields;var personMessage= '
            '[]\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0for(var i = '
            '0;i\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'personMessage.push(chinaMessage[i])\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            '}\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            '//为空或者null是不显示判断\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 for(var k in '
            'personMessage){\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'if(personMessage[k].value==null || '
            'personMessage[k].value==""){\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'personMessage[k]["display"] = '
            '"none";\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '}else{\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'personMessage[k]["display"] = '
            '"block";\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '}\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0}具体以 json '
            '数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData '
            '不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 '
            'forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 '
            'bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js '
            '的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push '
            '上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 '
            'demo 有实现方式）。可以看下实现的效果：',
 'pub_time': '2016-10-12 22:39',
 'title': '微信小程序开发教程第五章：名片夹详情页开发 '}
2019-07-25 14:24:58 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5192-1.html>
{'author': 'Rolan',
 'content': '前言遇到了一个需求，想要扫码后，进入微信小程序的某一个页面，这就要求二维码携带参数。微信小程序开发文档很简单，但不太具体。经百度和折腾，在express中成功获得了带参数的二维码。总结以下几步，供参考。1.express项目中引入http请求工具为什么要在服务端引入这个工具？因为还需要用这个工具去找微信服务端拿access_token接口凭证，来保证安全。笔者用的是axios。cmd进入根目录，npm安装。# '
            'npm i axios '
            '--save肯定需要写一个获得二维码的接口。在写这个接口的文件中引入axios即可，接口路由的写法不具体展开介绍。import '
            "express from 'express';\r\n"
            "import axios from 'axios'; //引入axios库\r\n"
            'let qrcode= express.Router();\r\n'
            "qrcode.post('/getQrode',async (req,res)=>{\r\n"
            '    try {\r\n'
            '        ...\r\n'
            '        //待写接口内容区域\r\n'
            '    } catch (error) {\r\n'
            '        throw error;\r\n'
            '    }\r\n'
            '})\r\n'
            'export default '
            'qrcode;复制代码引入了库，定义了路由，也定义了一个post接口。第一步准备完毕。2.获取access_token找微信服务端拿access_token，需要用上刚刚引入的axios工具了。通过官方文档介绍，获取access_token需要三个参数，一个常量grant_type，两个变量分别是appid和secret（注册小程序的时候就会获得）修改接口即可获得access_tokenimport '
            "express from 'express';\r\n"
            "import axios from 'axios';\r\n"
            'let qrcode= express.Router();\r\n'
            "qrcode.post('/share',async (req,res)=>{\r\n"
            '    try {\r\n'
            "        let appid = 'wxc********b7a';\r\n"
            "        let secret = '2bfa**************e8682';\r\n"
            '        let url = '
            '`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${secret}`\r\n'
            '        axios.get(url).then(res2=>{\r\n'
            '            //access_token就在res2中\r\n'
            '            let access_token = res2.data.access_token;\r\n'
            '            //待继续补充区域\r\n'
            '        });\r\n'
            '    } catch (error) {\r\n'
            '        console.log(error)\r\n'
            '    }\r\n'
            '})\r\n'
            'export default '
            'qrcode;复制代码拿到了access_token接口凭证了，继续下一步。3.获取二维码的二进制数据阅读文档，得知需要进一步传参，请求微信服务端获取二维码的buffer数据。需要携带的参数可以写在scene中。其他参数文档中介绍的已经很具体。然而，这里有两个坑要注意！第一个坑：access_token参数要写在url中，不然请求后会报未传access_token的错。第二个坑：要设置响应格式，否则请求回来的buffer数据总是被编译成String字符串，造成文件损坏，就无法转化为正常图片（这个折磨了我好久）import '
            "express from 'express';\r\n"
            "import axios from 'axios';\r\n"
            'let qrcode = express.Router();\r\n'
            "qrcode.post('/share',async (req,res)=>{\r\n"
            '    try {\r\n'
            "        let appid = 'wxc********b7a';\r\n"
            "        let secret = '2bfa**************e8682';\r\n"
            '        let url = '
            '`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${secret}`\r\n'
            '        axios.get(url).then(res2=>{\r\n'
            '            let scene = req.body._id;//开发者自己自定义的参数\r\n'
            '            axios(\r\n'
            '                {\r\n'
            '                    '
            'headers:{"Content-type":"application/json"},\r\n'
            "                    method: 'post',\r\n"
            "                    responseType: 'arraybuffer',\r\n"
            '                    url: '
            "'https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token='+access_token+'',\r\n"
            '                    data:{\r\n'
            '                        scene:scene,\r\n'
            "                        page:'pages/infor/main',\r\n"
            '                        width: 280\r\n'
            '                    }\r\n'
            '                }\r\n'
            '            ).then(res3=>{\r\n'
            '                //请求到的二维码buffer就在res3中\r\n'
            '                //待完善区域\r\n'
            '            })\r\n'
            '        });\r\n'
            '    } catch (error) {\r\n'
            '        console.log(error)\r\n'
            '    }\r\n'
            '})\r\n'
            'export default '
            'qrcode;复制代码第二次axios请求，用option配置的方式，设置了responseType，避开了第二个坑。二维码的buffer数据就在res3中。4.用buffer生成图片只要buffer数据是完整的，就能正确生成二维码。因为需要生成图片，所以需要引用fs模块和path模块。import '
            "express from 'express';\r\n"
            "import axios from 'axios';\r\n"
            "import path from 'path';\r\n"
            "import fs from 'fs';\r\n"
            'let qrcode= express.Router();\r\n'
            "qrcode.post('/share',async (req,res)=>{\r\n"
            '    try {\r\n'
            "        let appid = 'wxc********b7a';\r\n"
            "        let secret = '2bfa**************e8682';\r\n"
            '        let url = '
            '`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${secret}`;\r\n'
            '        axios.get(url).then(res2=>{\r\n'
            '            let access_token = res2.data.access_token;\r\n'
            '            let scene = req.body._id;\r\n'
            '            axios(\r\n'
            '                {\r\n'
            '                    '
            'headers:{"Content-type":"application/json"},\r\n'
            "                    method: 'post',\r\n"
            "                    responseType: 'arraybuffer',\r\n"
            '                    url: '
            "'https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token='+access_token+'',\r\n"
            '                    data:{\r\n'
            '                        scene:scene,\r\n'
            "                        page:'pages/infor/main',\r\n"
            '                        width: 280\r\n'
            '                    }\r\n'
            '                }\r\n'
            '            ).then(res3=>{\r\n'
            '                let src = '
            "path.dirname(__dirname).replace(/\\\\/g,'/')+`/public/photo/${req.body._id}.png`;\r\n"
            '                fs.writeFile(src, res3.data, function(err) {\r\n'
            '                    if(err) {console.log(err);}\r\n'
            '                    res.json({msg:ok});\r\n'
            '                });\r\n'
            '            })\r\n'
            '        });\r\n'
            '    } catch (error) {\r\n'
            '        console.log(error);\r\n'
            '        res.json({error})\r\n'
            '    }\r\n'
            '})\r\n'
            '\r\n'
            'export default '
            'qrcode;复制代码就会在根目录下的public/photo文件夹中生成制定名称的二维码图片。供小程序访问调用。后记获取二维码后，可以在前端利用canvas进行图片绘制，也可以在后端生成图片。可根据业务需求自行选择。希望对有需要的朋友能够有帮助。',
 'pub_time': '2019-5-21 00:31',
 'title': 'express启用https小记 '}
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-12-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-12-1.html>
{'author': 'admin',
 'content': '进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template '
            '名片很多，需要用模板、这里需要微信提供的基础组件大致是 '
            'input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC '
            '跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* '
            '名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* '
            'Template：定义一个模板，name 模板的名字其实是个作用域。* '
            'Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 '
            'data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template '
            '时非常方便，is 和 name 一样，data 是 nameData '
            '传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json '
            '数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 '
            'nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 '
            'json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css '
            '是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 '
            'bindChange 为输入框发生改变事件。微信提供的 bindchange '
            '在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js '
            '里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; '
            '//this绑定，这个this指向微信的提供windowvar Text = '
            'e.detail.value.toUpperCase(); //取到输入的内容if(Text==""){ //如果输入为空 '
            '一些东西需要显示 否则不显示show_letter = "block";}else{show_letter = '
            '"none";}this.setData({show_letter:show_letter,showSheet:true});var '
            'res = nameData; 获取到传递的数据if(data_type=="name"){}else '
            'if(data_type=="time"){res = timeData;\xa0};for(var k in res){ '
            '//for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = '
            '0;iIf(data[i].userName!=null && '
            'data[i].userName.indexOf(Text)!=-1){data[i]["display"] = "block"; '
            '//存在就是赋值显示}else{data[i]["display"] = "none"; // '
            '不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 '
            'action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js '
            '配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: '
            '调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 '
            'loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 '
            'view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 '
            'api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom '
            '长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC '
            '跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾',
 'pub_time': '2016-10-12 23:26',
 'title': '微信小程序开发教程第四章：首页面开发 '}
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5255-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=5)
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5255-1.html>
{'author': 'Rolan',
 'content': '需求在项目里写过几个canvas生成分享海报页面后,觉得这是个重复且冗余的工作.于是就想有没有能通过类似json直接生成海报的库.然后就在github找到到两个项目:wxa-plugin-canvas\xa0'
            ',不太喜欢配置文件的写法.就没多去了解mp_canvas_drawer\xa0'
            ',使用方式就比较符合直觉,不过可惜功能有点少.然后就想着能不能自己再造个轮子.于是就有了这个项目\xa0'
            'json2canvas\xa0,你可以简单的理解为是mp_canvas_drawer的增强版吧.json2canvas\xa0'
            'canvas绘制海报,写个json就够了.项目的canvas绘制是基于\xa0cax\xa0'
            '实现的.所以天然的带来一个好处,json2canvas同时支持小程序和web功能支持缩放. '
            '如果设计稿是750,而画布只有375时.你不需要任何换算,只需要将scale设置为0.5即可.支持图片圆角支持圆型,矩形,矩形圆角(背景色支持线性渐变)长文本自动换行(感谢 '
            'coolzjy@v2ex 提供的正则\xa0https://regexr.com/4f12l\xa0'
            ',优化了换行的计算方式(不会粗暴的折断单词))支持分组(cax里很好用的一个功能)同时支持小程序和web示例demo-web\xa0'
            '界面左边的json,可以进行编辑,直接看效果哟~小程序demogit clone '
            'https://github.com/willnewii/json2canvas.git\r\n'
            '微信开发者工具导入项目 example/weapp/小程序安装npm i json2canvas\r\n'
            '微信开发者工具->工具->构建npm在需要使用的界面引入Component{\r\n'
            '  "usingComponents": {\r\n'
            '    "json2canvas":"/miniprogram_npm/json2canvas/index"\r\n'
            '  }\r\n'
            '}举个例子想要生成一个这样的海报,需要怎么做？(红框是图片元素,蓝框是文字元素,其余的是一张背景图。)简单,一个json搞定.具体支持的元素和参数,请查看项目\xa0'
            'readme{\r\n'
            '        "width": 750,\r\n'
            '        "height": 1334,\r\n'
            '        "scale": 0.5,\r\n'
            '        "children": [\r\n'
            '            {\r\n'
            '                "type": "image",\r\n'
            '                "url": '
            '"http://res.mayday5.me/wxapp/wxavatar/tmp/bg_concerts_1.jpg",\r\n'
            '                "width": 750,\r\n'
            '                "height": 1334\r\n'
            '            }, {\r\n'
            '                "type": "image",\r\n'
            '                "url": '
            '"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg",\r\n'
            '                "width": 100,\r\n'
            '                "x": 48,\r\n'
            '                "y": 44,\r\n'
            '                "isCircular": true,\r\n'
            '            }, {\r\n'
            '                "type": "circle",\r\n'
            '                "r": 50,\r\n'
            '                "lineWidth": 5,\r\n'
            '                "strokeStyle": "#CCCCCC",\r\n'
            '                "x": 48,\r\n'
            '                "y": 44,\r\n'
            '            }, {\r\n'
            '                "type": "text",\r\n'
            '                "text": "歌词本",\r\n'
            '                "font": "30px Arial",\r\n'
            '                "color": "#FFFFFF",\r\n'
            '                "x": 168,\r\n'
            '                "y": 75,\r\n'
            '                "shadow": {\r\n'
            '                    "color": "#000",\r\n'
            '                    "offsetX": 2,\r\n'
            '                    "offsetY": 2,\r\n'
            '                    "blur": 2\r\n'
            '                }\r\n'
            '            }, {\r\n'
            '                "type": "image",\r\n'
            '                "url": '
            '"http://res.mayday5.me/wxapp/wxavatar/tmp/medal_concerts_1.png",\r\n'
            '                "width": 300,\r\n'
            '                "x": "center",\r\n'
            '                "y": 361\r\n'
            '            }, {\r\n'
            '                "type": "text",\r\n'
            '                "text": "一生活一场 五月天",\r\n'
            '                "font": "38px Arial",\r\n'
            '                "color": "#FFFFFF",\r\n'
            '                "x": "center",\r\n'
            '                "y": 838,\r\n'
            '                "shadow": {\r\n'
            '                    "color": "#000",\r\n'
            '                    "offsetX": 2,\r\n'
            '                    "offsetY": 2,\r\n'
            '                    "blur": 2\r\n'
            '                }\r\n'
            '            }, {\r\n'
            '                "type": "text",\r\n'
            '                "text": "北京6场，郑州2场，登船，上班，听到你想听的歌了吗？",\r\n'
            '                "font": "24px Arial",\r\n'
            '                "color": "#FFFFFF",\r\n'
            '                "x": "center",\r\n'
            '                "y": 888,\r\n'
            '                "shadow": {\r\n'
            '                    "color": "#000",\r\n'
            '                    "offsetX": 2,\r\n'
            '                    "offsetY": 2,\r\n'
            '                    "blur": 2\r\n'
            '                }\r\n'
            '            }, {\r\n'
            '                "type": "rect",\r\n'
            '                "width": 750,\r\n'
            '                "height": 193,\r\n'
            '                "fillStyle": "#FFFFFF",\r\n'
            '                "x": 0,\r\n'
            '                "y": "bottom"\r\n'
            '            }, {\r\n'
            '                "type": "image",\r\n'
            '                "url": '
            '"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg",\r\n'
            '                "width": 117,\r\n'
            '                "height": 117,\r\n'
            '                "x": 47,\r\n'
            '                "y": 1180\r\n'
            '            }, {\r\n'
            '                "type": "text",\r\n'
            '                "text": "长按识别小程序二维码",\r\n'
            '                "font": "26px Arial",\r\n'
            '                "color": "#858687",\r\n'
            '                "x": 192,\r\n'
            '                "y": 1202\r\n'
            '            }, {\r\n'
            '                "type": "text",\r\n'
            '                "text": "加入五月天 永远不会太迟",\r\n'
            '                "font": "18px Arial",\r\n'
            '                "color": "#A4A5A6",\r\n'
            '                "x": 192,\r\n'
            '                "y": 1249\r\n'
            '            }]\r\n'
            '    }问题反馈有什么问题可以直接\xa0提issue',
 'pub_time': '2019-6-19 00:39',
 'title': '通过json用canvas生成分享海报,支持微信小程序和web '}
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-8-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-15-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5195-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=8)
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-8-1.html>
{'author': 'admin',
 'content': '效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 '
            'swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical '
            '加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 '
            'nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 '
            'index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 '
            '即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain '
            '事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 '
            'wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 '
            'MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 '
            'module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot '
            '是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 '
            'module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 '
            'global，这个 global '
            '是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 '
            'requester.js 里面的封装。图二是需要调用数据的页面渲染。',
 'pub_time': '2016-10-12 22:46',
 'title': '微信小程序开发教程第六章：「名片盒」「我」的页面开发 '}
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-15-1.html>
{'author': '天下雪',
 'content': '文件基本结构：\xa0 \u3000 \xa0先看入口app.js，app(obj)注册一个小程序。接受一个 object '
            '参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({\xa0 '
            'onLaunch: function () {\xa0 \xa0 //调用API从本地缓存中获取数据\xa0 \xa0 var '
            "logs = wx.getStorageSync('logs') || []\xa0 \xa0 "
            "logs.unshift(Date.now())\xa0 \xa0 wx.setStorageSync('logs', "
            'logs)\xa0 },\xa0 getUserInfo:function(cb){\xa0 \xa0 var that = '
            'this\xa0 \xa0 if(this.globalData.userInfo){\xa0 \xa0 \xa0 typeof '
            'cb == "function" && cb(this.globalData.userInfo)\xa0 \xa0 '
            '}else{\xa0 \xa0 \xa0 //调用登录接口\xa0 \xa0 \xa0 '
            'wx.login({\xa0 \xa0 \xa0 \xa0 success: function () '
            '{\xa0 \xa0 \xa0 \xa0 \xa0 '
            'wx.getUserInfo({\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 success: function '
            '(res) {\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'that.globalData.userInfo = '
            'res.userInfo\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 typeof cb == '
            '"function" && '
            'cb(that.globalData.userInfo)\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '}\xa0 \xa0 \xa0 \xa0 \xa0 })\xa0 \xa0 \xa0 \xa0 }\xa0 \xa0 \xa0 '
            '})\xa0 \xa0 }\xa0 },\xa0 globalData:{\xa0 \xa0 userInfo:null\xa0 '
            '}})\xa0 \u3000 \xa0'
            '我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性\xa0 \u3000 \xa0'
            'onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。\xa0 \u3000 \xa0'
            "var logs = wx.getStorageSync('logs') || "
            '[]获取本地缓存中的logs属性，如果值为空，那么设置logs=[] '
            '与HTML5中的localStorage作用相似logs.unshift(Date.now()) '
            "当前登录时间添加到数组中\xa0 \u3000 \xa0wx.setStorageSync('logs', logs) "
            "将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据\xa0 \u3000 \xa0"
            'getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数\xa0 \xa0 '
            'var that = this\xa0 \xa0 '
            'if(this.globalData.userInfo){//用户信息不为空\xa0 \xa0 \xa0 typeof cb == '
            '"function" && '
            'cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；\xa0 \xa0 '
            '}else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。\xa0 \xa0 \xa0 '
            'wx.login({\xa0 \xa0 \xa0 \xa0 success: function () '
            '{\xa0 \xa0 \xa0 \xa0 \xa0 '
            'wx.getUserInfo({\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 success: function '
            '(res) {\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 '
            'console.log(res)\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'that.globalData.userInfo = '
            'res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'typeof cb == "function" && '
            'cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '}\xa0 \xa0 \xa0 \xa0 \xa0 })\xa0 \xa0 \xa0 \xa0 }\xa0 \xa0 \xa0 '
            '})\xa0 \xa0 }\xa0 }\xa0\xa0 \u3000 \xa0'
            'globalData对象用来存储全局数据，在其他地方调用\xa0 \u3000 \xa0'
            '然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 '
            'tab 等、\xa0 \u3000 \xa0'
            '最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。\xa0'
            '{\xa0 "pages":[\xa0 \xa0 "pages/index/index",\xa0 \xa0 '
            '"pages/logs/logs"\xa0 ],\xa0 "window":{\xa0 \xa0 '
            '"backgroundTextStyle":"light",\xa0 \xa0 '
            '"navigationBarBackgroundColor": "#fff",\xa0 \xa0 '
            '"navigationBarTitleText": "WeChat",\xa0 \xa0 '
            '"navigationBarTextStyle":"black"\xa0 }}\xa0 \u3000 \xa0'
            '然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。\xa0 \u3000 \xa0'
            '先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。\xa0 \u3000 \xa0'
            'index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。\u3000\u3000'
            '<!--index.wxml--><view class="container">//视图容器\xa0 <view \xa0'
            'bindtap="bindViewTap" '
            'class="userinfo">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js '
            'page()设置添加\xa0 \xa0 <image class="userinfo-avatar" '
            'src="{{userInfo.avatarUrl}}" '
            'background-size="cover"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的\xa0 \xa0 '
            '<text class="userinfo-nickname">{{userInfo.nickName}}</text>\xa0 '
            '</view>\xa0 <view class="usermotto">\xa0 \xa0 <text '
            'class="user-motto">{{motto}}</text>\xa0 '
            '</view></view>\xa0 \u3000 \xa0'
            'index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个 OBJECT '
            '参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var app = getApp() // '
            "获取入口文件app的应用实例Page({\xa0 data: {\xa0 \xa0 motto: 'Hello "
            "World',\xa0 \xa0 userInfo: {}\xa0 },\xa0 "
            '//自定义事件处理函数，点击.userinfo的容易触发此函数\xa0 bindViewTap: function() '
            '{\xa0 \xa0 wx.navigateTo({//全局对象wx的跳转页面方法\xa0 \xa0 \xa0 url: '
            "'../logs/logs'\xa0 \xa0 })\xa0 },\xa0 onLoad: function () "
            "{//发生页面加载时，自动触发该生命周期函数\xa0 \xa0 console.log('onLoad')\xa0 \xa0 "
            'var that = this\xa0 \xa0 //调用应用实例的方法获取全局数据\xa0 \xa0 '
            'app.getUserInfo(function(userInfo){\xa0 \xa0 \xa0 '
            '//更新数据，页面自动渲染\xa0 \xa0 \xa0 that.setData({\xa0 \xa0 \xa0 \xa0 '
            'userInfo:userInfo\xa0 \xa0 \xa0 })\xa0 \xa0 })\xa0 '
            '}})\xa0 \u3000 \xa0'
            'index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。\xa0 \u3000 \xa0'
            '再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。\xa0 \u3000 \xa0'
            'logs.wxml文件<!--logs.wxml--><view class="container log-list">\xa0 '
            '<block wx:for="{{logs}}" '
            'wx:for-item="log">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>\xa0 \xa0 '
            '<text class="log-item">{{index + 1}}. {{log}}</text>\xa0 '
            '</block></view>\xa0 \u3000\u3000logs.js 文件//logs.jsvar util = '
            "require('../../utils/util.js') "
            '//util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({\xa0 data: '
            '{\xa0 \xa0 logs: []\xa0 },\xa0 onLoad: function () {\xa0 \xa0 '
            "this.setData({\xa0 \xa0 \xa0 logs: (wx.getStorageSync('logs') || "
            '[]).map(function (log) '
            '{//通过wx.getStorageSync获取本地缓存的logs日志数据\xa0 \xa0 \xa0 \xa0 return '
            'util.formatTime(new Date(log))//日期格式化\xa0 \xa0 \xa0 })\xa0 \xa0 '
            '})\xa0 }})\u3000\u3000logs.json文件{\xa0 \xa0 '
            '"navigationBarTitleText": "查看启动日志" \xa0 '
            '//当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}\u3000\u3000'
            '基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。',
 'pub_time': '2016-10-13 16:49',
 'title': '微信小程序试用报告：前端源码逻辑和工作流 '}
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5195-1.html>
{'author': 'Rolan',
 'content': '在小程序开发的过程中，小程序的体积会随着版本的迭代变的越来越大，这时候我们就希望能够将小程序分成多个包从服务器下载，这样既可以加快首屏的渲染也便于后续按需加载的实现。小程序在\xa0'
            '微信客户端 6.6.0，基础库\xa0\xa01.7.3\xa0\xa0及以上版本开始支持\xa0'
            '分包功能。在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个\xa0主包\xa0'
            '。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而\xa0分包\xa0'
            '则是根据开发者的配置进行划分。在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。配置方法配置例子{\r\n'
            '  "pages": ["pages/index", "pages/shopcart"],\r\n'
            '  "subpackages": [\r\n'
            '    {\r\n'
            '      "root": "packageA",\r\n'
            '      "pages": ["pages/mine", "pages/order"]\r\n'
            '    },\r\n'
            '    {\r\n'
            '      "root": "packageB",\r\n'
            '      "name": "pack2",\r\n'
            '      "pages": ["pages/detail", "pages/pay"]\r\n'
            '    }\r\n'
            '  ]\r\n'
            '}├── app.js\r\n'
            '├── app.json\r\n'
            '├── app.wxss\r\n'
            '├── packageA\r\n'
            '│   └── pages\r\n'
            '│       ├── mine\r\n'
            '│       └── order\r\n'
            '├── packageB\r\n'
            '│   └── pages\r\n'
            '│       ├── pay\r\n'
            '│       └── detail\r\n'
            '├── pages\r\n'
            '│   ├── index\r\n'
            '│   └── shopcart\r\n'
            '└── utils打包原则声明\xa0\xa0subpackages\xa0\xa0后，将按\xa0\xa0'
            'subpackages\xa0\xa0配置路径进行打包，\xa0subpackages\xa0\xa0配置路径外的目录将被打包到 '
            'app（主包） 中app（主包）也可以有自己的 pages（即最外层的 pages 字段）subpackage\xa0\xa0'
            '的根目录不能是另外一个\xa0\xa0subpackage\xa0\xa0内的子目录tabBar\xa0\xa0页面必须在 '
            'app（主包）内引用原则packageA\xa0\xa0无法 require\xa0\xa0packageB\xa0\xa0JS '
            '文件，但可以 require\xa0\xa0app\xa0、自己 package 内的 JS 文件packageA\xa0\xa0'
            '无法 import\xa0\xa0packageB\xa0\xa0的 template，但可以 require\xa0\xa0'
            'app\xa0、自己 package 内的 templatepackageA\xa0\xa0无法使用\xa0\xa0'
            'packageB\xa0\xa0的资源，但可以使用\xa0\xa0app\xa0、自己 package 内的资源',
 'pub_time': '2019-5-22 00:20',
 'title': '小程序系列--如何使用分包加载 '}
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-19-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-21-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=234> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-19-1.html>
{'author': '天下雪',
 'content': '//app.json页面\xa0'
            '{//页面注册，有几个页面都要在pages里面注册"pages":["pages/index/index","pages/logs/logs","pages/main/main","pages/main1/main1","pages/main2/main2","pages/main3/main3",],//上导航配置及app背景颜色设置"window":{//是否开启下拉刷新"enablePullDownRefresh":true,//窗口背景颜色，在上拉刷新，下拉刷新，navigate切换页面时可以看见"backgroundColor":"#eee",//下拉背景字体、loading '
            '图的样式，仅支持 '
            'dark/light,（string形式）"backgroundTextStyle":"light",//上导航条背景颜色"navigationBarBackgroundColor": '
            '"orange",//上导航标题文字"navigationBarTitleText": '
            '"上导航标题文字","navigationBarTextStyle":"white" '
            '//上导航标题字体颜色，仅支持white和black\xa0},//底部导航配置"tabBar": {"color": '
            '"#a9b7b7",//导航字体默认颜色"selectedColor": '
            '"#eb4f38",//导航字体选中时颜色"borderStyle": "black", //上border颜色，仅支持 '
            'black/white（string形式）"backgroundColor": '
            '"rgba(0,0,0,0.4)",//底部导航背景色"list": [ //导航列表2-5个{"pagePath": '
            '"pages/index1/index1", //每个导航的网页对应的路径"text": "首页", '
            '//标题"iconPath": "images/wechat.png", //默认小图标路径"selectedIconPath": '
            '"images/wechatHL.png" //选中时的小图标路径},{"pagePath": '
            '"pages/index2/index2","text": "日记","iconPath": '
            '"images/pause.png","selectedIconPath": '
            '"images/play.png"},{"pagePath": "pages/index3/index3","text": '
            '"指南","iconPath": "images/pause.png","selectedIconPath": '
            '"images/play.png"},]},//网络请求超时时间"networkTimeout": {"request": '
            '10000,"downloadFile": '
            '9000,"uploadFile":8000,"connectSocket":7000},//是否开启debug模式"debug": '
            'true}//说明：根据官方文档，上述color和bg-color类型为HexColor即16进制类型，（指定仅支持 '
            'black/white，string形式的除外），但实测rbg,rgba和red这些类型目前也支持，但是建议大家还是按文档要求来设置为16进制类型即: '
            '#ffffff '
            '类型；////使用时仅需将文件复制下来，根据需求改动即可；////app.json为标准的json文件，所以不能存在有注释，使用的时候需把注释去掉；\xa0\xa0\xa0'
            '//app.js页面App({//当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onLaunch: '
            'function () {//onLaunch时调用API从本地缓存中获取数据var logs = '
            "wx.getStorageSync('logs') || "
            "[]logs.unshift(Date.now())wx.setStorageSync('logs', "
            'logs)},//获取用户登录信息getUserInfo:function(cb){var that = '
            'thisif(this.globalData.userInfo){typeof cb == "function" && '
            'cb(this.globalData.userInfo)}else{//调用登录接口wx.login({success: '
            'function () {wx.getUserInfo({success: function (res) '
            '{that.globalData.userInfo = res.userInfotypeof cb == "function" '
            '&& '
            'cb(that.globalData.userInfo)}})}})}},//获取后台数据onshow:function(){wx.request({url: '
            "'test.php',data: {x: 'xxx',y: 'yyy'},header: {'Content-Type': "
            "'application/json'},success: function(res) "
            '{console.log(res.data)}})},//设置全局数据//本页面通过this.globalData即可取得数据\xa0'
            'globalData:{userInfo:null}//其他页面可以通过getApp()获取到小程序实例\xa0'
            '//其他页面可以通过getApp().globalData.xxx获取到全局数据})\xa0\xa0'
            '//app.wxss页面.common {height: 100%;display: flex;flex-direction: '
            'column;align-items: center;justify-content: '
            'space-between;padding: 200rpx 0;box-sizing: '
            'border-box;}//仅支持:类:.commonID:#common标签：common多个标签：common1,common2\xa0'
            '伪类::after伪类::before//不支持层级，如.common > view 或者.common '
            'view//引入新的单位rpx:rpx（responsive pixel）: '
            '可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 '
            '上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = '
            '1物理像素。及新的rem:rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx '
            '。//写在app.wxss里面的样式将被设置为公有的，对于其他页面都是可用的',
 'pub_time': '2016-10-13 17:20',
 'title': '微信小程序教程：app配置指南 '}
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=233> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-21-1.html>
{'author': '天下雪',
 'content': '1. WXML(HTML)\u3000\u30001.1 小程序的WXML没有HTML的宽容度?那么高，单标签必需是 /> '
            '结尾的。不然会报错。\u3000\u30001.2 '
            '官方推荐使用的基础标签是块标签，给了作为文本标签，但是使用其他标签比如div也是可以使用的，并且都是inline标签。并且wxml的parser会把标签上的不在白名单上的属性都去掉，class, '
            'id, data '
            '这些应该都在白名单内，但是href什么的是不会有的，所以如果你用传统的html的标签构建页面理论上也是可行的，不过这些都是inline标签，需要自行设定display。\u3000\u3000'
            '1.3 scroll-view 的scroll-top, scroll-left '
            '是可以修改scroll-view的滚动位置的。但是用户自己滚动了之后小程序并不会去改变 scroll-top, '
            'scroll-left 的赋值（并不是双向同步的）。如果这时使用setData去修改的话，scroll-top, '
            'scroll-left '
            '的赋值和上一次的值相同，小程序是不会运用这个修改的，所以表现就是设置没有生效。这时只能先设置一个其他值，再设置回去（这里还可以体现setData方法是同步的）。scroll-view '
            '获取scroll位置，只能通过bindscroll的回调函数获取，所以需要取scroll位置的请自行预存好。scroll-view '
            '还是有webview的 scroll '
            '的臭毛病，在居顶位置如果第一个动作是向下滚动的，会导致之后手怎么滑都滚不动，设置scroll-top '
            '不为0，设个1就好了。\u3000\u30001.4 input '
            '目前只支持文字居左，其他都是不行的（模拟器可以）。如果你做表单，建议把input等表单元素都放在form中，from触发submit时会返回内部所有表单元素的name-value。不然只能绑定所有表单元素的 '
            'change 事情来获取，甚是麻烦。\u3000\u30001.5 只有 \xa0checkbox-group 有 change '
            '事件，单个的checkbox是没有的，如果你只有一个checkbox， '
            '觉得外面套一个checkbox-group麻烦又不美观的话，可以用 switch type="checkbox" '
            '代替。\u3000\u30001.6 map '
            '组建目前直接在app第一个页面加载会出现加载失败。需要在onLoad之后再加在。可以先wx:if="false" '
            '然后onLoad的之后改成 true 就行了。\u3000\u30001.7 map, canvas '
            '像是在webview上面盖一个native组件的感觉。它们是没法被overflow 以及 '
            '上面盖元素的，你可以认为z-index写多高都没法在他上面。所以不建议在页面上做弹层和蒙层。canvas '
            '无法放在scroll-view中滚动会定位在初始位置，如果你给canvas设置背景颜色的话，你会发现背景色块跟着滚了，图没滚。2. '
            'WXSS(CSS)\u3000\u30002.1 WXSS 和 CSS很像，基本所有的CSS都支持，小程序还提供了 rpx '
            '这个单位。一屏幕宽是750rpx。推荐使用这个来作为布局。不过有一些细小的差别我下面会列出\u3000\u30002.2 '
            'WXSS不支持 大括号嵌套（{{}} ）。所以key-frames，CSS animation '
            '就不可用了，不过transition 是可用的。\u3000\u30002.3 '
            '目前测试引入字体也是不可用的，前面WXML中提到的内容看SVG也是没法使用的。所以icon目前只能用图的方式做了。\u3000\u3000'
            '2.4 WXSS中是不能引入本地资源的, 只能使用线上资源（模拟器是可以，但是别信），可以使用base64。\u3000\u3000'
            '2.5 WXSS的 rule 是不支持集联的。所以不能 body .main {background:#000;} '
            '这么写。所以写起来还是比较费劲的。每个class都得很长，不然怕重名。不过支持 li.current {color: red;} '
            '这样的写法，支持after， before伪类，但是不支持 first-child last-child nth-child '
            '这类伪类。\u3000\u30002.6 app.wxss 和每个 page 的wxss 的覆盖关系是: 如果有同名 rule '
            '的话，page 会覆盖 app 的，不是merge是覆盖。\u3000\u30003. JS\u3000\u30003.1 JS '
            '的运行环境和view的运行环境是隔离的。JS只能通过事件获取时机和setData方法修改数据来改变view。\u3000\u3000'
            '3.2 JS 目前有个很大的问题是无法获取到页面px级的宽度高度, '
            '所有事件回调的单位都是px级的而不是rpx的，但是又不知道当前rpx，px的转换关系。比如过你用canvas画图。你都不知道边界在哪里，这个很蛋疼。\u3000\u3000'
            '3.3 上面有说过 setData方法如果上一个值和下一个值相同时，是不会触发view修改的（见1.3）\u3000\u3000'
            '3.4 使用 navigate '
            '跳转的时候可以使用queryString的方式跟在相对地址上，onLoad事件会在入参中传入（会转化成object），但是 '
            'navigate back的时候没有一个官方给出的数据通讯机制。可以使用getApp() '
            '获取到全局对象，给上面加点东西，自行实现。navigate 最多5个什么的就不说了。\u3000\u30003.5 canvas '
            'getActions被调用之后，actions是会被清空的。即连续调用两次getActions，第二次是空数组。\u3000\u3000'
            '3.6 '
            '开发者工具是nw写的，我就看了看裙底的源码，开发者工具中WXML确实是有parser再拼装的过程的。但是并不能说明小工具是native的，从css的支持力度到webview的一些bug相似度来看，我还是觉得像webview，但是组件比如map，canvas什么的用的是原生view，然后盖在webview上的感觉。但是不管怎么说 '
            'auto-focus 能自动呼出键盘就已经是个很大的好评了。',
 'pub_time': '2016-10-13 17:26',
 'title': '微信小程序官方文档里看不到的小Tips '}
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=232> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-9-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-13-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=231> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=230> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-9-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:24:59 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-13-1.html>
{'author': 'admin',
 'content': '整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时 '
            'bindinput 事件，大家别使用 bindchange 事件，这里的 bindchange '
            '事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了 '
            'from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件 '
            'bindtouchstart 与 bindtouchmove，这里必须绑定它的 id，这个 id '
            '都是不同的，我这使用的用户创建完成后在后台生成的一个 id 号，之后我再 block 出来使用在这里，这个 id '
            '都是唯一的，不能是相同的 id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了 css3 '
            '的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap '
            '点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart 发生后，会执行 '
            'bindtouchmove 事件，在这里我们可以判断是否左右滑动：* Var dataId = '
            'e.currentTarget.id //获取到前面唯一的id；If(key){ '
            '//用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；* '
            'Touch是获取触摸点的一些数据，touches 是一个触摸点的数组，每个触摸点包括以下属性：* '
            'pageX,pageY：距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴；* '
            'clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；* '
            'screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用 '
            'clientX,clientY 即可。我们在 bindtouchstart 时记录到开始的点，在 bindtouchmove '
            '记录到触摸结束的点，如果 X 轴滑动大于 Y '
            '轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在 '
            'wxml 里面 block 的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的 id== 当前被事件操作的 '
            'id，那么我给改数组再添加一个 right 向右偏移 15%，否则其他都不偏移，右滑同理，直接全部设置为 '
            '0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X '
            '轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个 '
            'catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在 '
            'data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是 '
            'copy '
            '首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给 '
            'checked 设置 Boole '
            '开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是 '
            'from 表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。',
 'pub_time': '2016-10-12 23:31',
 'title': '微信小程序开发教程第八章：分组开发与左滑功能实现 '}
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:24:59 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-11-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=236)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5202-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5204-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5201-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-11-1.html>
{'author': 'admin',
 'content': '找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime '
            'Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app '
            '的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 '
            'tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* '
            'Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 '
            'page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* '
            'networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* '
            'iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 '
            'tabar 高度会减少很多。\xa0Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 '
            'require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 '
            'require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar '
            '以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css '
            '文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js '
            '目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 '
            'pages 里面才能生效。',
 'pub_time': '2016-10-12 23:22',
 'title': '微信小程序开发教程第三章：项目结构以及配置 '}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5202-1.html>
{'author': 'Rolan',
 'content': '在程序开发中，难免会要考虑一些基础业务以外的功能，如错误提示、升级提示、维护提示等...有时候因为时间问题，产品可能只开发部分功能就上线了，而为了让用户知道有这么一个功能，未开发完全的功能则仅放置一个入口，此时就需要一个升级/维护的提示页面...功能升级中.png如上图：这个页面很简单，一张图片，一行文字，在代码上，都不需要写任何js代码。仅需改动wxml和wxss即可；<!--pages/error/update.wxml--><view '
            "class='vertical'>  <image class='image' "
            "src='../../images/icon-update.png' mode='widthFix'></image>  "
            '<text '
            "class='text'>功能升级中...</text></view>在这里，唯一需要注意的是mode='widthFix'，之所以能保持image显示的图片等比缩放，就是通过mode控制的，该属性默认值是scaleToFill，即拉伸充满image容器。另外还有一些其他值，参考官方文档即可，这里不介绍了...\xa0"
            'wxss/* pages/error/update.wxss */.vertical{  display: flex;  '
            'flex-direction: column;  align-items: center;}.bg-white {  '
            'background-color: #ffffff;}.image {  margin-top: 30%;  width: '
            '200rpx;}.text {  margin-top: 50rpx;  font-size: 40rpx;  color: '
            '#333333;}wxss同样很简单，关键点在于纵向布局vertical，它包含了元素纵向排列flex-direction: '
            'column;及居中align-items: center;\xa0'
            '图片最后，则是在images中放入图片icon-update.png\xa0简书：ThinkinLiu 博客: '
            'IT老五这只是一个简单的功能升级页面，同时，你也可以将图片和文字改改，改为维护页、错误页或者其他提示页...',
 'pub_time': '2019-5-28 00:08',
 'title': '微信小程序：功能升级中页面（图片等比缩放） '}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5204-1.html>
{'author': 'Rolan',
 'content': '小程序5种路由方法使用场景，封装路由文件和路由方法，提升小程序体验和开发效率明确要解决的问题每次使用路由时，总是粘贴复制路径，这样在路径有修改时，需要修改所有用到该路径的地方，维护成本高路由跳转时拼接参数让人头大，业务复杂时要拼接十几个参数路由返回，只会返回一层，不能直接返回到目标页面，因为不知道目标页面是否在路由栈中，也不知道在第几层这些问题都可以通过封装路由文件和路由方法解决，提供开发效率，减少BUG，省下来的时间可以多陪陪女朋友封装路由文件，对路由进行统一管理在根目录创建router.js// '
            '这是路由管理页面，在此统一配置路由\r\n'
            'export default {\r\n'
            "  'index':'/index/index', // 首页\r\n"
            "  'list':'/list/list', // list页面\r\n"
            "  'top':'/top/top', // top页面\r\n"
            '}\r\n'
            '复制代码解决了第一个问题封装路由方法路由方法有五个，常用的有三个\xa0switchTab\xa0、\xa0'
            'navigateTo\xa0、\xa0navigateBack简单介绍一下这五个方法及使用场景switchTab\xa0'
            ',跳转tabBar页面专用，其他页面出栈，新页面入栈navigateTo\xa0'
            '最常用的路由跳转，会加入到页面栈，允许返回，也就是新页面不断入栈navigateBack\xa0'
            '返回，只能返回到页面栈中存在的页面，页面不断出栈，直到到达目标页redirectTo\xa0'
            '关闭当前页面，跳转某个页面，当前页面不会加入到页面栈，也就是说当前页面不能通过返回到达，比如付款页面，付款完成后，最好不要再让用户返回到付款页，再比如一些无法修改的操作，比如删除商品，商品删除后再通过\xa0'
            'navigateBack\xa0返回再删除一次商品，体验肯定不好，表现为当前页面出栈，新页面入栈reLaunch\xa0'
            '关闭所有页面，打开某个页面，可以打开任意页面包括tabBar，适合强制完成某个操作的页面，比如登录页，当已登录的用户点击退出后，进入登录页，那么就不能通过返回再回去了，就必须留下来登录或注册，适合用这个，表现为所有页面出栈，新页面入栈开始封装，在根目录创建utils.js// '
            '封装路由方法\r\n'
            'export default {\r\n'
            '\r\n'
            '  /** \r\n'
            '   * function\r\n'
            '   * @param {string} url 目标页面的路由\r\n'
            '   * @param {Object} param 传递给目标页面的参数\r\n'
            '   * @description  '
            '处理目标页面的参数，转成json字符串传递给param字段，在目标页面通过JSON.parse(options.param)接收\r\n'
            '   */  \r\n'
            '  navigateTo(url,param={}){\r\n'
            '    if(param){\r\n'
            '      url+=`?param=${JSON.stringify(param)}`\r\n'
            '    }\r\n'
            '    wx.navigateTo({\r\n'
            '      url:url,\r\n'
            '      fail(err) {\r\n'
            "        console.log('navigateTo跳转出错',err)  \r\n"
            '      },\r\n'
            '    })\r\n'
            '  },\r\n'
            '\r\n'
            '\r\n'
            '   /** \r\n'
            '   * function\r\n'
            '   * @param {string} url 目标页面的路由\r\n'
            '   * @param {Object} param '
            '传递给目标页面的参数，只有页面栈无目标页面调用navigateTo时，参数才会生效，单单返回不能设置参数\r\n'
            '   * @description  '
            '先取出页面栈，页面栈最多十层，判断目标页面是否在页面栈中，如果在，则通过目标页的位置，返回到目标页面，否则调用navigateTo方法跳转到目标页\r\n'
            '   */   \r\n'
            '  navigateBack(url,param={}){\r\n'
            '    const pagesList = getCurrentPages()\r\n'
            '    let index =  pagesList.findIndex(e=>{\r\n'
            '      return url.indexOf(e.route)>=0\r\n'
            '    })\r\n'
            '    if(index == -1){  // 没有在页面栈中，可以调用navigateTo方法\r\n'
            '      this.navigateTo(url,param)\r\n'
            '    }else{\r\n'
            '      wx.navigateBack({\r\n'
            '        delta: pagesList.length-1-index,\r\n'
            '        fail(err){\r\n'
            "          console.log('navigateBack返回出错',err)\r\n"
            '        }\r\n'
            '      })\r\n'
            '    }\r\n'
            '  },\r\n'
            '\r\n'
            '\r\n'
            '  switchTab(url){ // 封装switchTab，switchTab不能有参数\r\n'
            '    wx.switchTab({\r\n'
            '      url:url\r\n'
            '    })\r\n'
            '  },\r\n'
            '  redirectTo(url,param={}){ // 封装redirectTo，和navigateTo没啥区别\r\n'
            '    if(param){\r\n'
            '      url+=`?param=${JSON.stringify(param)}`\r\n'
            '    }\r\n'
            '    wx.redirectTo({\r\n'
            '      url:url,\r\n'
            '      fail(err) {\r\n'
            "        console.log('redirectTo跳转出错',err)  \r\n"
            '      },\r\n'
            '    })\r\n'
            '  },\r\n'
            '  reLaunch(url,param={}){ // 封装reLaunch，和navigateTo没啥区别\r\n'
            '    if(param){\r\n'
            '      '
            'url+=`?param=${JSON.stringify(param)}`要根据具体业务来，该返回就返回，该跳转就用跳转，不能一直跳转！\r\n'
            '    }\r\n'
            '    wx.reLaunch({\r\n'
            '      url:url,\r\n'
            '      fail(err) {\r\n'
            "        console.log('reLaunch跳转出错',err)  \r\n"
            '      },\r\n'
            '    })\r\n'
            '  }\r\n'
            '}\r\n'
            '复制代码以上对参数的封装解决了第二个问题，对\xa0navigateBack\xa0的封装解决了第三个问题',
 'pub_time': '2019-5-28 00:32',
 'title': '小程序封装路由文件和路由方法，5种路由方法全解析 '}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5201-1.html>
{'author': 'Rolan',
 'content': '在做小程序列表展示的时候，接到了一个需求。需要在列表展示的时候加上动画效果。设计视频效果如下图：需要在进入列表页的时候，依次展示每一条卡片，在展示完成后需要隐藏掉当天之前的卡片。实现思路实现该动画效果，首先需要给每个卡片添加一个css动画。因为每个卡片的显示是有时间间隔的，以及考虑到展示完成后的隐藏效果，所以动画效果需要用js动态去添加。在看了微信开发文档后，发现微信小程序提供了Animation的一个动画对象，具体看了里面的参数后发现，是可以实现需求上的效果的。具体使用如下api:wx.createAnimation(Object '
            'object) 创建一个animation对象。最后通过动画实例的export方法导出动画数据传递给组件的 animation '
            '属性。里面有如下参数：duration（动画持续时间，单位 '
            'ms）,timingFunction（动画的国度效果）,delay（动画延迟）创建的animation对象，本次实现过程中需要用到如下属性：Animation.export() '
            '可以导出动画队列，export 方法每次调用后会清掉之前的动画操作。Animation.step(Object object) '
            '表示一组动画完成。可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。比如一组动画结束了，就以step()结尾Animation.translateY(number '
            'translation) 在 Y 轴平移的距离，单位为 pxAnimation.opacity(number value) 透明度 '
            '0-1的取值范围看到上面这些属性，合理使用的话，那么实现需求提到动画效果那是稳稳的。实现步骤封装一个方法，用来创建动画，并方便调用/**\r\n'
            ' * 动画实现\r\n'
            ' * @method animationShow\r\n'
            ' * @param {that} 当前卡片\r\n'
            ' * @param {opacity} 透明度\r\n'
            ' * @param {delay} 延迟\r\n'
            ' * @param {isUp} 移动方向\r\n'
            ' */\r\n'
            '  animationShow: function (that,opacity, delay, isUp) {\r\n'
            '    let animation = wx.createAnimation({\r\n'
            '      duration: 1000,\r\n'
            "      timingFunction: 'ease',\r\n"
            '      delay: delay\r\n'
            '    });\r\n'
            '    <!--考虑到还需要隐藏掉当天之前的卡片，做如下判断来赋予不同的动画效果-->\r\n'
            "    if (isUp == 'down') {\r\n"
            '      '
            'animation.translateY(0).opacity(opacity).step().translateY(-80).step();\r\n'
            "    } else if (isUp == 'up') {\r\n"
            '      '
            'animation.translateY(0).opacity(opacity).step().translateY(-140).opacity(0).step()\r\n'
            '    } else {\r\n'
            '      animation.translateY(0).opacity(opacity).step()\r\n'
            '    }\r\n'
            "    let params = ''\r\n"
            '    params = animation.export()\r\n'
            '    return params\r\n'
            '  }, \r\n'
            '复制代码初始化每个卡片的样式首先每个卡片的位置相对于自身往Y轴平移80像素，并且把透明度设置为0。这样就可以进入页面的时候再往下平移并且让卡片逐渐显示。\r\n'
            '.init{\r\n'
            '  opacity: 0;\r\n'
            '  transform: translateY(-80px)\r\n'
            '}\r\n'
            '复制代码处理数据循环处理每一条数据，通过调用封装的方法，来获得该卡片应该拥有的动画属性for (let i = 0; i < '
            'transData.length; i++) {\r\n'
            '    if (i == 0) {\r\n'
            '      transData[i].animation = that.app.slideupshow(that, 1, 0, '
            "'up')\r\n"
            '    } else {\r\n'
            '      transData[i].animation = that.app.slideupshow(that, 1, (i + '
            "1) * 10, 'down')\r\n"
            '    }\r\n'
            '  }\r\n'
            '复制代码跟设计视频中的动画风格基本保持一致，美滋滋。',
 'pub_time': '2019-5-28 00:01',
 'title': '微信小程序-渐入渐出动画效果实现 '}
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5207-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5212-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5206-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5208-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5207-1.html>
{'author': 'Rolan',
 'content': '前言近期闲来无事，想着闲着也是闲着，不如给自己搞点事情做！敢想敢做，于是选择了给微信小程序做个仿iPhone通讯录效果的自定义组件。先来整理一下，瞧瞧需要实现的核心功能。按照第一个字的首字母排序;实现输入搜索功能；侧边栏字母导航；从易到难，先来看看页面的结构布局。基本上分为3块：顶部的搜索区域；内容的展示区域；侧边字母导航栏区域；// '
            'index.wxml\r\n'
            '<view class="main">\r\n'
            '  <!-- 顶部搜索区域 -->\r\n'
            '  <view class="header">\r\n'
            '  </view>\r\n'
            '  <!-- 内容区域 -->\r\n'
            '  <scroll-view class="scroll">\r\n'
            '  </scroll-view>\r\n'
            '  <!-- 侧边导航 -->\r\n'
            '  <view class="sub_nav">\r\n'
            '  </view>\r\n'
            '</view>\r\n'
            '复制代码【顶部的搜索区域】一目了然就直接贴代码了。<view class="header">\r\n'
            '    // 这里或许有人要问，为啥不用小程序的label组件呢。?_?\r\n'
            '    // 原因就是...我就不用，你还能咬我？！^(oo)^\r\n'
            '    // 哈哈哈哈～开个玩笑，其实是小程序的label组件还没支持input!\r\n'
            '    <view class="label"> \r\n'
            '      <icon></icon>\r\n'
            '      <input type="text" placeholder="搜索" />\r\n'
            '    </view>\r\n'
            '</view>\r\n'
            '复制代码【内容的展示区域】再说一目了然会不会被打呢？根据图片就可以看出来，存在2个区域。红框包围的外框，负责圈定展示的范围；绿框包围的范围，包含有字母标题和对应的子项。代码如下：<scroll-view '
            'class="scroll">\r\n'
            '    <view class="dl">\r\n'
            '      <view class="dt">这里是字母标题。</view>\r\n'
            '      <view class="dd">\r\n'
            '        <span>这里当然是展示的内容啦。</span>\r\n'
            '      </view>\r\n'
            '    </view>\r\n'
            '  </scroll-view>\r\n'
            '复制代码【侧边字母导航栏区域】为了节省一下文章的篇幅，这里就不贴图了，很简单，就是并排下来就好了。<view '
            'class="sub_nav">\r\n'
            '    <view class="option">这里是输出字母。</view>\r\n'
            '</view>\r\n'
            '复制代码接下来是wxss的样式了。考虑到wxss的样式较多，我就直接贴代码链接吧，有兴趣的童鞋可以瞧瞧。完成之后，是时候贴个效果图了。（不许吐槽丑，宝宝会不开心的！）结构样式弄完了，也贴一下自定组件的基础文件// '
            'index.json\r\n'
            '{\r\n'
            '  "component": true\r\n'
            '}\r\n'
            '复制代码// index.js\r\n'
            'Component({\r\n'
            '  properties: {}, // 组件的对外属性\r\n'
            '  data: {},       // 组件的内部数据\r\n'
            '  lifetimes: {},  // 生命周期\r\n'
            '  methods: {}     // 事件\r\n'
            '});\r\n'
            '复制代码现在开始实现功能了！！！按照第一个字的首字母排序说实话，实现这块功能呢，我是没啥头绪的，所以这个时候就要求助伟大的“度娘/Google”了。经过楼主“遍寻网络”，查找到如下页面的源码参考：因楼主问题，遗忘了该网址，如有知道的童鞋，贴个链接告诉下楼主，楼主立马麻溜的加上。源码的原理大概描述下：收录20902个汉字和375个多音字的Unicode编码，然后用JS切割首字母并转换成Unicode进行对比，最后返回对应首字母的拼音。// '
            '汉字对应的Unicode编码文件\r\n'
            '// oMultiDiff = 多音字 | firstLetterMap = 汉字\r\n'
            "import firstStore from './firstChineseLetter'; \r\n"
            '\r\n'
            '// 获取首字母拼音\r\n'
            'function getFirstLetter (val) {\r\n'
            '  const firstVal = val.charAt(0);\r\n'
            '  if (/.*[\\u4e00-\\u9fa5]+.*/.test(firstVal)) {\r\n'
            '    // 处理中文字符\r\n'
            '    // 转换成Unicode编码，与firstStore里面的数据进行对比，然后返回对应的参数\r\n'
            '    const code = firstVal.charCodeAt(0); // 转换成Unicode编码\r\n'
            '    return code in firstStore.oMultiDiff ? '
            'firstStore.oMultiDiff[code] : '
            'firstStore.firstLetterMap.charAt(code - 19968);\r\n'
            '  } else {\r\n'
            '    // 这里处理非中文\r\n'
            '    // 检测是否字母，如果是就直接返回大写的字母\r\n'
            '    // 不是的话，返回“#”\r\n'
            '    return /^[a-zA-Z]+$/.test(firstVal) ? firstVal.toUpperCase() '
            ": '#';\r\n"
            '  }\r\n'
            '}\r\n'
            '\r\n'
            "getFirstLetter('东城区');\r\n"
            '// 输出结果：D\r\n'
            '\r\n'
            '复制代码firstChineseLetter.js地址获取首字母的方法有了之后，就该对数据进行处理了。首先定义一下组件所需要的参数。Component({\r\n'
            '  // 组件的对外属性\r\n'
            '  properties: {\r\n'
            '    data: { type: Array, value: [],  }, // 组件外传递进来的数据\r\n'
            "    attr: { type: String, value: 'label' }, // "
            '需要进行首字母处理的属性，默认是"label"\r\n'
            '  },\r\n'
            '  ...\r\n'
            '})\r\n'
            '复制代码然后，针对组件外传递进来的数据，做一次转换。// 静态数据的存储\r\n'
            'const Static = {\r\n'
            '  list: []\r\n'
            '}\r\n'
            '\r\n'
            'Component({\r\n'
            '  ...\r\n'
            '  methods: {\r\n'
            '    // 初始/重置数据\r\n'
            '    init () {\r\n'
            '      const { data, attr } = this.properties;\r\n'
            '\r\n'
            '      let changeData = [], // 转换后的数据\r\n'
            '          inChangeData = {}; // 存储转换后的数据对应字母的索引值\r\n'
            '          \r\n'
            '      data.map(v => {\r\n'
            '        // 获取首字母拼音\r\n'
            '        let firstLetter = this.getFirstLetter(v[attr]); \r\n'
            '        \r\n'
            '        // 循环对比检测\r\n'
            "        firstLetter.split('').map(str => {\r\n"
            '          if (str in inChangeData) {\r\n'
            '            // 有首字母相同的项，\r\n'
            '            // 则添加入已有的项里面\r\n'
            '            changeData[inChangeData[str]].list.push(v);\r\n'
            '          } else {\r\n'
            '            // 没有首字母相同的项，\r\n'
            '            // 则在尾部追加一条新的数据，\r\n'
            '            // 储存对应的字母值（firstLetter），\r\n'
            '            // 同时存储该字母对应的索引\r\n'
            '            changeData.push({ firstLetter: str, list: [v] });\r\n'
            '            inChangeData[str] = changeData.length - 1;\r\n'
            '          }\r\n'
            '        });\r\n'
            '      });\r\n'
            '      \r\n'
            '      // 此时转换后的数组属于乱序，\r\n'
            '      // 需要对乱序的数组进行排序\r\n'
            '      changeData.sort((pre, next) => pre.firstLetter < '
            'next.firstLetter ? -1 : 1);\r\n'
            '      \r\n'
            '      // 若存在“#”项，将位置位移至底部\r\n'
            "      if (changeData[0].firstLetter === '#') {\r\n"
            '        const firstArr = changeData.splice(0, 1);\r\n'
            '        changeData = [...changeData, ...firstArr];\r\n'
            '      }\r\n'
            '\r\n'
            '      // 存储转换后的数据，\r\n'
            '      // this.data.list的数据对应页面的展示数据，因为有搜索功能，数据可能会变更，\r\n'
            '      // 在静态的数据里面，也存储1份数据，方便后续的搜索等功能。\r\n'
            '      this.setData({ list: changeData });\r\n'
            '      Static.list = changeData;\r\n'
            '    },\r\n'
            '  }\r\n'
            '  ...\r\n'
            '});\r\n'
            '复制代码初始化函数有了之后呢，当然是调用它啦。Component({\r\n'
            '  lifetimes: {\r\n'
            '    // 在组件实例进入页面节点树时执行初始化数据\r\n'
            '    attached () {\r\n'
            '      this.init();\r\n'
            '    }\r\n'
            '  },\r\n'
            '  observers: {\r\n'
            '    // 考虑到组件传递的数据存在变更的可能，\r\n'
            '    // 在数据变更的时候，也要做一次初始化\r\n'
            "    'data, attr, icon' (data, attr) {\r\n"
            '      this.init();\r\n'
            '    }\r\n'
            '  },\r\n'
            '})\r\n'
            '复制代码接下来是搜索功能啦～先给页面搜索框加个监听事件（input）<view class="main">\r\n'
            '  ...\r\n'
            '  <view class="header">\r\n'
            '    <view class="label">\r\n'
            '      <icon></icon>\r\n'
            '      <input type="text" placeholder="搜索" value="{{ search }}" '
            'bindinput="searchData" />\r\n'
            '    </view>\r\n'
            '  </view>\r\n'
            '  ...\r\n'
            '</view>\r\n'
            '复制代码接着是JS的事件const Static = {\r\n'
            '  list: []\r\n'
            '}\r\n'
            '\r\n'
            'Component({\r\n'
            '  ...\r\n'
            '  methods: {\r\n'
            '    searchData (e) {\r\n'
            '      const { value } = e.detail; // 用户输入的值\r\n'
            '      const { list } = Static; // init存储的静态数据，用来做数据对比\r\n'
            '      const { attr } = this.properties; // 要对比的属性值\r\n'
            '      let result = [], tem = {};\r\n'
            '      \r\n'
            '      // 没有搜索内容，返回全部内容\r\n'
            '      if (value.length === 0) { this.setData({ list: Static.list '
            '}); return; }\r\n'
            '\r\n'
            '      // 检索搜索内容\r\n'
            '      list.map(v => {\r\n'
            '        // 获取所有跟value匹配上的数据\r\n'
            '        const searchList = v.list.filter(v => '
            'v[attr].indexOf(value) !== -1);\r\n'
            '        \r\n'
            '        if (searchList.length > 0) {\r\n'
            '          // 此处原理类似楼上init的对比，此处不细说，\r\n'
            '          // 反正我懒我有理（0.0）\r\n'
            '          if (v.firstLetter in tem) {\r\n'
            '            const _list = result[tem[v.firstLetter]].lish;\r\n'
            '            result[tem[v.firstLetter]].lish = [..._list, '
            '...searchList];\r\n'
            '          } else {\r\n'
            '            result.push({ firstLetter: v.firstLetter, list: '
            '[...searchList] });\r\n'
            '            tem[v.firstLetter] = result.length - 1;\r\n'
            '          }\r\n'
            '        }\r\n'
            '      });\r\n'
            '      \r\n'
            '      // 存储数据\r\n'
            '      this.setData({ list: result, search: value });\r\n'
            '    }\r\n'
            '  },\r\n'
            '  ...\r\n'
            '});\r\n'
            '复制代码侧边栏字母导航（突然觉得，写文好累啊！！！）写这块的时候呢，楼主发现了iPhone通讯录侧边导航栏有个问题，手指在字母导航栏上滑动的时候，有时候很难确认自己滑到了哪个区域？！然鹅这个问题呢，楼主发现了微信的通讯录，针对这块添加了手指滑动的时候，添加了个结构来帮助用户确认目前所处的区域。楼主本着学习的精神，借(chao)鉴(xi)了这个效果，来个效果图。贴一下新的wxml结构<!-- '
            '侧边导航 -->\r\n'
            '  <view class="sub_nav" id="subNav" '
            'catchtouchstart="subTouchStart" catchtouchmove="subTouchMove" '
            'catchtouchend="subTouchEnd">\r\n'
            '    <view class="option" wx:for="{{ list }}" data-firstLetter="{{ '
            'item.firstLetter }}" wx:key="firstLetter">\r\n'
            '      {{ item.firstLetter }}\r\n'
            '      <!-- 以下这块就是新增的结构啦 S -->\r\n'
            '      <view \r\n'
            '        class="max {{ item.firstLetter ===  scrollIntoView && '
            'subNavHint ? \'show\' : \'\' }}" \r\n'
            '        data-desc="{{ item.firstLetter }}"\r\n'
            '      ></view>\r\n'
            '      <!-- 以上这块就是新增的结构啦 E -->\r\n'
            '    </view>\r\n'
            '  </view>\r\n'
            '复制代码const Static = {\r\n'
            '  list: [],\r\n'
            '  timer: null\r\n'
            '}\r\n'
            '\r\n'
            'Component({\r\n'
            '  ...\r\n'
            '  data: {\r\n'
            "    scrollIntoView: '', // 标记当前处于哪个字母\r\n"
            '    subNavHint: false, // 控制借(chao)鉴(xi)微信效果的元素\r\n'
            '  },\r\n'
            '  methods: {\r\n'
            '    subTouchStart () {\r\n'
            "      this.setData({ subNavHint: true, scrollIntoView: '' });\r\n"
            '    },\r\n'
            '    subTouchEnd () {\r\n'
            '      this.setData({ subNavHint: false });\r\n'
            '    },\r\n'
            '    subTouchMove (e) {\r\n'
            '      // 获取字母导航栏元素对应的值\r\n'
            '      const query = this.createSelectorQuery();\r\n'
            "      query.select('#subNav').boundingClientRect();\r\n"
            '      query.selectViewport().scrollOffset();\r\n'
            '      query.exec(res => {\r\n'
            '        const { clientY } = e.touches[0]; // Y轴的位置\r\n'
            '        const DomTop = res[0].top; // 导航元素距离顶部的位置\r\n'
            '        const { list } = this.data;\r\n'
            '        \r\n'
            '        // 计算索引，\r\n'
            '        // 或许看到这里有人会疑问，为什么是除以20？\r\n'
            '        // 因为样式里面，我写的高度是20px，所以每个字母的区域是20px。\r\n'
            '        let index = Math.round((clientY - DomTop) / 20); \r\n'
            '        index = index >= list.length ? list.length - 1 : index; '
            '// 限制索引大于0\r\n'
            '        index = index < 0 ? 0 : index; // 限制索引小于0\r\n'
            '        // 限制结果重复赋值\r\n'
            '        if (list[index].firstLetter !== this.data.scrollIntoView) '
            '{\r\n'
            '          this.setData({ scrollIntoView: list[index].firstLetter '
            '});\r\n'
            '          // 加个抖动效果\r\n'
            '          wx.vibrateShort(); \r\n'
            '        }\r\n'
            '      });\r\n'
            '      }\r\n'
            '    },\r\n'
            '  }\r\n'
            '  ...\r\n'
            '});\r\n'
            '复制代码结语文章写到这呢，基本上核心的功能都已经实现啦～（终于写完了...）通过自己封装组件，楼主还是有挺大收获的！当然，这个组件还有很多可以继续完善的地方，有兴趣的童鞋呢，可以提出你的优化建议，楼主有时(xing)间(qu)的话，会继续完善下去。最后，还是推一下这个组件啦，希望它能帮到有需要的童鞋。github地址手写不易，欢迎提issues，欢迎star，内附有使用方法哦。',
 'pub_time': '2019-5-29 00:39',
 'title': '仿iPhone通讯录制作小程序自定义选择组件 '}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5212-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5206-1.html>
{'author': 'Rolan',
 'content': '小程序 多图列表 性能优化写这篇文章的缘由: 最近在公司的小程序项目中遇到了页面图片元素过多导致的性能问题. '
            '从小程序提供的性能检测面板分析, 确定是图片元素占用了过多内存导致.因为本人之前主要是做桌面端应用开发和原生app开发, '
            '没有太顾及过移动端图片的内存占用问题. 这次既然遇到了, 也就趁这个机会学习一下其优化的技巧.什么造成的性能问题简单的来说:\xa0'
            'DOM节点过多\xa0&&\xa0图片节点过多DOM节点过多会造成更多的内存占用. 按照目前的微信小程序限制, '
            '内存占用500M以上会出现卡顿, 甚至闪退. 如果列表中节点没有图片标签, 内存占用现象还不会太明显, '
            '只是DOM节点过多会造成页面渲染耗时增加. 但当列表节点中含有图片时, 内存占用会迅速攀升.如何解决这两点呢?对于上面两点, '
            '我们分别有对应的优化思路1. DOM节点过多.对于无限加载的页面, 列表中每一个元素都有大量的子节点. 当列表数目增加时, '
            '页面的总节点数会暴增. 以小红书的小程序为例:上图中可以看到, 该页面为很多的卡片组成的列表页面. 假设一个卡片的DOM子节点数为 '
            '30, 那么当列表元素加载到1000时, 页面会有\xa030 * 1000 = 30,000\xa0个DOM节点. '
            '小程序显然是吃不消的 (注: 微信小程序推荐总节点数不超过:\xa01000\xa0)那我们该如何处理来减少节点数呢?思路很简单: '
            '我们可以只对用户当前屏幕和上下两屏进行真实内容的加载, 对于其他用户暂时不可见的地方, 用空白的节点进行占位. 这样处理后, '
            '实际有内容的卡片数目不超过5个, 页面的总节点数为:\xa05 * 30 + 995 = 1145\xa0. '
            '相对于之前的节点数有了巨大的改进.让我们来看看代码的实现写代码前, 让我们整理一下需要的数据结构.首先这是一个列表页面, '
            '我们需要一个 List来保存页面显示的数据:\xa0showCards\xa0.\xa0showCards\xa0'
            '中只会保存5条真实数据, 其余数据展示以空对象填充.我们还需要一个保存所有真实数据的List, 这样当用户滑动页面时, '
            '我们才能实时获取需要显示的卡片真实数据:\xa0totalCardsPage({\r\n'
            '  showCards: [],\r\n'
            '  totalCards: []\r\n'
            '})接下来我们来写页面布局部分:<view wx:for="{{showCards}}"\r\n'
            '        wx:key="{{index}}">\r\n'
            '\r\n'
            '    <self-define-component data-card-data="{{item}}">\r\n'
            '    </self-define-component>\r\n'
            '    \r\n'
            '</view>简单的代码框架就是这样 (这里省略了很多不影响理解思路的代码细节)我们先实现没有优化DOM节点的代码逻辑. '
            '在页面滑动到最底部时, 向\xa0showCards\xa0push进新的卡片, 并通过\xa0setData\xa0更新页面. '
            '这样就实现了一个简单的下拉无限加载的列表页面.async onReachBottom() {\r\n'
            '    const newCards = await fetchNewCards();\r\n'
            '  this.data.showCards.push(newCards);\r\n'
            '  this.setData({\r\n'
            '    showCards: this.data.showCards\r\n'
            '  })\r\n'
            '},接下来我们实现优化DOM节点的代码逻辑.我们会再用户滑动页面(\xa0onScroll\xa0事件) 时, '
            '对当前页面每个\xa0card\xa0的位置进行判断, 如果该 card在用户可见范围内的上下两屏内, 则展示真实数据, '
            '否则将其替换为宽高与原卡片一致的空白占位节点.在 Page 的\xa0onPageScroll\xa0回调中, '
            '我们进行回收函数的调用 (注意这里回调时要进行\xa0节流\xa0处理, 否则频繁调用会导致页面闪动) . '
            '让我们看看这个回收页面节点函数的主要逻辑:回调中, 我们首先通过小程序提供的获取页面元素位置的api:\xa0'
            'createSelectorQuery().boundingClientRect\xa0来拿到每个卡片的位置信息.接下来, '
            '我们通过位置信息, 判断是否展示card的真实数据. 对于不展示真实数据的card, 我们需要保存其高度信息, '
            '以便在渲染页面时使用高度信息填充页面. 同时我们给空card一个 type 属性, 方便我们在 '
            'wxml中渲染时判断卡片类型.async onScrollCallback() {\r\n'
            '  try {\r\n'
            '    const rectList = await this.calcCardsHeight();\r\n'
            '    this.recycleCard(rectList);\r\n'
            '  } catch (e) {\r\n'
            '    console.error(e);\r\n'
            '  }\r\n'
            '}\r\n'
            '  calcFeedHeight() {\r\n'
            '    return new Promise((resolve, reject) => {\r\n'
            '      this.createSelectorQuery()\r\n'
            '        .selectAll(`.card`)\r\n'
            '        .boundingClientRect(rectList => {\r\n'
            '          resolve(rectList);\r\n'
            '        })\r\n'
            '        .exec()\r\n'
            '    })\r\n'
            '  },\r\n'
            '\r\n'
            '  recycleCard(rectList) {\r\n'
            '    const newShowCards = [];\r\n'
            '    for (let i = 0; i < this.data.showCards.length; i++) {\r\n'
            '      const rect = rectList[i];\r\n'
            '      if (rect && Math.abs(rectList[i].top - 0) > pageHeight * 2) '
            '{\r\n'
            '        newShowCards.push({\r\n'
            "          type: 'empty-card',\r\n"
            '          height: rectList[i].bottom - rectList[i].top\r\n'
            '        });\r\n'
            '      } else {\r\n'
            '          const feed = totalCards[i];\r\n'
            '        newShowCards.push(feed);\r\n'
            '      }\r\n'
            '    }\r\n'
            '    this.setData({\r\n'
            '      showCards: newShowCards\r\n'
            '    });\r\n'
            '  }接下来, 我们要对wxml布局文件进行相应的修改:<view wx:for="{{showCards}}"\r\n'
            '        wx:key="{{index}}">\r\n'
            '\r\n'
            '    <view wx:if="{{item.type === \'empty-card\'}}"\r\n'
            '          class="card empty-card"\r\n'
            '          style="height: {{item.height}}px">\r\n'
            '    </view>\r\n'
            '\r\n'
            '    <self-define-component  wx:if="{{item.type !== '
            '\'empty-card\'}}"\r\n'
            '                data-card-data="{{item}}"\r\n'
            '                class="card read-card">\r\n'
            '    </self-define-component>\r\n'
            '    \r\n'
            '  </view>这样, 我们就解决了 DOM节点数目过多的问题. 并且最大限度的不影响用户的体验. '
            '(虽然用户快速上下滑动时还是会看到一些空白, 但大多数情况用户不会非常快速的上下滑, 而是阅读内容并慢速滑动)2. '
            '图片节点过多通过上面一步的优化, 我们其实已经大幅减少了页面加载的图片数目. 但是有些情况, '
            '我们的列表中的每一个卡片并不是只有一张图, 有时我们的图片组件是一个\xa0swiper\xa0. '
            '我们假设每个swiper平均展示10张图片, 那么我们展示5张card的话,\xa0<Image/>\xa0节点就有\xa0'
            '50\xa0个. 对于一些低端的安卓机, 这样的开销依然会造成卡顿.那有什么好的优化方案呢? 前面一个问题, '
            '我们的优化思路是在用户看不见的地方, 将节点简化展示.同样的, 对于swiper控件, 用户能看到的也就是\xa0当前图片\xa0'
            '以及\xa0滑动可见的左右两张图片\xa0. 其余位置的图片是可以简化展示的. 从下图可以看到, 其实需要立即加载的图片只有三张. '
            '(红色的框代表的是swiper组件的可视区域)我们使用一个变量记录当前swiper控件展示图片的坐标:\xa0'
            'curIndex\xa0, 然后我们改造一下 wxml布局文件. 代码逻辑很简单, 就是通过判断当前Image '
            '节点的index和swiper展示节点的 index之间距离, 大于2就不显示.经过这样的处理后, 我们的每个swiper组件, '
            '最多只会有三个占用实际内存的\xa0<Image/>\xa0节点.<swiper-item '
            'wx:for="{{images}}"\r\n'
            '                   wx:key="{{index}}">\r\n'
            '\r\n'
            '        <view >\r\n'
            '          <image class="img"\r\n'
            '                 mode="widthFix"\r\n'
            '                 src="{{index - curIndex < 2 && index - curIndex '
            '> -2 ? item.url : \'\'}}">\r\n'
            '          </image>\r\n'
            '        </view>\r\n'
            '      </swiper-item>最后以上就是我在这次性能优化中用到的一些小技巧, 希望能为你带来一些帮助 '
            ':)如果你对我的文章感兴趣, 这里有我的一些\xa0数据可视化\xa0，\xa0D3.js\xa0方面的文章， 欢迎 fork '
            '&& star：https://github.com/ssthouse/s...',
 'pub_time': '2019-5-29 00:32',
 'title': '小程序 多图列表 性能优化 '}
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5203-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-5209-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=7)
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5208-1.html>
{'author': 'Rolan',
 'content': '背景\r\n'
            '在最开始准备制作小程序的时候，为了求开发的快速，所使用了直接page的引入方式，每次小程序加载都是全包下载。3月份之前小程序页面稳定在35个，下载耗时在1800ms左右，4月份初上线了新业务页面膨胀到52个页面时，下载耗时基本稳定在2300ms左右，随着用户反馈越来越多，所以开始准备小程序采用分包加载，来解决这个问题。5月份在分包加载之后，页面依旧稳定在52个，但是下载耗时稳定800ms左右，缩短了将近1500ms。基本做到了0业务入侵、加入npm '
            'script 来实现新建页面，同时兼容分包加载，page加载。\r\n'
            '操作流程\r\n'
            '执行命令\r\n'
            'npm run new\r\n'
            '复制代码给出信息提示，并且要求输入路径\r\n'
            '[Info] 帮助你快速创建page文件\r\n'
            '[Info] 只局限于新目录创建\r\n'
            '[Info] 请输入文件路径，已帮你省略pages/\r\n'
            '[Info] 例子：address/addressList\r\n'
            '? 请输入文件路径：\r\n'
            '复制代码输入路径之后创建文件的提示\r\n'
            '[Info] 已创建base64.js\r\n'
            '[Info] 已创建index.js\r\n'
            '[Info] 已创建index.json\r\n'
            '[Info] 已创建index.wxml\r\n'
            '[Info] 已创建index.wxss\r\n'
            '[Info] 创建完成！！！！\r\n'
            '复制代码选择包，是主包、还是分包，并且提示，给出提示，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n'
            '? 你想生成什么样的包： (Use arrow keys)\r\n'
            '❯ 主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n'
            '  分包，在subpackages中写入\r\n'
            '复制代码单选完成之后提示新建成功\r\n'
            '[Info] 写入成功\r\n'
            '复制代码第一次分包\r\n'
            '首先我们对未分包和分包的app.json代码进行对比\r\n'
            '// 未分包\r\n'
            '"pages": [\r\n'
            '  "pages/a/index",\r\n'
            '  "pages/b/index",\r\n'
            '  "pages/b/list",\r\n'
            ']\r\n'
            '复制代码// 实现分包\r\n'
            '"subpackages": [\r\n'
            '  {\r\n'
            '    "root": "pages/a",\r\n'
            '    "pages": [\r\n'
            '      "index",\r\n'
            '    ]\r\n'
            '  },\r\n'
            '  {\r\n'
            '    "root": "pages/b",\r\n'
            '    "pages": [\r\n'
            '      "index",\r\n'
            '      "list"\r\n'
            '    ]\r\n'
            '  }\r\n'
            ']\r\n'
            '复制代码接下来看目录结构\r\n'
            'pages\r\n'
            '  |---- a\r\n'
            '        |---- index.js\r\n'
            '  |---- b\r\n'
            '        |---- index.js\r\n'
            '        |---- list.js\r\n'
            'app.json\r\n'
            "复制代码简单分一下，第一次分包的核心业务是，将pages这个普通列表，变成名为subpackages的二叉树结构，左子节点是root，右子节点是pages，并且右子节点是string类型，左子节点是array类型。好吧，我可以定下规则，首先我可以将pages/a/index这个字符串变为数组以/为分界的['pages','a','index']数组，然后我将前两项作为root节点的参数，用slice操作截取出来，转为字符串类型，赋值给root。之后的所有参数，我都赋值或者push给pages参数，最后我就得到了这样一个符合要求的树，最后push进subpackages即可。至于数据源，我只需要读出app.json这个文件的pages参数，并且通过我的方法写入subpackages参数即可。\r\n"
            '要点\r\n'
            '\r\n'
            '去重，因为subpackages内，root节点是唯一的，但是在pages里面可能我会截取初重复的值\r\n'
            '\r\n'
            '解决\r\n'
            '\r\n'
            '使用Map结构，把截取出的root值作为key，剩下的作为value，Map数据这种数据结构的特点就是key值唯一。\r\n'
            '\r\n'
            'let list = [\r\n'
            '  "pages/a/index",\r\n'
            '  "pages/a/list",\r\n'
            '  "pages/a/detail/index",\r\n'
            '  "pages/c/list",\r\n'
            '  "pages/b/index",\r\n'
            '];\r\n'
            '\r\n'
            'let m = new Map();\r\n'
            'let packages = [];\r\n'
            'list.forEach(v=>{\r\n'
            "  let arr = v.split('/');\r\n"
            "  let root = arr.splice(0,2).join('/');\r\n"
            "  let pages = arr.join('/');\r\n"
            '\r\n'
            '  if(m.get(root)){\r\n'
            '    let s = m.get(root);\r\n'
            '    m.set(root,[...s, pages]);\r\n'
            '  }else{\r\n'
            '    m.set(root,[pages]);\r\n'
            '  };\r\n'
            '});\r\n'
            'for(let [key,value] of m){\r\n'
            '  packages.push({\r\n'
            '    root: key,\r\n'
            '    pages: value,\r\n'
            '  })\r\n'
            '}\r\n'
            '\r\n'
            'console.log(packages);\r\n'
            '复制代码// log 出的结构\r\n'
            '[\r\n'
            "  { root: 'pages/a', pages: [ 'index', 'list', 'detail/index' ] "
            '},\r\n'
            "  { root: 'pages/c', pages: [ 'list' ] },\r\n"
            "  { root: 'pages/b', pages: [ 'index' ] }\r\n"
            ']\r\n'
            '复制代码我已经在不入侵业务的情况下实现了小程序的第一次分包，节约了我手动去改的劳动力，我个人认为，解决问题，上策用数据结构，中策写兼容代码，下策手动去改。至于，读出写入文件，我就不赘述了，google即可。\r\n'
            '创建新pages的指令编写\r\n'
            '好吧，我实现了第一次的分包。然后我要思考，如果我每次要加页面的话，是不是就要去查看subpackages，找到对应的root，并且添加pages。这么重复劳动力的操作，我为什么不用脚本替代呢，是吧。\r\n'
            '核心需求\r\n'
            '\r\n'
            '编写交互式的命令输入\r\n'
            '检测输入的page目录是否存在，存在就报错\r\n'
            '不存在创建page目录，复制template到新建的page中\r\n'
            '根据使用者的单选，选择写入pages，或者写入subpackages\r\n'
            '在page文件加中设置预留文件夹，用做初级业务拆分，不加入subpackages检测\r\n'
            '屏蔽app.json中pages的文件，不加入subpackages检测\r\n'
            '\r\n'
            '设计npm script\r\n'
            '{\r\n'
            '  "subcontract": "node ./config/subcontract",\r\n'
            '  "new": "node ./config/new"\r\n'
            '}  \r\n'
            '复制代码添加的package.json参数，ignore-files表示文件夹中不检测的文件，pages表式app.json中的文件\r\n'
            '{\r\n'
            '  "ignore-files": [\r\n'
            '    "**/common/**",\r\n'
            '    "**/component/**",\r\n'
            '    "**/<name>/**",\r\n'
            '    "**/<name>/**",\r\n'
            '    "**/<name>/**",\r\n'
            '  ],\r\n'
            '  "pages": [\r\n'
            '    "pages/<name>/index",\r\n'
            '    "pages/<name>/index",\r\n'
            '    "pages/<name>/index",\r\n'
            '  ]\r\n'
            '}\r\n'
            '复制代码需求已经明确，我就要去找我需要用到的npm包了\r\n'
            'colors        命令行颜色\r\n'
            'inquirer      交互式命令行\r\n'
            'glob          全局搜索文件\r\n'
            'fs-extra      文件写入写出\r\n'
            'path          路径\r\n'
            'shelljs       执行shell命令\r\n'
            '复制代码分析new.js文件\r\n'
            "const colors = require('colors');\r\n"
            "const inquirer = require('inquirer');\r\n"
            "const glob = require('glob');\r\n"
            "const fs = require('fs-extra');\r\n"
            "const path = require('path');\r\n"
            "const shell = require('shelljs');\r\n"
            "const PKG = require('../package.json');\r\n"
            "const ROOT = path.resolve(__dirname, '../');\r\n"
            '\r\n'
            "let appJson = require('../app.json');\r\n"
            'const promps = [{\r\n'
            "  type: 'input',\r\n"
            "  name: 'pagePath',\r\n"
            "  message: '请输入文件路径：',\r\n"
            '},\r\n'
            '{\r\n'
            "  type: 'list',\r\n"
            "  name: 'type',\r\n"
            "  message: '你想生成什么样的包：',\r\n"
            '  choices: [\r\n'
            '    {\r\n'
            '      name: '
            "'主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar',\r\n"
            "      value: '1',\r\n"
            '    },\r\n'
            '    {\r\n'
            "      name: '分包，在subpackages中写入',\r\n"
            "      value: '2',\r\n"
            '    },\r\n'
            '  ],\r\n'
            '}];\r\n'
            'const logger = {\r\n'
            '  info(msg) {\r\n'
            '    console.log(`[Info] ${colors.green(msg)}`);\r\n'
            '  },\r\n'
            '  warn(msg) {\r\n'
            '    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n'
            '  },\r\n'
            '  error(msg) {\r\n'
            '    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n'
            '  },\r\n'
            '};\r\n'
            '\r\n'
            "logger.info('帮助你快速创建page文件');\r\n"
            "logger.info('只局限于新目录创建');\r\n"
            "logger.info('请输入文件路径，已帮你省略pages/');\r\n"
            "logger.info('例子：xxxxx/xxxx');\r\n"
            '复制代码这是代码中的常量部分和默认提示部分，我写了logeer对象来作为提示输出的默认颜色，promps作为我交互命令行的基础配置。引入package.json我的主要目的是因为我屏蔽了一些文件ignore-files和pages，想这两个参数的文件夹我是不会被检测的，不会被加入到subpackages的。\r\n'
            'function checkFile(name) {\r\n'
            '  const options = {\r\n'
            '    ignore: [\r\n'
            "      '**/*.js',\r\n"
            "      '**/*.wxss',\r\n"
            "      '**/*.wxml',\r\n"
            "      '**/*.json',\r\n"
            '    ],\r\n'
            "    cwd: 'pages/',\r\n"
            '  };\r\n'
            "  const files = glob.sync('**', options);\r\n"
            '  if (files.some((v) => v === name)) {\r\n'
            "    logger.error('输入的目录已经存在，已终止！！！！');\r\n"
            '    return false;\r\n'
            '  };\r\n'
            '  return name;\r\n'
            '};\r\n'
            '复制代码在这是检测文件是否存在的方法，只需要传入路径，即可检测这个路径是否在pages/目录中存在。\r\n'
            'function buildFile(name) {\r\n'
            '  const options = {\r\n'
            "    cwd: 'template/page',\r\n"
            '  };\r\n'
            '  const files = glob.sync(`**`, options);\r\n'
            '\r\n'
            '  files.forEach((v)=>{\r\n'
            "    const file = v.split('.tp')[0];\r\n"
            '    fs.copy(`${ROOT}/template/page/${v}`, '
            '`${ROOT}/pages/${name}/${file}`, (err) => {\r\n'
            '      if (err) {\r\n'
            '        console.error(err);\r\n'
            '        return false;\r\n'
            '      }\r\n'
            '    });\r\n'
            '    logger.info(`已创建${file}`);\r\n'
            '  });\r\n'
            "  logger.info('创建完成！！！！');\r\n"
            '  return true;\r\n'
            '};\r\n'
            '复制代码这是复制文件夹并且复制模版文件的方法，我准备了tempalte这个文件夹，用来存储我写的模版文件，创建完成之后，我直接复制进去即可。为了和普通文件区别，我添加的.tp后缀。我的模版是可扩展的，我可以把request、app({...})在其中写好，并且添加我个人的一些方法。\r\n'
            'function subcontract(res) {\r\n'
            '  inquirer.prompt(promps[1]).then((answers)=>{\r\n'
            "    if (answers.type === '1') {\r\n"
            "      PKG['ignore-files'].push(`${res}/**`);\r\n"
            "      PKG['pages'].push(`${res}/index`);\r\n"
            "      appJson['pages'].push(`pages/${res}/index`);\r\n"
            '      fs.writeFileSync(`${ROOT}/app.json`, '
            'JSON.stringify(appJson, null, 2));\r\n'
            '      fs.writeFileSync(`${ROOT}/package.json`, '
            'JSON.stringify(PKG, null, 2));\r\n'
            "      logger.info('写入成功');\r\n"
            '    };\r\n'
            "    if (answers.type === '2') shell.exec('npm run "
            "subcontract');\r\n"
            '  });\r\n'
            '};\r\n'
            '复制代码这是选择pages还是subcontract的方法，选择了subcontract，我直接执行我上面写的小程序分包方法subcontract.js即可。如果选择pages，我会将它加入package.json中的pages对象，这个对象表式这些文件名不被subcontract脚本检测。\r\n'
            'async function inquirers() {\r\n'
            '  const {pagePath} = await inquirer.prompt(promps[0]);\r\n'
            "  const path = pagePath.replace(/\\s+/g, '');\r\n"
            '\r\n'
            '  if (!path) {\r\n'
            "    logger.error('输入有失误，已终止！！！！');\r\n"
            '    return false;\r\n'
            '  };\r\n'
            '  if (/.*[\\u4e00-\\u9fa5]+.*$/.test(path)) {\r\n'
            "    logger.error('请不要输入中文符号，已终止！！！！');\r\n"
            '    return false;\r\n'
            '  };\r\n'
            '\r\n'
            '  return path;\r\n'
            '};\r\n'
            '复制代码检测输入值是否合法，是否有中文，并且去除空格\r\n'
            '( async function() {\r\n'
            '  const inquirerRes = await inquirers();\r\n'
            '  const checkFileRes = inquirerRes && checkFile(inquirerRes);\r\n'
            '  const buildFileRes = checkFileRes && '
            'buildFile(checkFileRes);\r\n'
            '  buildFileRes && subcontract(checkFileRes);\r\n'
            '})();\r\n'
            '复制代码最后组装，inquirerRes变量负责判断输入值是否正确。然后进入checkFile，来检测文件夹是否重复。调用buildFile方法，创建文件夹，复制模版文件。最后调用subcontract来判断是分包还是主包。\r\n'
            'subcontract.js 分析\r\n'
            "const glob = require('glob');\r\n"
            "const fs = require('fs');\r\n"
            "const path = require('path');\r\n"
            "const colors = require('colors');\r\n"
            "const ROOT = path.resolve(__dirname, '../');\r\n"
            "const PAG = require('../package.json');\r\n"
            "let appJson = require('../app.json');\r\n"
            '\r\n'
            "const ignoreFiles = PAG['ignore-files'];\r\n"
            "const pages = PAG['pages'];\r\n"
            'const logger = {\r\n'
            '  info(msg) {\r\n'
            '    console.log(`[Info] ${colors.green(msg)}`);\r\n'
            '  },\r\n'
            '  warn(msg) {\r\n'
            '    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n'
            '  },\r\n'
            '  error(msg) {\r\n'
            '    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n'
            '  },\r\n'
            '};\r\n'
            '\r\n'
            'const subcontract = () => {\r\n'
            '  const options = {\r\n'
            '    ignore: ignoreFiles,\r\n'
            "    cwd: 'pages/',\r\n"
            '  };\r\n'
            "  const files = glob.sync('**/index.js', options);\r\n"
            '\r\n'
            '  let subcontractMap = new Map();\r\n'
            '  files.forEach((v)=>{\r\n'
            "    let arr = v.split('.')[0].split('/');\r\n"
            '    let root = arr.shift();\r\n'
            "    let page = arr.join('/');\r\n"
            '\r\n'
            '    if (subcontractMap.has(root)) {\r\n'
            '      let pages = subcontractMap.get(root);\r\n'
            '      pages.push(page);\r\n'
            '      subcontractMap.set(root, pages);\r\n'
            '    } else {\r\n'
            '      subcontractMap.set(root, [page]);\r\n'
            '    }\r\n'
            '  });\r\n'
            '\r\n'
            '  let subcontractList = [];\r\n'
            '  subcontractMap.forEach((v, k)=>{\r\n'
            '    subcontractList.push({\r\n'
            '      root: `pages/${k}`,\r\n'
            '      pages: v,\r\n'
            '    });\r\n'
            '  });\r\n'
            '\r\n'
            '  return subcontractList;\r\n'
            '};\r\n'
            '\r\n'
            'appJson.subpackages = subcontract();\r\n'
            'appJson.pages = pages;\r\n'
            'fs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, '
            'null, 2));\r\n'
            "logger.info('写入成功');\r\n"
            '复制代码这个方法其实和小程序第一次分包的方法大同小异。只不过我修改了数据源的获取，第一次我是读取app.json的pages，这里我是根据目录来的，以及加入了ignoreFiles来做文件屏蔽。以及一些友好提示。\r\n'
            '结尾\r\n'
            '项目优化的道路还有很长这只是最最初步的方案。为什么我开始不直接选择分包呢？因为项目开始的时候还没有分包，而且如果有，我感觉分包机制的这种书写方式，可能会带给开发者出错的可能性，我为了将项目工期缩短，出错可能性降低，我也不会选择一开始就分包。当业务增长到一定量，以及业务逐渐趋向于稳定时候，我就可以根据业务的特性，去做相对应的事情。这种方式我称之为技术迭代。在特定的时候，选择特定的解决方案，坚决不过度设计。',
 'pub_time': '2019-5-29 00:47',
 'title': '如何将老项目的小程序快速改为分包模式 '}
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-40-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=234)
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5209-1.html>
{'author': 'Rolan',
 'content': '这个 Demo '
            '是去年刚接触小程序没多久写的，直接扔在文件夹角落里有点可惜，就拿出来分享给刚入门的同学参考。源代码没有写备注，函数名就是备注，看函数名应该能猜到我是写什么端的。\r\n'
            '文中动画都是 Canvas 绘制的，这里就不贴代码了，直接看效果图，有感兴趣的想看实现的点击这里看源码。\r\n'
            '1. 绘制贝塞尔曲线\r\n'
            '\r\n'
            '2. 自定义路径动画\r\n'
            '\r\n'
            '3. 自定义动画速度曲线\r\n'
            '3.1 淡入淡出\r\n'
            '\r\n'
            '3.2 淡出\r\n'
            '\r\n'
            '3.3 弹簧',
 'pub_time': '2019-5-29 00:55',
 'title': 'Canvas 实现小程序动画 '}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-5203-1.html>
{'author': 'Rolan',
 'content': 'Trello是一款团队管理工具。本文介绍的是使用微信小程序做一个积分排名的项目，从微信小程序端去调用Trello的接口、获取掘金上面的文章,按照特定的规则去积分。项目开始之前需要做一些准备工作：注册 '
            'Trello 账号-->注册为开发者 -->获取 trello 开发者的key -->生成 token。然后进入Trello '
            'API 文档获取需要的接口。成为微信小程序开发者，具体步骤请参考\xa0'
            'developers.weixin.qq.com/miniprogram…获取genetalks_大数据里面的所有文章。提示：使用微信开发者工具发请求前先把：微信开发者工具（右上角） '
            '--> 详情 --> 不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书 (✔ '
            '上)本次项目所做的小程序，微信扫码进入积分规则如下练习题在 Trello 里面,获取对应的 board（Trello 中的看板 '
            '）里面有 list(board 里面的任务列表) 里面有 card（对应任务、题目）。按照一定的约定在对应的 board '
            '里面去创建 list --> card，完成了对应的任务才能去归档，然后获得对应的 board 里面归档的 card '
            '对应参与排名者应该获得的积分。只有博客在掘金里面，因此需要获取掘金里面的文章，但是掘金平台方面没有提供 api '
            '接口，那么就只有自己去获取对应的 html '
            '页面，然后做字符串截取了。实现因为页面比较简单，页面也少。下面说说Promise处理异步的问题。二、微信小程序端不引入第三方 js '
            '脚本的情况下处理异步问题。本人所知的处理 js '
            '异步问题的方法：使用回调。缺点：代码逻辑变的复杂，回调层次根据你访问接口的次数越来越深。使用 async '
            'await,但是不引入第三方 js 脚本，就不能使用。Promise，下面会讲解怎样使用 '
            'Promise，不再需要回调，代码可读性提高。微信小程序发送请求。例：统计积分需要获取 Trello '
            '的接口、掘金的文章，拿到数据后进行其他操作，使用回调let sort = () => {}; // '
            'sort函数做逻辑处理，排序操作\r\n'
            'const get_data = () => {\r\n'
            '  const _this = this;\r\n'
            '  const get_board = (callback) => {\r\n'
            '    wx.request({\r\n'
            "      url: 'https://*****',\r\n"
            '      success: resp => {\r\n'
            '        // 拿到resp\r\n'
            '        // 使用回调\r\n'
            '        // 如果需要把resp传入过去，然后做逻辑处理\r\n'
            '        // 回调里面使用了回调，把sort '
            '当成参数传入、也可以不传入,直接在callback,里面调用。如果都正常返回的话此处调用了一次sort函数\r\n'
            '        resp.data.forEach((item, index) => {\r\n'
            '          callback(item, index === resp.data.length - 1 && '
            'sort);\r\n'
            '        })\r\n'
            '      }\r\n'
            '    });\r\n'
            '  };\r\n'
            '  const get_cards = (data, callback) => {\r\n'
            '    wx.request({\r\n'
            '      url: data.url,\r\n'
            '      success: () => {\r\n'
            '        // 业务逻辑处理\r\n'
            '        // ................\r\n'
            '        callback && callback();\r\n'
            '      }\r\n'
            '    })\r\n'
            '  }\r\n'
            '  const get_blogs = (callback) => {\r\n'
            '    wx.request({\r\n'
            "      url: 'https//****',\r\n"
            '      success: resp => {\r\n'
            '        // 同上。。。。。\r\n'
            '      }\r\n'
            '    })\r\n'
            '  }\r\n'
            '  get_board(get_cards); // 获取board里面的cards \r\n'
            '  get_blogs(get_blog_detail) // 获取博客的内容\r\n'
            '  // 然后调用get_board '
            '、get_blogs，这样的话虽然也能做最后的逻辑处理，但是sort函数被执行了2次，并且还容易因为数据请求出错，而发生统计错误。\r\n'
            '};\r\n'
            '复制代码使用Promise// 获取board下归档的card\r\n'
            'const get_cards = (data) => {\r\n'
            '  const get_value = new Promise(resolve, reject) => {\r\n'
            '    wx.request({\r\n'
            '      url: data.url,\r\n'
            '      success: (resp) => resolve(resp),\r\n'
            '      fail: (err) => reject(err)\r\n'
            '    })\r\n'
            '  }\r\n'
            '  // 返回一个Promise，拥有card接口返回值。\r\n'
            '  return get_value;\r\n'
            '}\r\n'
            'const get_board = () => {\r\n'
            '  // 获取所有的board\r\n'
            '  const get_value = new Promise(resolve, reject) => {\r\n'
            '    wx.request({\r\n'
            '      url,\r\n'
            '      success: (resp) => resolve(resp)\r\n'
            '    })\r\n'
            '  }\r\n'
            '  let promise_arr;\r\n'
            '  // 此时的get_value拥有board接口返回的值\r\n'
            '  return get_value.then(resp => {\r\n'
            '    // 遍历需要参与积分的board\r\n'
            '    resp.data.forEach(item => {\r\n'
            '      // 把每个card接口返回的Promise 存储到promise_arr数组里\r\n'
            '      promise_arr.push(get_cards(item));\r\n'
            '    })\r\n'
            '    // Promise.all函数接收一个Promise数组\r\n'
            '    // 使用Promise.all '
            '等所有获取card的接口都执行完了会返回一个数组，数组的每一项对应board下面card的返回值\r\n'
            '    return Promise.all(promise_arr)\r\n'
            '  })\r\n'
            '  // 博客的获取方式与上面获取card的方式一样  \r\n'
            '}\r\n'
            '  // '
            '在写一个Promise.all()等待获取掘金博客的数据与获取Trello的数据都获取到了就可以执行最后的数据汇总及排序。调用sor()\r\n'
            '  const get_data = () => {\r\n'
            '    return Promise.all([get_board(), get_card()]).then(resp => '
            'return sort(resp));\r\n'
            '  }\r\n'
            '复制代码微信小程序上线问题微信小程序只能获取https的API因为开发时选用的是不校验合法域名、web-view（业务域名）、TLS '
            '版本以及 HTTPS 证书，所以当你上传了代码，使用体验版本时，会发现所有的接口都获取不到数据，这时你需要去微信小程序后台管理页面 '
            '开发 --> 开发设置 --> '
            '服务器域名：把域名填配置在这里。如果提示你域名未备案，可以做域名转发，自己不会的话可以请教后台的大哥帮忙。欧克，总结完毕！！！作者信息：宁文飞，人和未来大数据前端工程师',
 'pub_time': '2019-5-28 00:24',
 'title': '微信小程序统计Trello、掘金积分程序，Promise做异步处理 '}
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-109-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=230)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-41-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=234)
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-40-1.html>
{'author': '天下雪',
 'content': '部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 配置云存储 Redis6. '
            '配置云数据库 MongoDB7. 启动一笔到底示例 Node 服务实现会话层实现源代码微信小程序示例 - '
            '一笔到底微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 '
            'API，在这个平台上面的想象空间很大。微信的定位并不是 HTML5，这里很多人都有误解。在一些实现上，并不能想当然地用 HTML5 '
            '的思路来思考。比如，微信的请求接口\xa0wx.request并不支持\xa0cookie\xa0传递，所以会话层不能使用传统的 '
            'Session '
            '方式。这篇文章分享一个简单的画图应用，使用自己新鲜出炉的小程序会话管理能力来判断并当前用户的身份。小程序非常简单，使用 '
            'Canvas 绘图后，把序列化的\xa0actions\xa0'
            '提交给服务器保存。下次加载的时候，再列出用户曾经绘制过的图。部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. '
            '准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP '
            '中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS '
            '协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. '
            '云主机和镜像部署一笔到底的服务器运行代码和配置已经打包成腾讯云 CVM '
            '镜像，大家可以直接使用。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. '
            '配置 HTTPS镜像中已经部署了 nginx，需要在\xa0/etc/nginx/conf.d\xa0'
            '下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. '
            '域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS '
            '服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 '
            'CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 配置云存储 Redis会话管理依赖 Redis '
            '进行作为缓存管理，开发者可以选择自行搭建 Redis 服务或者直接购买云存储 Redis 服务。6. 配置云数据库 '
            'MongoDB一笔到底小程序使用 MongoDB 来存储用户绘制的图像路径，要运行小程序开发者需要自行搭建 MongoDB '
            '服务或者直接购买云数据库 MongoDB。7. 启动一笔到底示例 Node 服务在镜像的 nginx '
            '配置中（/etc/nginx/conf.d），已经把/applet/session的请求转发到\xa0'
            'http://127.0.0.1:5757处理。我们需要把 Node 服务运行起来。Node '
            '代码部署在目录/data/release/qcloud-applet-session下。进入该目录：cd '
            '/data/release/qcloud-applet-session在该目录下有个名为config.js的配置文件（如下所示），根据注释将appId、appSecret、redisConfig、mongoConfig修改成自己的配置。module.exports '
            "= {    port: '5757',    ROUTE_BASE_PATH: '/applet',    // 微信小程序 "
            "App ID    appId: '',    // 微信小程序 App Secret    appSecret: '',    "
            '// Redis 配置    // @see '
            'https://www.npmjs.com/package/redis#options-object-properties    '
            "redisConfig: {        host: '',        port: '',        password: "
            "'',    },    // MongoDB 配置    // @see "
            'https://www.qcloud.com/doc/product/240/3979    mongoConfig: '
            "{        username: '',        password: '',        host: "
            "'',        port: '',        query: "
            "'?authMechanism=MONGODB-CR&authSource=admin',        database: "
            "'qcloud-applet-session',    },};一笔到底示例使用 pm2 管理 Node 进程，执行以下命令启动 "
            'node 服务：pm2 start '
            'process.json实现会话层实现会话层实现包含两个部分：服务器端：https://github.com/CFETeam/weapp-session客户端：https://github.com/CFETeam/weapp-session-client我们的 '
            'Demo 直接使用这两个仓库，可以快速地拥有会话层的能力。会话层的实现和传统 Cookie 的实现方式类似，都是在 Header '
            '上使用特殊的字段跟踪。一个请求的完整流程如下：客户端（微信小程序）发起请求\xa0'
            'requestweapp-session-client\xa0包装\xa0request首次请求调用\xa0'
            'wx.login()\xa0和\xa0wx.getUserInfo()\xa0接口获得\xa0code、rawData\xa0'
            '和\xa0signaturerequset\xa0的头部带上\xa0code、rawData\xa0和\xa0'
            'signature保存\xa0code\xa0供下次调用非首次请求request\xa0的头部带上保存的\xa0'
            'code服务器收到请求\xa0request，中间件从头部提取\xa0code、rawData\xa0和\xa0'
            'signature\xa0字段如果\xa0code\xa0为空，跳到第\xa04\xa0步如果\xa0code\xa0'
            '不为空，且\xa0rawData\xa0不为空，需要进行签名校验使用\xa0code，appid、app_secret\xa0'
            '请求微信接口获得\xa0session_key\xa0和\xa0openid如果接口失败，响应\xa0'
            'ERR_SESSION_KEY_EXCHANGE_FAILED使用签名算法通过\xa0rawData\xa0和\xa0'
            'session_key\xa0计算签名\xa0signature2对比\xa0signature\xa0和\xa0'
            'signature2签名一致，解析\xa0rawData\xa0为\xa0wxUserInfo把\xa0openid\xa0'
            '写入到\xa0wxUserInfo把\xa0(code, wxUserInfo)\xa0缓存到 Redis把\xa0'
            'wxUserInfo\xa0存放在\xa0request.$wxUserInfo\xa0里跳到第\xa04\xa0'
            '步签名不一致，响应\xa0ERR_UNTRUSTED_RAW_DATA如果\xa0code\xa0不为空，但\xa0'
            'rawData\xa0为空，从 Redis 根据\xa0code\xa0查询缓存的用户信息找到用户信息，存放在\xa0'
            'request.$wxUserInfo\xa0字段里，跳到第\xa04\xa0步没找到用户信息（可能是过期），响应\xa0'
            'ERR_SESSION_EXPIREDrequest\xa0被业务处理，可以使用\xa0'
            'request.$wxUserInfo\xa0来获取用户信息（request.$wxUserInfo\xa0'
            '可能为空，业务需要自行处理）源代码可从 Github 获取\xa0'
            'https://github.com/CFETeam/weapp-session',
 'pub_time': '2016-10-15 17:07',
 'title': '微信小程序云端解决方案教程三：会话管理场景 '}
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-42-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=234)
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-109-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-41-1.html>
{'author': '天下雪',
 'content': '部署和运行整体架构1. 准备域名和证书2. Nginx 和 Node 代码部署3. 配置 HTTPS4. 域名解析5. 开通 '
            '点播服务6. 准备 云数据库MySQL7. 启动新片预告示例 Node 服务8. 启动新片预告 '
            'Demo主要功能实现获取视频列表、展示评论、提交评论播放视频新片预告是结合腾讯云点播 VOD和云数据库 '
            'MySQL制作的一个微信小程序示例。在代码结构上包含如下两部分：app: '
            '新片预告应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的Node服务端代码，作为服务器和app通信，提供 '
            'CGI '
            '接口示例用于拉取云数据库上的视频列表、评论列表，将评论数据提交到云数据库新片预告主要功能如下：支持分页滚动加载视频列表点击海报跳转至详情页播放视频对视频进行评论展示视频的评论列表部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. '
            '准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP '
            '中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个 SSL '
            '证书。腾讯云提供域名注册和证书申请服务，还没有域名或者证书的可以去使用域名注册好之后，可以登录微信公众平台配置通信域名了。注意：需要将\xa0'
            'www.qcloud.la\xa0设置为上面申请的域名2. Nginx 和 Node '
            '代码部署小程序服务要运行，需要进行以下几步：部署 Nginx，Nginx 的安装和部署请大家自行搜索（注意需要把 SSL '
            '模块也编译进去）配置 Nginx 反向代理到\xa0http://127.0.0.1:9994Node 运行环境，可以安装\xa0'
            'Node V6.6.0部署\xa0server\xa0目录的代码到服务器上，如\xa0'
            '/data/release/qcloud-applet-video使用\xa0npm install\xa0安装依赖模块使用\xa0'
            'npm install pm2 -g\xa0安装 pm2上述环境配置比较麻烦，新片预告的服务器运行代码和配置已经打包成腾讯云 '
            'CVM 镜像，推荐大家直接使用。镜像部署完成之后，云主机上就有运行 WebSocket '
            '服务的基本环境、代码和配置了。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验小程序的朋友无需重复部署3. '
            '配置 HTTPS镜像中已经部署了 nginx，需要在\xa0/etc/nginx/conf.d\xa0'
            '下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx\r\n'
            '4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS '
            '服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 '
            'CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通 点播服务新片预告示例的播放资源是存储在 '
            '腾讯云点播 上的mp4文件，要使用 点播 服务，需要登录\xa0点播 '
            '管理控制台，然后在其中完成以下操作：上传视频资源，点播几乎支持所有主流的视频格式上传转码成功后获取mp4或m3u8源地址目前微信小程序video组件经测试支持mp4和m3u8格式，其中 '
            'm3u8 格式只能在手机上使用，开发者可以使用腾讯云点播控制台将视频源转码成 mp4 或 m3u8 '
            '格式，并且腾讯云点播会对播放的资源进行CDN加速。6. 准备 云数据库MySQL示例中拉取的视频和评论列表都是存储在 云数据库 '
            '上，要使用\xa0云数据库\xa0'
            '服务需要完成以下操作购买，注意购买的云数据库需要与云服务器同在一个地域分区初始化流程，本示例选用的是utf8编码点击云数据库 '
            '控制台操作栏的登录按钮，登录到phpMyAdmin创建数据库并在当前数据库中导入本示例中的SQL文件注意：导入SQL文件中包含了 '
            '点播 上传的视频列表，开发者可以基于云数据库自行开发维护一个视频发布管理系统，因为此内容跟本示例暂不相关，所以不再详述。7. '
            '启动新片预告示例 Node 服务在镜像中，新片预告示例的 Node '
            '服务代码已部署在目录/data/release/qcloud-applet-video下：进入该目录：cd '
            '/data/release/qcloud-applet-video\r\n'
            '在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 MySQL 配置：module.exports = '
            '{\r\n'
            '    // Node 监听的端口号\r\n'
            "    port: '9994',\r\n"
            "    ROUTE_BASE_PATH: '/applet',\r\n"
            '\r\n'
            "    host: '填写开通 MySQL 时分配的内网IP',\r\n"
            "    user: '填写MySQL用户名',\r\n"
            "    password: '填写MySQL密码',\r\n"
            "    database: '填写上一步中创建的MySQL数据名',\r\n"
            '};\r\n'
            '示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json\r\n'
            '8. 启动新片预告 '
            'Demo在微信开发者工具将新片预告应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开新片预告Demo开始体验。主要功能实现获取视频列表、展示评论、提交评论通过node的mysql模块连接mysql，进行查询，插入操作以下是查询评论列表的示例代码const '
            "mysql = require('mysql');\r\n"
            "const config = require('../../../config');\r\n"
            '\r\n'
            'let vid = this.req.query.vid;\r\n'
            'if (!vid) {\r\n'
            "    this.res.json({ code: -1, msg: 'failed', data: {} });\r\n"
            '    return;\r\n'
            '}\r\n'
            '\r\n'
            '//CDB Mysql配置\r\n'
            'let connection = mysql.createConnection({\r\n'
            '    host: config.host,\r\n'
            '    password: config.password,\r\n'
            '    user: config.user,\r\n'
            '    database: config.database\r\n'
            '});\r\n'
            '\r\n'
            '//开启数据库连接\r\n'
            'connection.connect((err) => {\r\n'
            '    if (err) {\r\n'
            "        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n"
            '    }\r\n'
            '});\r\n'
            '\r\n'
            '//查询列表\r\n'
            "connection.query('SELECT * from comment where vid = ? order by id "
            "desc', [vid], (err, result) => {\r\n"
            '    if (err) {\r\n'
            "        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n"
            '        return;\r\n'
            '    }\r\n'
            '\r\n'
            '    this.res.json({\r\n'
            '        code: 0,\r\n'
            "        msg: 'ok',\r\n"
            '        data: result,\r\n'
            '    });\r\n'
            '});\r\n'
            '\r\n'
            '//查询完后关闭连接\r\n'
            'connection.end();\r\n'
            '播放视频<video src="{{videoUrl}}" '
            'binderror="videoErrorCallback"></video>\r\n'
            '属性名类型说明srcString要播放视频的资源地址binderrorEventHandle当发生错误时触发error事件，event.detail '
            "= {errMsg: 'something "
            "wrong'}播放视频使用的是video标签，目前官方文档上只给出了两个参数说明，笔者测试了src支持加载mp4和m3u8格式视频，video标签的控制条暂时没办法自定义样式以及隐藏",
 'pub_time': '2016-10-15 17:12',
 'title': '微信小程序云端解决方案教程四：视频应用场景 '}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-42-1.html>
{'author': '天下雪',
 'content': '本文分为以下几个部分：小程序调试技巧小程序主要模块构成小程序模块间通信设计理念分析小程序调试技巧微信开发者工具默认禁用了右键打开调试面板功能，我们可以修改开发者工具部分代码移除该限制。找到 '
            'app.nw 项目根目录，Mac '
            '下为/Applications/wechatwebdevtools.app/Contents/Resources/app.nw使用 '
            'js-beautify 对代码批量格式化：cd '
            '/Applications/wechatwebdevtools.app/Contents/Resources/app.nw\r\n'
            'find . -type f -name \'*.js\' -not -path "./node_modules/*" -not '
            '-path "./modified_modules/*" -exec js-beautify -r -s 2 -p -f '
            "'{}' \\;\r\n"
            '注释掉文件 app/dist/app.js 44 '
            '行和app/dist/components/simulator/webviewbody.js 149 '
            '行preventDefault 调用。101100 版本还需要修改 package.json 文件，去掉 '
            '--disable-devtools。执行完以上操作就可以右键打开页面的调试面板了，需要特别注意的是，使用 view '
            '页面的面板后会导致 wxml 面板不可用，touch 事件无法响应等种种问题，请慎重使用。通过代码可以发现，在配置目录下添加 '
            'config.json 文件，然后加入{isDev:true} 可以启用开发者工具所谓的调试模式， '
            '但是我在配置后程序无法正常启动，只好暂时先放弃这种方式。小程序主要模块构成小程序自身分为两个主要部分独立运行：view 模块和 '
            'service 模块。在开发者工具中，它们独立运行于不同的 webivew tag 中。view 模块负责 UI '
            '显示，它由开发者编写的 wxml 和 wxss 转换后代码以及微信提供相关辅助模块组成。 一个 view 模块对应一个 '
            'webview 组件（也就是我们常规理解的一个页面）, 小程序支持同时多个 view 存在。view 模块通过 '
            'WeixinJSBridge 对象来跟后台通信。service 模块负责应用的后台逻辑，它由小程序的 js '
            '代码以及微信提供的相关辅助模块组成。 一个应用只有一个 service '
            '进程，它同样也是一个页面（至少在开发者工具内如此，上线后可能运行于 WeixinJSCore 之内），与 view '
            '模块不同的是，它在程序生命周期内后台运行，service 模块通过与 view 模块实现不同但接口格式一样的 '
            'WeixinJSBridge 对象跟后台通信。小程序模块间通信(开发者工具内各模块通信图)做过微信开发相关的开发者会对 '
            'WeixinJSBridge 这个对象有所了解，它就是负责 UI 与后台 进行交互的一个中间层。应用号的 '
            'WeixinJSBridge 相比与之前的微信 webview 多出 publish 和 subscribe '
            '两个公共方法来发布和订阅事件，从而进行双向通信。service 模块的 WeixinJSBridge '
            '对象在文件app/dist/weapp/appservice/asdebug.js 中定义， view 层的 '
            'WeixinJSBridge 在文件 app/dist/inject/jweixindebug.js 中定义。 '
            '尽管两者都使用一样的接口以及使用 postMessage 方法与后台通信，但是其内部所做的事情确是完全不同的， 例如 '
            'service 模块可以直接通过 prompt 方法来通过 prompt调起底层组件，而 view 层的 '
            'WeixinJSBridge 只能发送消息 (参考 '
            'H5与Native交互之JSBridge技术)。我们来看一个典型的交互流程：用户点击界面触发事件对应 view '
            '模块接收事件后将事件封装成所需格式后调用 publish '
            "方法发送:WeixinJSBridge.publish('PAGE_EVENT', data)\r\n"
            'data 参数举例：{\r\n'
            '"data": {\r\n'
            '  "eventName": "onhidetap",\r\n'
            '  "data": {\r\n'
            '    "target": {\r\n'
            '      ...\r\n'
            '    },\r\n'
            '    "currentTarget": {\r\n'
            '      ...\r\n'
            '    },\r\n'
            '    "type": "tap",\r\n'
            '    "timeStamp": 11457,\r\n'
            '    "touches": [ ...  ],\r\n'
            '    "detail": {\r\n'
            '      ...\r\n'
            '    }\r\n'
            '  }\r\n'
            '},\r\n'
            '"options": {\r\n'
            '  "timestamp": 1475445858336\r\n'
            '}\r\n'
            '}\r\n'
            '后台(开发者工具内为 nwjs 运行环境)将数据处理后发送给 service 模块，数据形如：{\r\n'
            '"to": "appservice",\r\n'
            '"msg": {\r\n'
            '  "eventName": "PAGE_EVENT",\r\n'
            '  "data": {\r\n'
            '    "data": {\r\n'
            '      "eventName": "onhidetap",\r\n'
            '      "data": {\r\n'
            '        "target": {\r\n'
            '          ...\r\n'
            '        },\r\n'
            '        "currentTarget": {\r\n'
            '          ...\r\n'
            '        },\r\n'
            '        "type": "tap",\r\n'
            '        "timeStamp": 75329,\r\n'
            '        "touches": [ ...  ],\r\n'
            '        "detail": {\r\n'
            '          ...\r\n'
            '        }\r\n'
            '      }\r\n'
            '    },\r\n'
            '    "options": {\r\n'
            '      "timestamp": 1475445858336\r\n'
            '    }\r\n'
            '  },\r\n'
            '  "webviewID": 0\r\n'
            '},\r\n'
            '"command": "MSG_FROM_WEBVIEW"\r\n'
            '}\r\n'
            'service 模块的 WeixinJSBridge 内回调函数依据传来数据找到对应 view 的 page 模块后执行 对应名为 '
            'eventName 指向的函数回调函数调用 this.setData({hidden: true}) 改变 '
            'data，serivce 层计算该页面 data 后向后台发送 send_app_data 和 appdataChange '
            '事件，具体数据格式如下：{\r\n'
            '"appData": {\r\n'
            '  "page/index": {\r\n'
            '    ...\r\n'
            '  }\r\n'
            '},\r\n'
            '"sdkName": "send_app_data",\r\n'
            '"to": "backgroundjs",\r\n'
            '"comefrom": "webframe",\r\n'
            '"command": "COMMAND_FROM_ASJS",\r\n'
            '"appid": "touristappid",\r\n'
            '"appname": "chat",\r\n'
            '"apphash": 70475629,\r\n'
            '"webviewID": 100000\r\n'
            '}\r\n'
            '{\r\n'
            '"eventName": "appDataChange",\r\n'
            '"data": {\r\n'
            '  "data": {\r\n'
            '    "data": {\r\n'
            '      "hidden": true\r\n'
            '    }\r\n'
            '  },\r\n'
            '  "options": {\r\n'
            '    "timestamp": 1475528706311\r\n'
            '  }\r\n'
            '},\r\n'
            '"sdkName": "publish",\r\n'
            '"webviewIds": [\r\n'
            '  0\r\n'
            '],\r\n'
            '"to": "backgroundjs",\r\n'
            '"comefrom": "webframe",\r\n'
            '"command": "COMMAND_FROM_ASJS",\r\n'
            '"appid": "touristappid",\r\n'
            '"appname": "chat",\r\n'
            '"apphash": 70475629,\r\n'
            '"webviewID": 100000\r\n'
            '}\r\n'
            '后台(文件 dist/components/simulator/webviewbody.js) 接收到appDataChange '
            '事件数据后再将数据进行简单封装， 最后转发给到 view 层。 具体数据格式为：{\r\n'
            '"to": "webframe",\r\n'
            '"msg": {\r\n'
            '  "eventName": "appDataChange",\r\n'
            '  "data": {\r\n'
            '    "data": {\r\n'
            '      "data": {\r\n'
            '        "hidden": true\r\n'
            '      }\r\n'
            '    },\r\n'
            '    "options": {\r\n'
            '      "timestamp": 1475528706311\r\n'
            '    }\r\n'
            '  },\r\n'
            '  "sdkName": "publish",\r\n'
            '  "webviewIds": [\r\n'
            '    0\r\n'
            '  ],\r\n'
            '  "to": "backgroundjs",\r\n'
            '  "comefrom": "webframe",\r\n'
            '  "command": "COMMAND_FROM_ASJS",\r\n'
            '  "appid": "touristappid",\r\n'
            '  "appname": "chat",\r\n'
            '  "apphash": 70475629,\r\n'
            '  "webviewID": 100000,\r\n'
            '  "act": "sendMsgFromAppService"\r\n'
            '},\r\n'
            '"command": "MSG_FROM_APPSERVICE",\r\n'
            '"webviewID": 0,\r\n'
            '"id": 0.10577065353216675\r\n'
            '}\r\n'
            'view 层的 WeixinJSBridge 接收到后台的数据，如果 webviewID 匹配则将 data 与现有页面 data '
            '合并， 然后就是 virtual dom 模块进行 diff 和 apply 操作改变 '
            'dom。小程序模块间消息传递除了界面事件和应用数据还包括触发原生方法、握手以及生命周期等类型， '
            '尽管处理对象和处理方式不同，大体流程跟上面是一样的。view 模块和 service 模块的 WeixinJSBridge '
            '都使用了 postMessage 接口 (参考MDN 文档) 与后台通信，但是由于该接口无法直接与 nwjs '
            '后台进程通信，所以开发者工具会将 app/dist/contentscript/contentScript.js '
            '文件做为contentScript 注入到 view 模块和 service 模块所在页面，contentScript.js '
            '的代码提供了 message 消息到 chrome.runtime通信接口的转换。微信开发者工具扩展了 devtools 提供了 '
            'AppData 面板，开发者可以修改里面数据然后直接看到 view 界面的变化效果。这里修改数据后 nwjs 会将消息发送给 '
            'service 层，之后发生的事就跟上面 4 5 6 步一样：service 传递消息给 nwjs，最后到 view '
            '层。设计理念分析小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， '
            '同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， '
            '另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 js 代码里面是不能直接使用浏览器提供的 DOM 和 '
            'BOM 接口的，这一方面是因为 js 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM '
            '接口，它们对应的 也是 service 模块页面，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API '
            '被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API '
            '都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。理解了以上机制，再对 view 模块和 service 模块的 '
            'WeixinJSBridge 加以改造，我们便不难做到让 小程序跑在自己的环境下，这样就可以做些手机调试以及单页面测试等操作。',
 'pub_time': '2016-10-15 17:21',
 'title': '微信小程序架构分析《一》调试技巧，模块构成，理念分析 '}
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-110-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=230)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-112-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=230)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=225> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-110-1.html>
{'author': '天下雪',
 'content': '最近突发奇想，如果微信小程序不在微信公众号里了该如何使用 自动回复呢？先看下效果话不多说 直接上代码1.页面代码：<swiper '
            'indicator-dots="{{indicatorDots}}"\xa0 \xa0 \xa0 \xa0 '
            'autoplay="{{autoplay}}" interval="{{interval}}" '
            'duration="{{duration}}">\xa0 \xa0 \xa0 <block '
            'wx:for="{{imgUrls}}">\xa0 \xa0 \xa0 \xa0 '
            '<swiper-item>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0<navigator '
            'url="{{item.link}}" '
            'hover-class="navigator-hover">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '<image src="{{item.url}}" class="slide-image" width="355" '
            'height="150"/>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            '</navigator>\xa0\xa0 \xa0 \xa0 \xa0 </swiper-item>\xa0 \xa0 \xa0 '
            '</block></swiper>\xa0<block>\xa0 \xa0 <input type="text" '
            'class="input-text" bindchange="setInputValue" \xa0'
            'placeholder="请输入你要咨询的内容"/>\xa0 \xa0 <button '
            'bindtap="getgetinputSEnd" '
            'class="input-button">发送</button></block><view '
            'class="chat-area"> \xa0 \xa0\xa0 \xa0 <view wx:for="{{msgs}}" '
            'wx:for-index="idx" wx:for-item="itemName">\xa0 \xa0 \xa0 \xa0 '
            '<view class="say-title">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <block '
            'wx:if="{{idx%2 != 0}}"><text '
            'class="red-font">客服：</text></block>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '<block wx:if="{{idx%2 == 0}}"><text '
            'class="green-font">你：</text></block>\xa0 \xa0 \xa0 \xa0 '
            '</view>\xa0 \xa0 \xa0 \xa0 <view '
            'class="say-content">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <block '
            'wx:if="{{itemName.type == '
            '\'video\'}}">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <video '
            'src="{{itemName.msg}}"></video>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '</block>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <block '
            'wx:if="{{itemName.type == '
            '\'voice\'}}">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <audio '
            'src="{{itemName.msg}}" controls '
            'loop></audio>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '</block>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <block '
            'wx:if="{{itemName.type == '
            '\'image\'}}">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <image '
            'src="{{itemName.msg}}"></image>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '</block>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <block '
            'wx:if="{{itemName.type == '
            '\'text\'}}">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '<text>{{itemName.msg}}</text>\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '</block>\xa0 \xa0 \xa0 \xa0 </view>\xa0 \xa0 </view></view>页面中 '
            '使用了 模板的\xa0条件渲染 '
            '：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1476197490824\xa0'
            '列表渲染：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html?t=14761974929812. '
            '样式代码.slide-image{\xa0 \xa0 width: 100%;}.input-text{border:1px '
            'solid '
            '#abcdef;width:88%;background:#ddd;line-height:100%;text-indent: '
            '0.5rem;margin:1rem auto;height:40px;}.input-button{ \xa0 \xa0'
            'background:#48C23D;margin:0.5rem '
            '5%;color:#fff;}.chat-area{\xa0 \xa0 width: 90%;\xa0 \xa0 '
            'margin:0.5rem 5%;\xa0 \xa0 border:1px solid #ddd;\xa0 \xa0 '
            'background:#eee;\xa0 \xa0 font-size: 1rem;}.red-font{\xa0 \xa0 '
            'color:#DC143C;}.green-font{\xa0 \xa0 '
            'color:#48C23D;}.say-content{font-size:80%;width:80%;margin:0.5rem '
            '5%;}3. js代码//test.js//获取应用实例var app = getApp();Page({\xa0 data: '
            '{\xa0 \xa0 \xa0 imgUrls: [\xa0 \xa0 \xa0 \xa0'
            '{\xa0 \xa0 \xa0 \xa0 \xa0 '
            "link:'/pages/index/index',\xa0 \xa0 \xa0 \xa0 \xa0 "
            "url:'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg'\xa0\xa0 \xa0 \xa0 \xa0"
            '},{\xa0 \xa0 \xa0 \xa0 \xa0 '
            "link:'/pages/logs/logs',\xa0 \xa0 \xa0 \xa0 \xa0 "
            "url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg'\xa0\xa0 \xa0 \xa0 \xa0"
            '},{\xa0 \xa0 \xa0 \xa0 \xa0 '
            "link:'/pages/test/test',\xa0 \xa0 \xa0 \xa0 \xa0 "
            "url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'\xa0\xa0 \xa0 \xa0 \xa0"
            '}\xa0\xa0 \xa0 ],\xa0 \xa0 indicatorDots: true,\xa0 \xa0 '
            'autoplay: true,\xa0 \xa0 interval: 5000,\xa0 \xa0 duration: '
            "1000,\xa0 \xa0 msgs:[],\xa0 \xa0 inputdata:'',\xa0 \xa0 userInfo: "
            "{}\xa0 },\xa0 onLoad: function () {\xa0 \xa0 console.log('onLoad "
            "test');\xa0 \xa0 console.log(this.data.msgs);\xa0 },\xa0 "
            'getgetinputSEnd:function(){\xa0 \xa0 \xa0 var input = '
            'this.data.inputdata;\xa0 \xa0 \xa0 var that = this;\xa0 \xa0 \xa0 '
            'var msgs = that.data.msgs;\xa0\xa0 \xa0 \xa0 '
            "msgs.push({msg:input,'type':'text'});\xa0 \xa0 \xa0 "
            '//--------------------------------- '
            '微信数据请求\xa0 \xa0 \xa0\xa0 \xa0 \xa0 '
            'wx.request({\xa0 \xa0 \xa0 \xa0 url: '
            "'http://test.com:8080/test/socket.php',\xa0 \xa0 \xa0 \xa0 data: "
            '{\xa0 \xa0 \xa0 \xa0 \xa0 msg:input\xa0 \xa0 \xa0 \xa0 '
            '},\xa0 \xa0 \xa0 \xa0 header: {\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            "'Content-Type': 'application/json'\xa0 \xa0 \xa0 \xa0 "
            '},\xa0 \xa0 \xa0 \xa0 success: function(res) '
            '{\xa0 \xa0 \xa0 \xa0 \xa0 '
            "msgs.push({msg:res.data.content,'type':res.data.msgType});\xa0 \xa0 \xa0 \xa0 \xa0 "
            'that.setData({msgs:msgs});\xa0 \xa0 \xa0 \xa0 \xa0 '
            'console.log(res.data)\xa0 \xa0 \xa0 \xa0 }\xa0 \xa0 \xa0 '
            '})\xa0 \xa0 \xa0\xa0 },\xa0 '
            'setInputValue:function(e){\xa0 \xa0 \xa0 '
            'console.log(e.detail);\xa0 \xa0 \xa0 this.data.inputdata = '
            'e.detail.value;\xa0 }})4. 服务器端代码<?php$params = $_REQUEST;$msg = '
            "$params['msg'];$content = array();switch ($msg) {\xa0 \xa0 case "
            "'1':\xa0\tcase '美女':\xa0\t\t$content['msgType'] = 'image';\xa0\t\t"
            "$content['content'] = "
            "'https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=ae4df4ec878ba61ec0eecf2f713497cc/43a7d933c895d143b233160576f082025aaf074a.jpg';\xa0\t\t"
            "break;\xa0\tcase '2':\xa0\tcase '音乐':\xa0\t\t$content['msgType'] "
            "= 'voice';\xa0\t\t$content['content'] = "
            "'http://www.w3school.com.cn/i/song.mp3';\xa0\t\tbreak;\xa0\tcase "
            "'3':\xa0\tcase '视频':\xa0\t\t$content['msgType'] = 'video';\xa0\t\t"
            "$content['content'] = "
            "'http://www.w3school.com.cn//i/movie.ogg';\xa0\t\tbreak;\t\xa0\t"
            "case '4':\xa0\tcase '笑话':\xa0\t\t$content['msgType'] = "
            "'text';\xa0\t\t$content['content'] = '一男子在闹市骑摩托撞昏了一个陌生的老汉! "
            "男子惊吓的不知所措!围观群众越来越多!突然,该男抱住老汉,声泪俱下的喊道:“爹,你等着我,我这就去给...';\xa0\t\t"
            "break;\t\t\xa0\tdefault:\xa0\t\t$content['msgType'] = "
            "'text';\xa0\t\t$content['content'] = "
            "'您发送的指令不在识别范围内：\xa0\t\t \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 "
            '你可以选择\xa0\xa0\t\t \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '1 '
            '美女\xa0\xa0\t\t \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '2 '
            '音乐\xa0\t\t \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '3 '
            '视频\xa0\t\t \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            "4 笑话 ';\xa0\t\tbreak;\xa0}\xa0\xa0echo json_encode($content);",
 'pub_time': '2016-10-20 15:10',
 'title': '微信小程序简易全攻略《四》模板条件列表渲染完成模拟公众号自动回复 ... '}
2019-07-25 14:25:00 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-112-1.html>
{'author': '天下雪',
 'content': '缘起：昨天官方开发有了更新v0.10.101100，Picker的mode属性已经支持date以及time（background-image的bug也修复），于是来更新此实例。目标：实现集成日期组件如图官方文档出处：https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html步骤，在item.wxml文件中增加一个picker组件，如下：如图从图中可以看出：1.日期后面是空白的，应该默认显示今天日期； '
            '2.点击确定也没有显示到组件上，需要实现bindDateChange方法。于是我们需要在item.js文件中，声明一个data值date与wxml中的{{date}}绑定关联然后在onLoad中初始化字符串格式的日期值，详细说明见注释：经过如上处理，日期组件已经显示为当前日期如图处理到此，我们还需要修复一个逻辑错误，即组件的结束日期应该不超过当日，做法也很简单，只需要在wxml文件中对picker的日期属性end由2017-09-01改为{{date}}即可<picker '
            'mode="date" value="{{date}}" start="{{date}}" end="2017-09-01" '
            'bindchange="bindDateChange">\r\n'
            '吐槽一下，官方的picker的还是有bug的，完全不听start与end使唤，仍可以选任意日期，暂时不去理会，代码就这么写着，什么时候开发工具修复了自然可以了，毕竟是现在还只是内测，就将就用着。接下来处理日期组件点击确认事件bindDateChange回到item.js文件声明一个bindDateChange方法，添加如下代码以写回data中的date值至此，已经实现集成日期picker组件。剩下的就是将它同之前的标题、类型、金额字段那样存在json再本地setStorage存储即可，这里不作赘述',
 'pub_time': '2016-10-21 10:26',
 'title': '秀杰实战教程系列《五》：实战课程之记账应用开发（续） '}
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-128-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-111-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=230)
2019-07-25 14:25:00 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-107-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=230)
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-111-1.html>
{'author': '天下雪',
 'content': '创建快捷项目app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 '
            'API，如本例的同步存储及同步读取本地数据。\xa0'
            'app.json是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。\xa0'
            'app.wxss是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss '
            '中声明的样式规则。App({\xa0 onLaunch: function () {\xa0 \xa0 '
            "//调用API从本地缓存中获取数据\xa0 \xa0 var logs = wx.getStorageSync('logs') "
            '|| []\xa0 \xa0 logs.unshift(Date.now())\xa0 \xa0 '
            "wx.setStorageSync('logs', logs)\xa0 },\xa0 "
            'getUserInfo:function(cb){\xa0 \xa0 var that = this\xa0 \xa0 '
            'if(this.globalData.userInfo){\xa0 \xa0 \xa0 typeof cb == '
            '"function" && cb(this.globalData.userInfo)\xa0 \xa0 '
            '}else{\xa0 \xa0 \xa0 //调用登录接口\xa0 \xa0 \xa0 '
            'wx.login({\xa0 \xa0 \xa0 \xa0 success: function () '
            '{\xa0 \xa0 \xa0 \xa0 \xa0 '
            'wx.getUserInfo({\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 success: function '
            '(res) {\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            'that.globalData.userInfo = '
            'res.userInfo\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 typeof cb == '
            '"function" && '
            'cb(that.globalData.userInfo)\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 '
            '}\xa0 \xa0 \xa0 \xa0 \xa0 })\xa0 \xa0 \xa0 \xa0 }\xa0 \xa0 \xa0 '
            '})\xa0 \xa0 }\xa0 },\xa0 globalData:{\xa0 \xa0 userInfo:null\xa0 '
            '},\xa0 onShow:function() {\xa0 \xa0 console.log("show");\xa0 '
            '},\xa0 onHide:function() {\xa0 \xa0 console.log("hide");\xa0 '
            '}})注意必须在 app.js 中注册App() ，不能注册多个。\xa0onLaunch：程序初始化执行，且只执行一次。\xa0'
            'onShow:程序启动，或从程序后台进入前台时执行。\xa0onHide:程序从前台进入后台时执行。\xa0'
            '可以添加任意函数到OBJECT中，使用this访问。底部导航\xa0添加images目录，放入图片资源并添加主程序页面\xa0'
            '添加底部导航tabBar{\xa0 "pages":[\xa0 \xa0 '
            '"pages/index/index",\xa0 \xa0 "pages/logs/logs",\xa0 \xa0 '
            '"pages/main/main"\xa0 ],\xa0 "window":{\xa0 \xa0 '
            '"backgroundTextStyle":"light",\xa0 \xa0 '
            '"navigationBarBackgroundColor": "#dddddd",\xa0 \xa0 '
            '"navigationBarTitleText": "WeChat",\xa0 \xa0 '
            '"navigationBarTextStyle":"black"\xa0 },\xa0 "tabBar":{\xa0 \xa0 '
            '"color":"#000",\xa0 \xa0 "selectedColor":"#48c33c",\xa0 \xa0 '
            '"borderStyle":"block",\xa0 \xa0 '
            '"backgroundColor":"#ffffff",\xa0 \xa0 "list":[{\xa0 \xa0 \xa0 '
            '"pagePath":"pages/index/index",\xa0 \xa0 \xa0 '
            '"iconPath":"images/footer/index.png",\xa0 \xa0 \xa0 '
            '"selectedIconPath":"images/footer/indexS.png",\xa0 \xa0 \xa0 '
            '"text":"首页"\xa0 \xa0 },\xa0 \xa0 {\xa0 \xa0 \xa0 '
            '"pagePath":"pages/logs/logs",\xa0 \xa0 \xa0 '
            '"iconPath":"images/footer/logs.png",\xa0 \xa0 \xa0 '
            '"selectedIconPath":"images/footer/logsS.png",\xa0 \xa0 \xa0 '
            '"text":"日志"\xa0 \xa0 },\xa0 \xa0 {\xa0 \xa0 \xa0 '
            '"pagePath":"pages/main/main",\xa0 \xa0 \xa0 '
            '"iconPath":"images/footer/main.png",\xa0 \xa0 \xa0 '
            '"selectedIconPath":"images/footer/mainS.png",\xa0 \xa0 \xa0 '
            '"text":"主程序"\xa0 \xa0 }\xa0 \xa0 ]\xa0 }}color：文字默认颜色\xa0'
            'selectedColor：文字选中颜色\xa0borderStyle：上边框颜色（只支持black/white）\xa0'
            'backgroundColor：背景色\xa0list：菜单列表list属性\xa0'
            'pagePath：页面路径（需要在pages中初始化）\xa0iconPath：图片路径，大小限制40kb\xa0'
            'selectedIconPath：选中样式图片路径，大小限制40kb\xa0'
            'text：按钮文字数据绑定main.jsPage({\r\n'
            '  data:{\r\n'
            '    text:"这是一个页面"\r\n'
            '  },\r\n'
            '  onLoad:function(options){\r\n'
            '    // 页面初始化 options为页面跳转所带来的参数\r\n'
            '  },\r\n'
            '  onReady:function(){\r\n'
            '    // 页面渲染完成\r\n'
            '  },\r\n'
            '  onShow:function(){\r\n'
            '    // 页面显示\r\n'
            '  },\r\n'
            '  onHide:function(){\r\n'
            '    // 页面隐藏\r\n'
            '  },\r\n'
            '  onUnload:function(){\r\n'
            '    // 页面关闭\r\n'
            '  }\r\n'
            '})12345678910111213141516171819201234567891011121314151617181920main.wxml<view>\r\n'
            '    <text>{{text}}</text>\r\n'
            '</view>123123view组件\xa0flex-direction： row：横向排列；column：纵向排列\xa0'
            'justify-content：flex-start：左对齐； '
            'flex-end：右对齐；center：居中；space-between：两端分散对齐；space-around：居中分散对齐\xa0'
            'align-items：flex-start：垂直顶部；flex-end：垂直底部；center：垂直居中轮播    '
            '<swiper indicator-dots="true" autoplay="true" duration="1000" '
            'bindchange="listenSwiper" >\r\n'
            '        <swiper-item>\r\n'
            '            <view style="background: red; height: '
            '150px"></view>\r\n'
            '        </swiper-item>\r\n'
            '        <swiper-item>\r\n'
            '            <view style="background: green; height: '
            '150px"></view>\r\n'
            '        </swiper-item>\r\n'
            '            <swiper-item>\r\n'
            '            <view style="background: blue; height: '
            '150px"></view>\r\n'
            '        </swiper-item>    \r\n'
            '    </swiper>12345678910111234567891011属性名 类型 默认值 说明\xa0'
            'indicator-dots Boolean false 是否显示面板指示点\xa0autoplay Boolean false '
            '是否自动切换\xa0current Number 0 当前所在页面的 index\xa0interval Number 5000 '
            '自动切换时间间隔\xa0duration Number 1000 滑动动画时长\xa0bindchange EventHandle '
            'current 改变时会触发 change 事件，event.detail = {current: current}\xa0'
            '注意：其中只可放置组件，其他节点会被自动删除。\xa0'
            '仅可放置在组件中，宽高自动设置为100%。获取轮播改变事件listenSwiper:function(e) {\r\n'
            '    console.log(e)\r\n'
            '},123123值Object {target: Object, currentTarget: Object, type: '
            '"change", timeStamp: 35345, detail: Object}\r\n'
            'currentTarget\r\n'
            ':\r\n'
            'Object\r\n'
            'detail\r\n'
            ':\r\n'
            'Object\r\n'
            'target\r\n'
            ':\r\n'
            'Object\r\n'
            'timeStamp\r\n'
            ':\r\n'
            '35345\r\n'
            'type\r\n'
            ':\r\n'
            '"change"\r\n'
            '__proto__\r\n'
            ':\r\n'
            'Object1234567891011121314151617181912345678910111213141516171819图标\xa0'
            'icon\xa0type 有效值：success, success_no_circle, info, warn, waiting, '
            'cancel, download, search, clear\xa0size 默认23px\xa0color '
            '同css的color<!--成功图标-->\xa0 \xa0 <icon type="success" '
            'size="40"/>\xa0 \xa0 <!--安全成功标志图标-->\xa0 \xa0 <icon '
            'type="safe_success" size="40"/>\xa0 \xa0 <!--提示信息图标-->\xa0 \xa0 '
            '<icon type="info" size="40"/>\xa0 \xa0 <!--带圆的信息提示图标-->\xa0 \xa0 '
            '<icon type="info_circle" size="40"/>\xa0 \xa0 '
            '<!--不带圆的成功图标-->\xa0 \xa0 <icon type="success_no_circle" '
            'size="40"/>\xa0 \xa0 <!--带圆的成功图标-->\xa0 \xa0 <icon '
            'type="success_circle" size="40"/>\xa0 \xa0 <!--警告图标-->\xa0 \xa0 '
            '<icon type="warn" size="40"/>\xa0 \xa0 <!--带圆的等待图标-->\xa0 \xa0 '
            '<icon type="waiting_circle" size="40"/>\xa0 \xa0 '
            '<!--等待图标-->\xa0 \xa0 <icon type="waiting" size="40"/>\xa0 \xa0 '
            '<!--下载图标-->\xa0 \xa0 <icon type="download" size="40"/>\xa0 \xa0 '
            '<!--取消图标-->\xa0 \xa0 <icon type="cancel" size="40"/>\xa0 \xa0 '
            '<!--清除图标-->\xa0 \xa0 <icon type="clear" size="40"/>\xa0 \xa0 '
            '<!--改变颜色的success-->\xa0 \xa0 <icon type="success" size="40" '
            'color="red"/>进度条\xa0percent Float 无 百分比0~100\xa0show-info Boolean '
            'false 在进度条右侧显示百分比\xa0stroke-width Number 6 进度条线的宽度，单位px\xa0color '
            'Color #09BB07 进度条颜色\xa0active Boolean false 进度条从左往右的动画<progress '
            'percent="80" show-info="true" stroke-width="5" color="red" '
            'active="true"/>按钮\xa0button\xa0 \xa0 <button type="defaule" '
            'bindtap="clickButton">Defalut</button>\xa0 \xa0 <!--原始颜色，不可点击状态， '
            '正在加载状态-->\xa0 \xa0 <button type="primary" disabled="true" '
            'loading="true">Primary</button>\xa0 \xa0 <button '
            'type="warn">warn</button>注：button-hover 默认为{background-color: '
            'rgba(0, 0, 0, 0.1); opacity: 0.7;}按钮点击事件\xa0 clickButton: '
            'function(e) {\xa0 \xa0 console.log(e);\xa0 },CHECKBOX\xa0 \xa0 '
            '<!--checkbox-group是checkbox的组，使用bindchange，监听数据选中和取消-->\xa0 \xa0 '
            '<checkbox-group '
            'bindchange="listenCheckboxChange">\xa0 \xa0 \xa0 \xa0 <label '
            'style="display: flex;" \xa0'
            'wx:for-items="{{items}}">\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 <checkbox '
            'value="{{item.name}}" '
            'checked="{{item.checked}}"/>{{item.value}}\xa0 \xa0 \xa0 \xa0 '
            '</label>\xa0 \xa0 </checkbox-group>绑定事件\xa0绑定数据items: '
            '[\xa0 \xa0 \xa0 \xa0 {\xa0 \xa0 \xa0 \xa0 \xa0 name: '
            "'S',\xa0\xa0 \xa0 \xa0 \xa0 \xa0 value: "
            "'S',\xa0\xa0 \xa0 \xa0 \xa0 \xa0 checked: "
            "'true'\xa0 \xa0 \xa0 \xa0 },\xa0 \xa0 \xa0 \xa0 "
            "{\xa0 \xa0 \xa0 \xa0 \xa0 name: 'O',\xa0\xa0 \xa0 \xa0 \xa0 \xa0 "
            "value: 'O'\xa0 \xa0 \xa0 \xa0 },\xa0 \xa0 \xa0 \xa0 "
            "{\xa0 \xa0 \xa0 \xa0 \xa0 name: 'N',\xa0\xa0 \xa0 \xa0 \xa0 \xa0 "
            "value: 'N'\xa0 \xa0 \xa0 \xa0 },\xa0 \xa0 \xa0 \xa0 "
            "{\xa0 \xa0 \xa0 \xa0 \xa0 name: 'G',\xa0\xa0 \xa0 \xa0 \xa0 \xa0 "
            "value: 'G'\xa0 \xa0 \xa0 \xa0 },\xa0 \xa0 \xa0 \xa0 "
            '{\xa0 \xa0 \xa0 \xa0 \xa0 name: '
            "'SONG',\xa0\xa0 \xa0 \xa0 \xa0 \xa0 value: "
            "'SONG'\xa0 \xa0 \xa0 \xa0 }\xa0 \xa0 ]绑定监听事件\xa0 "
            'listenCheckboxChange:function(e) {\xa0 \xa0 \xa0 '
            'console.log(e);\xa0 '
            '},至此页面源代码（Git）：https://github.com/yz-mengxiangsong/wechatDemo.git',
 'pub_time': '2016-10-20 17:47',
 'title': '微信小程序开发新手实战教程 '}
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-128-1.html>
{'author': '天下雪',
 'content': '"小程序”来了，大世界要变了？微信小程序可能是近期业绩最火的话题之一了。这个根植于微信流量巨无霸的应用，将对应用市场、对微商、电商、对企业的开发成本、获客成本将产生深远影响？将制造出绕开Google '
            'Play和AppStore的另一大App体系？将实现“知人性”的PM张小龙先生的“用后即走”的轻量App之梦？将秒杀传统的App？虽有海量追捧者趋之若鹜，但也有冷静人士淡定的白眼。但无论如何，腾讯这步棋子既然落在了棋盘上，绝不能悔棋，更不可能半途而废，你我这样神经敏感的PM、UX，不尝鲜是不可能的。说动就动，查找到微信小程序的设计规范后，让我们开始吧。造大梦的事儿还是让大佬们去干吧，咱们干点实在的。干活儿首先得挑个工具，我这里使用了Mockplus，近期国内的一款比较流行的原型设计。比较顺手，线框、交互都能胜任。首先尝试做WeUI的界面元素吧。经过一会儿的折腾，搞成了一套（好在WeUI的界面元素比不是太多）。有了这个，之后就方便了。在提示和上传页面中，我使用了交互，点击“成功提示”按钮，弹出提示。点击“上传”按钮，完成进度条的走动。操作很简单：在Mockplus中选中按钮，直接拖拽到准备弹出的提示框上，设置“显示/隐藏”，并在消失时做了延迟处理。提示框的默认显示状态，设为“不可见”。至于进度条的走动，是设置每个进度轨道的“调整尺寸”的交互（设置宽度变化），多拖拽几次鼠标，设置链接就好了，如图：好了，让我们来看看效果。点这里看我的成果：http://run.mockplus.cn/Tnr9w9TyUKjXeDeR/index.html这个尝试到此暂时结束，页面不多，算是个半成品。但在制作时，我边做边琢磨微信在设计中的一些理念：简约、准确、易用。这个伟大的产品之所以在国内能够深入人心，还是有些道理的。',
 'pub_time': '2016-10-23 11:47',
 'title': '微信小程序的原型设计尝鲜 '}
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-130-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-132-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-107-1.html>
{'author': '天下雪',
 'content': '一：设置页面标题页面写好了，总感觉哪里不爽，对，就是那，每个页面的标题都一样，都是 Wechatcou 呀 真cou, '
            '那咱就单独说说，如何设置 页面标题。设置页面标题 ，相当的简单，找到所在页面的目录，新建一个 json 文件，比如我们上一次建造的 '
            'test 页面我们 \xa0找到 pages/test/ 目录 新建一个 test.json 文件 '
            '加入如下代码{ \xa0\xa0 "navigationBarTitleText": "霸气侧漏" \xa0}\xa0view '
            'plain\xa0co效果如下：二：设置底部导航好了 小程序的头部标题 '
            '设置好了，我们来说说底部导航栏是如何实现的。我们先来看个效果图这里，我们添加了三个导航图标，因为我们有三个页面，微信小程序最多能加5个。那他们是怎么出现怎么着色的呢？两步就搞定！1. '
            '图标准备阿里图标库 \xa0'
            'http://www.iconfont.cn/collections/show/29我们进入该网站，鼠标滑到一个喜欢的图标上面 \xa0'
            '点击下方的 下载按钮在弹出框中 选择了 俩个不同颜色的 图标 \xa0选择64px大小即可，我选择的是png \xa0然后下载下来 '
            '起上别名\xa0将上述起好名字的图标 保存到 小程序 项目目录中 新创建的 images 文件夹中，准备工作就做好了2. '
            '更改配置文件我们找到项目根目录中的配置文件 app.json 加入如下配置信息\xa0"tabBar": {\xa0 \xa0 '
            '"color": "#a9b7b7",\xa0 \xa0 "selectedColor": "#11cd6e",\xa0 \xa0 '
            '"borderStyle":"white",\xa0 \xa0 "list": [{\xa0 \xa0 \xa0 '
            '"selectedIconPath": "images/111.png",\xa0 \xa0 \xa0 "iconPath": '
            '"images/11.png",\xa0 \xa0 \xa0 "pagePath": '
            '"pages/index/index",\xa0 \xa0 \xa0 "text": "首页"\xa0 \xa0 }, '
            '{\xa0 \xa0 \xa0 "selectedIconPath": '
            '"images/221.png",\xa0 \xa0 \xa0 "iconPath": '
            '"images/22.png",\xa0 \xa0 \xa0 "pagePath": '
            '"pages/logs/logs",\xa0 \xa0 \xa0 "text": "日志"\xa0 \xa0 }, '
            '{\xa0 \xa0 \xa0 "selectedIconPath": '
            '"images/331.png",\xa0 \xa0 \xa0 "iconPath": '
            '"images/33.png",\xa0 \xa0 \xa0 "pagePath": '
            '"pages/test/test",\xa0 \xa0 \xa0 "text": "开心测试"\xa0 \xa0 }]\xa0 '
            '},解释一下 对应的属性信息tabBar\xa0\xa0指底部的 导航配置属性color\xa0\xa0未选择时 '
            '底部导航文字的颜色selectedColor\xa0\xa0选择时 底部导航文字的颜色borderStyle\xa0\xa0'
            '底部导航边框的样色（注意\xa0这里如果没有写入样式 会导致 导航框上边框会出现默认的浅灰色线条）list\xa0\xa0 '
            '导航配置数组selectedIconPath\xa0选中时 图标路径iconPath\xa0未选择时 '
            '图标路径pagePath\xa0页面访问地址text\xa0\xa0导航图标下方文字如果要改变更详细的样式 '
            '请参看https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabBar好了，保存 '
            '编译 \xa0就可以看到上面的效果了。',
 'pub_time': '2016-10-20 14:33',
 'title': '微信小程序简易全攻略《二》设置页面标题与底部导航 '}
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-133-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-131-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-130-1.html>
{'author': '天下雪',
 'content': 'MINA是微信开发小程序的框架：MINA的目标是通过尽可能简单，高效的方式让开发者可以在微信中开发具有原生APP体验的服务。运行MINA的项目必须要有微信web开发者工具MINA框架中有四种类型的文件:.js文件 '
            '基于JavaScript的逻辑层框架.wxml\xa0视图层文件，是MINA设计的一套标签语言.wxss\xa0'
            '样式文件，用于描述WXML的组件样式.json\xa0'
            '文件，配置文件，用于单个页面的配置和整个项目的配置目录结构为了减少配置项，小程序中一个页面中的四个文件必须要有相同的路径和文件名,使用微信web开发者工具新建一个项目,可以看到他的目录结构是这样的：其中app.js是程序的入口，app.json是项目的配置文件,app.wxss是全局配置的样式文件,logs和index文件夹是是单个页面的文件，utils用来存放常用的工具类文件夹。app.jsapp.js使用App()函数注册一个小程序，可以指定小程序的生命周期小程序的App()生命周期中三个事件可以监听:onLaunch，onShow，onHide。onLaunch：小程序加载完成之后调用,全局只触发一次onShow： '
            '小程序启动，或者从后台到前台会触发一次onHide：小程序从前台到后台会触发一次例如:App({ \r\n'
            ' onLaunch: function () { \r\n'
            "    console.log('App Launch')\r\n"
            '  }, \r\n'
            ' onShow: function () {\r\n'
            "    console.log('App Show')  \r\n"
            '},  \r\n'
            'onHide: function () {\r\n'
            "    console.log('App Hide')  \r\n"
            '}, \r\n'
            ' globalData: {\r\n'
            '    hasLogin: false  \r\n'
            '}\r\n'
            '})其中app.js的globalData可以设置全局的变量,在一个页面中可以通过getApp()函数获取小程序的实例，使用App的getCurrentPage()可以获取到当前页面的实例。app.jsonapp.json是小程序的全局配置包括:页面的路径，窗口表现，设置网络超时,开发模式等...页面配置pages:设置页面的路径  '
            '"pages":[\r\n'
            '    "pages/index/index",\r\n'
            '    "pages/logs/logs"\r\n'
            '  '
            ']配置的index和logs两个页面的路径,在这里使用相对路径配置页面路径。窗口配置windows：用来配置状态栏的颜色，导航条的样式和颜色，标题，已经窗口的背景色:"window":{\r\n'
            '    "backgroundTextStyle":"light",\r\n'
            '    "navigationBarBackgroundColor": "#ffffff",\r\n'
            '    "navigationBarTitleText": "WeChat",\r\n'
            '    "navigationBarTextStyle":"black"\r\n'
            '  '
            '}使用的Color为十六进制的颜色值,比如"#ffffff"注意:其中navigationBarTextStyle，导航栏的颜色仅支持black/white。而backgroundTextStyle，下拉背景的样式仅支持dark/light。tabBar: '
            '设置tab应用，tabBar是一个数组，最少需要配置2个，最多能配置5个tab，tab按照数据的顺序排序："tabBar":{\r\n'
            '    "color":"#dddddd",\r\n'
            '    "selectdColor":"#3cc51f",\r\n'
            '    "borderStyle":"black",\r\n'
            '    "backgroundColor":"#ffffff"\r\n'
            '  ,"list":[\r\n'
            '    {\r\n'
            '      "pagePath":"pages/index/index",\r\n'
            '      "iconPath":"image/wechat.png",\r\n'
            '      "selectedIconPath":"image/wechatHL.png",\r\n'
            '      "text":"主页"\r\n'
            '      },{\r\n'
            '    "pagePath":"pages/logs/logs",\r\n'
            '    "iconPath":"image/wechat.png",\r\n'
            '    "selectedIconPath":"image/wechatHL.png",\r\n'
            '    "text":"日志"\r\n'
            '  }]\r\n'
            '}这里设置了两个tab页:index和log，效果如下:networkTimeout设置网络请求的超时时间,小程序有四种类型的网络请求wx.request普通的http请求，配置为requestwx.connect\xa0'
            'stock链接,配置为connectSocketwx.uploadFile上传文件,配置为uploadFilewx.downloadFile下载文件,配置为downloadFile配置单位为毫秒,例如："networkTimeout": '
            '{\r\n'
            '    "request": 10000,\r\n'
            '    "connectSocket": 10000,\r\n'
            '    "uploadFile": 10000,\r\n'
            '    "downloadFile": 10000\r\n'
            '  '
            '}debug:开发工具中开启debug模式，在控制台面板上可以看到调试信息,我们也可以使用console.log(\'onLoad\')输入log帮助我们调试程序。"debug":\xa0'
            'trueapp.wxssapp.wxss中定义的的样式为全局样式，作用在每一个页面，在page中定义的.wxss文件为局部样式，只作用在局部，局部样式中的定义会覆盖app.wxss中定义的样式。样式的定义:.container '
            '{\r\n'
            '  height: 100%;\r\n'
            '  display: flex;\r\n'
            '  flex-direction: column;\r\n'
            '  align-items: center;\r\n'
            '  justify-content: space-between;\r\n'
            '  padding: 200rpx 0;\r\n'
            '  box-sizing: border-box;\r\n'
            '}其中200rpx中的rpx是reponslve '
            'pixel，可以根据屏幕的宽度进行自适应，在iPhone6上1rpx=0.5px=1物理像素。微信小程序建议设计以iPhone6为准样式的使用：class="container">\r\n'
            '\r\n'
            'page使用Page()函数来注册一个页面，为其指定页面的初始数据，生命周期函数，事件处理等。data\xa0'
            '页面的初始数据，可以使用setData更新定义的数据onLoad\xa0页面加载事件onReady\xa0'
            '页面渲染完成onShow\xa0页面显示onHide\xa0页面隐藏onUnload\xa0页面卸载例如:Page({\r\n'
            '  data: {\r\n'
            '    logs: []\r\n'
            '  },\r\n'
            '  onLoad: function () {\r\n'
            '    this.setData({\r\n'
            "      logs: (wx.getStorageSync('logs') || []).map(function (log) "
            '{\r\n'
            '        return util.formatTime(new Date(log))\r\n'
            '      })\r\n'
            '    })\r\n'
            '  }\r\n'
            '})page另外使用的文件.wxml是页面文件，使用定义好一套标签语言，.wxss是局部样式文件，.json局部配置文件比如需要在一个单独的页面中设置他的navigationBarTitleText,可以在.json文件中设置:{\r\n'
            '    "navigationBarTitleText": "日志文件"\r\n'
            '}源代码地址:https://github.com/jjz/weixin-mina',
 'pub_time': '2016-10-23 11:58',
 'title': '微信小程序开发框架MINA分析 '}
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-134-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-132-1.html>
{'author': '天下雪',
 'content': '了解.js文件1、app.jsapp.js是整个小程序的入口文件，也是控制整个小程序生命周期的文件。App.js用App()来实现对整个程序的注册，同时App()里面还实现了对小程序生命周期的监控函数(onLaunch, '
            'onShow, '
            'onHide)。APP()内部参数说明：属性类型描述触发时机onLaunchFunction生命周期函数--监听小程序初始化当小程序初始化完成时，会触发onLaunch（全局只触发一次）onShowFunction生命周期函数--监听小程序显示当小程序启动，或从后台进入前台显示，会触发\xa0'
            'onShowonHideFunction生命周期函数--监听小程序隐藏当小程序从前台进入后台，会触发\xa0'
            'onHide其他Any开发者可以添加任意的函数或数据到Object\xa0参数中，用\xa0this\xa0'
            '可以访问\xa0\xa0\xa0\xa0\xa0我们来看一个app.js的代码：//app.jsApp({  onLaunch: '
            'function () {    ... ...  },  getUserInfo:function(cb){    ... '
            '...  },  globalData:{    userInfo:null  },  onShow: '
            'function(){    ... ...  },  onHide: function(){    ... ...  '
            '}})\xa0小程序前台、后台定义：\xa0当用户点击左上角关闭，或者按了设备\xa0Home\xa0'
            '键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。简单地说，前台就是你在操作小程序时；后台就是你离开了小程序，去玩手机的其他东西去了，这时小程序就隐藏到后面去了。\xa0'
            '2、index.js小程序中每一个页面可以放在一个文件夹中，这个文件夹中一般包括4个文件：.js, .json, .wxml, '
            '.wxss。官方建议这四个文件的名字最好和文件夹的名字一致，这样便于框架自动查找。每个页面都需要注册，index.js用Page()这个函数来注册一个页面，它接受一个object参数，用这个参数来指定页面的初始数据，生命周期函数，事件处理函数。\xa0'
            'Page()内部参数说明：属性类型描述dataObject页面的初始数据onLoadFunction生命周期函数--监听页面加载onReadyFunction赞赏 \n'
            '                             \n'
            '                 \n'
            '                邀请 \n'
            '               \n'
            '               \n'
            '               \n'
            '            \n'
            '             \n'
            '                         \n'
            '              \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鲜花                (1)\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鸡蛋                \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            'function errorhandle_clickhandle(message, values) {\r\n'
            "if(values['id']) {\r\n"
            'showCreditPrompt();\r\n'
            "show_click(values['idtype'], values['id'], values['clickid']);\r\n"
            '}\r\n'
            '}\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '刚表态过的朋友 (1 人)\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            'hgf\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '            \n'
            '\n'
            '分享至 :\n'
            '\n'
            '\n'
            'QQ空间\n'
            '\n'
            'window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName(\'head\')[0]||body).appendChild(createElement(\'script\')).src=\'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=\'+~(-new '
            'Date()/36e5)];\n'
            '\n'
            '收藏\n'
            '\n'
            '             \n'
            '                         \n'
            '              有渔微信小程序系统概述《一》认识微信小程序与HelloWorld \n'
            '              有渔微信小程序系统概述《三》view层及小程序框架概述 \n'
            '            \n'
            '             \n'
            '            \n'
            '                  原作者: 有渔 \n'
            '                  来自: 授权地址 \n'
            '                   \n'
            '                   \n'
            '                              \n'
            '            \r\n'
            '    /*700*200 创建于 2017/12/12*/\r\n'
            '    var cpro_id = "u3158955";\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '                        \n'
            '              \n'
            '                相关阅读\n'
            '              \n'
            '              \n'
            '                \n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n'
            '                                    \n'
            '                  • 有渔微信小程序系统进阶《四》小程序组件\n'
            '                                    \n'
            '                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n'
            '                                  \n'
            '              \n'
            '            \n'
            '             \n'
            '            \n'
            '          \n'
            '           \n'
            '        \n'
            '      \n'
            '       \n'
            '       \n'
            '      \r\n'
            '   \r\n'
            '    0 条回复\r\n'
            '  \r\n'
            '   \r\n'
            '    \r\n'
            '     \r\n'
            '     \r\n'
            '    \r\n'
            '        \r\n'
            '      \r\n'
            '  \r\n'
            '\r\n'
            '        \r\n'
            '    \r\n'
            '     \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                \r\n'
            '\r\n'
            '\r\n'
            '\t\t\r\n'
            'updateseccode(\'cSCCF1Fc\', \'<sec> <span id="sec<hash>" '
            'onclick="showMenu(this.id);"><sec></span><div id="sec<hash>_menu" '
            'class="p_pop p_opt" style="display:none"><sec></div>\', '
            "'portal::view');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '发表回复\r\n'
            '                \r\n'
            '\r\n'
            '           \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '\r\n'
            '   \r\n'
            '    \r\n'
            '        \r\n'
            '    jQuery(function(){\r\n'
            'jQuery("#tedt .pt").focus(function(){\r\n'
            '  jQuery(this).addClass("bgchange");\r\n'
            '}).blur(function(){\r\n'
            '  jQuery(this).removeClass("bgchange");\r\n'
            '});\r\n'
            '    });\r\n'
            '     \r\n'
            '\r\n'
            '    \r\n'
            '    \r\n'
            ' \n'
            '       \n'
            '       \n'
            '    \n'
            '  \n'
            '  \n'
            '    \n'
            '     \n'
            '      \r\n'
            '          相关栏目\r\n'
            '      \r\n'
            '        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n'
            '      \r\n'
            '          \r\n'
            '新手教程阅读排行\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            ' \n'
            '    \n'
            '  \n'
            '\n'
            '\n'
            '\n'
            ' \n'
            '   \n'
            '\n'
            '\n'
            ' \n'
            'jQuery(function() {\n'
            'jQuery("span").click(function() {\n'
            'var thisEle = jQuery("#article_content").css("font-size");\n'
            'var textFontSize = parseFloat(thisEle, 10);\n'
            'var unit = thisEle.slice( - 2);\n'
            'var cName = jQuery(this).attr("class");\n'
            'if (cName == "bigger") {\n'
            'if (textFontSize <= 22) {\n'
            'textFontSize += 2;\n'
            '}\n'
            '} else if (cName == "smaller") {\n'
            'if (textFontSize >= 12) {\n'
            'textFontSize -= 2;\n'
            '}\n'
            '}\n'
            'jQuery("#article_content").css("font-size", textFontSize + '
            'unit);\n'
            '});\n'
            '});\n'
            ' \n'
            ' \n'
            '     \n'
            '\n'
            '\r\n'
            '\r\n'
            '\n'
            '\n'
            '  \n'
            '     © 2019 极乐科技 | \n'
            '         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n'
            '         \n'
            '        \r\n'
            'var _hmt = _hmt || [];\r\n'
            '(function() {\r\n'
            '  var hm = document.createElement("script");\r\n'
            '  hm.src = '
            '"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b";\r\n'
            '  var s = document.getElementsByTagName("script")[0]; \r\n'
            '  s.parentNode.insertBefore(hm, s);\r\n'
            '})();\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '  '
            "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n"
            '  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new '
            'Date();a=s.createElement(o),\r\n'
            '  '
            'm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n'
            '  '
            "})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n"
            '\r\n'
            "  ga('create', 'UA-98020757-1', 'auto');\r\n"
            "  ga('send', 'pageview');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=(\'https:\'==document.location.protocol?\'https://\':\'http://\')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.growingio.com/2.1/gio.js","gio");\r\n'
            "  gio('init','874f0f6c4c3a4387', {});\r\n"
            '\r\n'
            '//custom page code begin here\r\n'
            '\r\n'
            '//custom page code end here\r\n'
            '\r\n'
            "gio('send');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '     \n'
            '   \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            '  \n'
            '\n'
            '\n'
            '\n'
            '返回顶部\n'
            '\n'
            '\n'
            'jQuery.noConflict();\n'
            'jQuery(function(){\n'
            '        //首先将#back-to-top隐藏\n'
            '        jQuery("#share").hide();\n'
            '        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n'
            '        jQuery(function () {\n'
            '            jQuery(window).scroll(function(){\n'
            '                if (jQuery(window).scrollTop()>100){\n'
            '                    jQuery("#share").fadeIn();\n'
            '                }\n'
            '                else\n'
            '                {\n'
            '                    jQuery("#share").fadeOut();\n'
            '                }\n'
            '            });\n'
            '            //当点击跳转链接后，回到页面顶部位置\n'
            '            jQuery("#totop").click(function(){\n'
            "                jQuery('body,html').animate({scrollTop:0},500);\n"
            '                return false;\n'
            '            });\n'
            '        });\n'
            '    }); \n'
            '\n'
            '\n'
            ' \n'
            ' \t\t\t\r\n'
            '\t\t\t\r\n'
            '\t\t\t\tvar tipsinfo = '
            "'9999|X3.2|0.6||0||0|7|1564035900|ef732c1391769e61a270097c9ba33326|2';",
 'pub_time': '2016-10-23 12:17',
 'title': '有渔微信小程序系统概述《二》了解.js文件及.json文件 '}
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-133-1.html>
{'author': '天下雪',
 'content': '小程序的view层MVC模式这里就不讲了，不懂MVC模式的就自己去查阅相关资料。小程序的的view层由WXML与WXSS编写，由组件来进行展示。view层将逻辑层的数据反应成界面显示，同时将界面发生的事件发送给逻辑层。WXML(WeiXin '
            'Markup language)用于描述页面的结构，可以想象成Html文件。WXSS(WeiXin Style '
            'Sheet)用于描述页面的样式，可以想象成Css文件。组件(Component)是视图的基本组成单元，可以想象成Html中的组件。下面我们用简单的例子来看看\xa0'
            'WXML\xa0具有什么能力：\xa01、测试环境准备⑴\xa0'
            'pages目录里建立viewtest目录，专门用来做view层测试。⑵\xa0'
            'index里添加触发viewtest的相关代码①\xa0index.wxml修改成：②\xa0index.js添加下面的代码：  '
            'bindUserTap: function() {    wx.navigateTo({      url: '
            "'../viewtest/viewtest'    })  },③\xa0"
            'app.json把viewtest路径加入pages参数里：  "pages":[    '
            '"pages/index/index",    "pages/logs/logs",    '
            '"pages/viewtest/viewtest"  ],\xa02、例子⑴\xa0'
            '数据绑定<!--viewtest.wxml--><view> {{message}} </view>// '
            "viewtest.jsPage({  data: {    message: 'Hello MINA!'  }})\xa0⑵\xa0"
            '列表渲染<!--viewtest.wxml--><view wx:for="{{array}}"> {{item}} '
            '</view>// viewtest.jsPage({赞赏 \n'
            '                             \n'
            '                 \n'
            '                邀请 \n'
            '               \n'
            '               \n'
            '               \n'
            '            \n'
            '             \n'
            '                         \n'
            '              \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鲜花                \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鸡蛋                \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            'function errorhandle_clickhandle(message, values) {\r\n'
            "if(values['id']) {\r\n"
            'showCreditPrompt();\r\n'
            "show_click(values['idtype'], values['id'], values['clickid']);\r\n"
            '}\r\n'
            '}\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '            \n'
            '\n'
            '分享至 :\n'
            '\n'
            '\n'
            'QQ空间\n'
            '\n'
            'window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName(\'head\')[0]||body).appendChild(createElement(\'script\')).src=\'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=\'+~(-new '
            'Date()/36e5)];\n'
            '\n'
            '收藏\n'
            '\n'
            '             \n'
            '                         \n'
            '              有渔微信小程序系统概述《二》了解.js文件及.json文件 \n'
            '              有渔微信小程序系统概述《六》小程序的API \n'
            '            \n'
            '             \n'
            '            \n'
            '                  原作者: 有渔 \n'
            '                  来自: 授权地址 \n'
            '                   \n'
            '                   \n'
            '                              \n'
            '            \r\n'
            '    /*700*200 创建于 2017/12/12*/\r\n'
            '    var cpro_id = "u3158955";\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '                        \n'
            '              \n'
            '                相关阅读\n'
            '              \n'
            '              \n'
            '                \n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n'
            '                                    \n'
            '                  • 有渔微信小程序系统进阶《四》小程序组件\n'
            '                                    \n'
            '                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n'
            '                                  \n'
            '              \n'
            '            \n'
            '             \n'
            '            \n'
            '          \n'
            '           \n'
            '        \n'
            '      \n'
            '       \n'
            '       \n'
            '      \r\n'
            '   \r\n'
            '    0 条回复\r\n'
            '  \r\n'
            '   \r\n'
            '    \r\n'
            '     \r\n'
            '     \r\n'
            '    \r\n'
            '        \r\n'
            '      \r\n'
            '  \r\n'
            '\r\n'
            '        \r\n'
            '    \r\n'
            '     \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                \r\n'
            '\r\n'
            '\r\n'
            '\t\t\r\n'
            'updateseccode(\'cSCCF1Fc\', \'<sec> <span id="sec<hash>" '
            'onclick="showMenu(this.id);"><sec></span><div id="sec<hash>_menu" '
            'class="p_pop p_opt" style="display:none"><sec></div>\', '
            "'portal::view');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '发表回复\r\n'
            '                \r\n'
            '\r\n'
            '           \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '\r\n'
            '   \r\n'
            '    \r\n'
            '        \r\n'
            '    jQuery(function(){\r\n'
            'jQuery("#tedt .pt").focus(function(){\r\n'
            '  jQuery(this).addClass("bgchange");\r\n'
            '}).blur(function(){\r\n'
            '  jQuery(this).removeClass("bgchange");\r\n'
            '});\r\n'
            '    });\r\n'
            '     \r\n'
            '\r\n'
            '    \r\n'
            '    \r\n'
            ' \n'
            '       \n'
            '       \n'
            '    \n'
            '  \n'
            '  \n'
            '    \n'
            '     \n'
            '      \r\n'
            '          相关栏目\r\n'
            '      \r\n'
            '        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n'
            '      \r\n'
            '          \r\n'
            '新手教程阅读排行\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            ' \n'
            '    \n'
            '  \n'
            '\n'
            '\n'
            '\n'
            ' \n'
            '   \n'
            '\n'
            '\n'
            ' \n'
            'jQuery(function() {\n'
            'jQuery("span").click(function() {\n'
            'var thisEle = jQuery("#article_content").css("font-size");\n'
            'var textFontSize = parseFloat(thisEle, 10);\n'
            'var unit = thisEle.slice( - 2);\n'
            'var cName = jQuery(this).attr("class");\n'
            'if (cName == "bigger") {\n'
            'if (textFontSize <= 22) {\n'
            'textFontSize += 2;\n'
            '}\n'
            '} else if (cName == "smaller") {\n'
            'if (textFontSize >= 12) {\n'
            'textFontSize -= 2;\n'
            '}\n'
            '}\n'
            'jQuery("#article_content").css("font-size", textFontSize + '
            'unit);\n'
            '});\n'
            '});\n'
            ' \n'
            ' \n'
            '     \n'
            '\n'
            '\r\n'
            '\r\n'
            '\n'
            '\n'
            '  \n'
            '     © 2019 极乐科技 | \n'
            '         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n'
            '         \n'
            '        \r\n'
            'var _hmt = _hmt || [];\r\n'
            '(function() {\r\n'
            '  var hm = document.createElement("script");\r\n'
            '  hm.src = '
            '"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b";\r\n'
            '  var s = document.getElementsByTagName("script")[0]; \r\n'
            '  s.parentNode.insertBefore(hm, s);\r\n'
            '})();\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '  '
            "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n"
            '  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new '
            'Date();a=s.createElement(o),\r\n'
            '  '
            'm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n'
            '  '
            "})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n"
            '\r\n'
            "  ga('create', 'UA-98020757-1', 'auto');\r\n"
            "  ga('send', 'pageview');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=(\'https:\'==document.location.protocol?\'https://\':\'http://\')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.growingio.com/2.1/gio.js","gio");\r\n'
            "  gio('init','874f0f6c4c3a4387', {});\r\n"
            '\r\n'
            '//custom page code begin here\r\n'
            '\r\n'
            '//custom page code end here\r\n'
            '\r\n'
            "gio('send');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '     \n'
            '   \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            '  \n'
            '\n'
            '\n'
            '\n'
            '返回顶部\n'
            '\n'
            '\n'
            'jQuery.noConflict();\n'
            'jQuery(function(){\n'
            '        //首先将#back-to-top隐藏\n'
            '        jQuery("#share").hide();\n'
            '        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n'
            '        jQuery(function () {\n'
            '            jQuery(window).scroll(function(){\n'
            '                if (jQuery(window).scrollTop()>100){\n'
            '                    jQuery("#share").fadeIn();\n'
            '                }\n'
            '                else\n'
            '                {\n'
            '                    jQuery("#share").fadeOut();\n'
            '                }\n'
            '            });\n'
            '            //当点击跳转链接后，回到页面顶部位置\n'
            '            jQuery("#totop").click(function(){\n'
            "                jQuery('body,html').animate({scrollTop:0},500);\n"
            '                return false;\n'
            '            });\n'
            '        });\n'
            '    }); \n'
            '\n'
            '\n'
            ' \n'
            ' \t\t\t\r\n'
            '\t\t\t\r\n'
            '\t\t\t\tvar tipsinfo = '
            "'9999|X3.2|0.6||0||0|7|1564035900|ef732c1391769e61a270097c9ba33326|2';",
 'pub_time': '2016-10-23 12:25',
 'title': '有渔微信小程序系统概述《三》view层及小程序框架概述 '}
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-131-1.html>
{'author': '天下雪',
 'content': '认识微信小程序一、当前APP的痛点1.\xa0'
            '用户的痛自从买了智能手机后，手机上装了一堆APP，每次装一个新应用就必须下载安装一个APP。这手机屏幕成了百货展厅，每次找个APP还得滑动屏幕找白天；而且每次安装一个APP，就占用大量空间，这手机容量也越来越不够用了。一次跟一位做运营的朋友聊天，他说现在只在微信上做推广，因为微信上客户群体多。他说知名度小的APP很难推，一是推广费用高，二是客户一般也不愿下载。\xa0'
            '2.\xa0'
            '开发者的痛现在做互联网的，开发了PC端的WEB后，再开发Android和Apple版，几乎是标配。我也曾经赶过这趟浑水，当时团队开发完了PC端的WEB，然后自然就想到要开发Android和Apple版。但问题来了：我们团队人少，而且大家都没APP开发经验；哪就找外包呗？于是我们就去找外包公司。后来在聊天中外包公司的老大就向我吐苦水，他说现在1个Android，1个Apple团队，1个项目必须得养2帮人马，开发成本太高了。后来，为了省财力、时间，我就让外包公司开发一个APP的外壳，然后里面打开浏览器访问我们的WAP网站，也就是Hybrid '
            'APP解决方案。Hybrid APP解决方案虽然开发便捷，但在用户体验上就比原生的APP差很多。\xa0'
            '二、微信小程序方便了用户，更方便了开发者什么是小程序？小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不关心是否安装太多应用的问题。应用将无处不在，随时随地可用，但又无需安装卸载。微信小程序解决了当前APP的痛点，方便了用户，更方便了开发者。从本质上看，微信小程序有点类似Hybrid '
            'APP解决方案。以后微信就成为移动端入口，用户不用再无休止地安装APP了；开发者只需要用javaScript一种语言就可以了，开发成本几乎可省下2/3以上；而且微信提供了非常丰富的API，微信小程序的用户体验肯定不会比原生的APP差。微信作为国内最大的交友平台，已经成了一个独立的互联网王国，上面有大量的用户资源，微信小程序推广的性价比就非常高。\xa0\xa0\xa0'
            '可以想象，再过一段时间，大量的APP开发者会转投微信小程序的大营，而且几乎所有的APP都会重新再开发一个微信小程序版本，微信小程序开发人员的需求也会非常大。所以，作为一名互联网从业人员，学习掌握微信小程序开发是非常有必要的。HelloWorld微信小程序看千遍不如做一遍。先让我们来一起做一个最简单的HelloWorld吧。\xa0\xa0\xa0\xa0'
            '1.下载安装微信小程序开发者工具，下载路径：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html根据你的操作系统类型，选择windows '
            '64、windows 32或mac。\xa0\xa0\xa0\xa0\xa02.创建项目\xa0\xa0\xa0\xa0⑴\xa0'
            '添加项目\xa0\xa0\xa0\xa0点击“添加项目”按钮，创建一个项目。⑵\xa0'
            '项目的几个参数说明\xa0\xa0\xa0\xa0没有\xa0AppID\xa0'
            '就选无AppID（如果乱写会报错，到时可能无法进入项目）。如果你选择的“项目目录”为空，请如图所示勾选在“当前目录中创建quick '
            'start项目”。项目名称就随便写一个吧，比如“测试项目”。点击“添加项目”按钮，一个最简单的微信小程序就完成了。3.项目代码结构说明\xa0 \xa0\xa0'
            '点击开发者工具左侧导航的“编辑”，我们可以看到这个项目已经初始化并包含了一些简单的代码。其中包括：app.js，app.json，app.wxss和2个目录：pages，utils。\xa0\xa0\xa0\xa0\xa0'
            '其中，最重要的是\xa0app.js、app.json、app.wxss\xa0这三个文件。\xa0\xa0\xa0\xa0'
            'app.js：这个文件是整个小程序的入口文件。\xa0\xa0\xa0\xa0'
            'app.json：这个文件是小程序的全局配置文件，决定页面文件的路径，窗口表现，设置网络超时时间等。app.wxss：是小程序的样式文件，你可以把它想象成html中的CSS。',
 'pub_time': '2016-10-23 12:11',
 'title': '有渔微信小程序系统概述《一》认识微信小程序与HelloWorld '}
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-135-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-134-1.html>
{'author': '天下雪',
 'content': '组件(Component)是小程序视图的基本组成单元，可以把它想象成Html中的组件，你可以通过组合这些基础组件快速开发小程序的界面。小程序的组件包括以下内容：大类具体组件说明视图容器view视图scroll-view可滚动视图区域swiper滑块视图区域赞赏 \n'
            '                             \n'
            '                 \n'
            '                邀请 \n'
            '               \n'
            '               \n'
            '               \n'
            '            \n'
            '             \n'
            '                         \n'
            '              \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鲜花                \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鸡蛋                \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            'function errorhandle_clickhandle(message, values) {\r\n'
            "if(values['id']) {\r\n"
            'showCreditPrompt();\r\n'
            "show_click(values['idtype'], values['id'], values['clickid']);\r\n"
            '}\r\n'
            '}\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '            \n'
            '\n'
            '分享至 :\n'
            '\n'
            '\n'
            'QQ空间\n'
            '\n'
            'window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName(\'head\')[0]||body).appendChild(createElement(\'script\')).src=\'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=\'+~(-new '
            'Date()/36e5)];\n'
            '\n'
            '收藏\n'
            '\n'
            '             \n'
            '                         \n'
            '              精品教程《二》：微信小程序实战之小豆瓣图书 \n'
            '              微信小程序实战教程：火车票查询，直取12306数据 \n'
            '            \n'
            '             \n'
            '            \n'
            '                  原作者: 有渔 \n'
            '                  来自: 授权地址 \n'
            '                   \n'
            '                   \n'
            '                              \n'
            '            \r\n'
            '    /*700*200 创建于 2017/12/12*/\r\n'
            '    var cpro_id = "u3158955";\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '                        \n'
            '              \n'
            '                相关阅读\n'
            '              \n'
            '              \n'
            '                \n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n'
            '                                    \n'
            '                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n'
            '                                    \n'
            '                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n'
            '                                  \n'
            '              \n'
            '            \n'
            '             \n'
            '            \n'
            '          \n'
            '           \n'
            '        \n'
            '      \n'
            '       \n'
            '       \n'
            '      \r\n'
            '   \r\n'
            '    0 条回复\r\n'
            '  \r\n'
            '   \r\n'
            '    \r\n'
            '     \r\n'
            '     \r\n'
            '    \r\n'
            '        \r\n'
            '      \r\n'
            '  \r\n'
            '\r\n'
            '        \r\n'
            '    \r\n'
            '     \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                \r\n'
            '\r\n'
            '\r\n'
            '\t\t\r\n'
            'updateseccode(\'cSCCF1Fc\', \'<sec> <span id="sec<hash>" '
            'onclick="showMenu(this.id);"><sec></span><div id="sec<hash>_menu" '
            'class="p_pop p_opt" style="display:none"><sec></div>\', '
            "'portal::view');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '发表回复\r\n'
            '                \r\n'
            '\r\n'
            '           \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '\r\n'
            '   \r\n'
            '    \r\n'
            '        \r\n'
            '    jQuery(function(){\r\n'
            'jQuery("#tedt .pt").focus(function(){\r\n'
            '  jQuery(this).addClass("bgchange");\r\n'
            '}).blur(function(){\r\n'
            '  jQuery(this).removeClass("bgchange");\r\n'
            '});\r\n'
            '    });\r\n'
            '     \r\n'
            '\r\n'
            '    \r\n'
            '    \r\n'
            ' \n'
            '       \n'
            '       \n'
            '    \n'
            '  \n'
            '  \n'
            '    \r\n'
            '推荐教程\r\n'
            '\r\n'
            '\r\n'
            '当微信小程序遇上 '
            'TensorFlow：本地缓存模2019-07-03如何两步完成一个抽奖小程序2019-07-04马蜂窝旅游小程序2019-07-03Taro撸一个简版的微信读书小程序2019-07-05微信小程序打怪之定时发送模板消息(node版)2019-07-04我的第一个小程序：小程序与SEO2019-07-05开发 '
            '地图标记工具 '
            '后记2019-07-03微信小程序--wx.request封装和使用2019-07-03微信小程序-麦当劳点餐+爬虫2019-07-03\r\n'
            '\r\n'
            '\n'
            '     \n'
            '      \r\n'
            '最新Demo\r\n'
            '\r\n'
            '\r\n'
            '校园综合服务平台小程序2019-07-13一款适合全民朗读的音频小程序源码2019-07-01微信小程序作品-食堂供餐服务小程序2019-06-27农物小助手-AR扫病害2019-06-26微信公众平台登录小程序后台问题2019-06-26有人有用测试号开发的社区类或者论坛类源码2019-06-22小程序商城—自己开发的源码，有需要学习交2019-06-14微信小游戏坦克大战源码2019-06-12像企业介绍和产品介绍的小程序吗求个代码是2019-05-30\r\n'
            '\r\n'
            ' \n'
            '    \n'
            '  \n'
            '\n'
            '\n'
            '\n'
            ' \n'
            '   \n'
            '\n'
            '\n'
            ' \n'
            'jQuery(function() {\n'
            'jQuery("span").click(function() {\n'
            'var thisEle = jQuery("#article_content").css("font-size");\n'
            'var textFontSize = parseFloat(thisEle, 10);\n'
            'var unit = thisEle.slice( - 2);\n'
            'var cName = jQuery(this).attr("class");\n'
            'if (cName == "bigger") {\n'
            'if (textFontSize <= 22) {\n'
            'textFontSize += 2;\n'
            '}\n'
            '} else if (cName == "smaller") {\n'
            'if (textFontSize >= 12) {\n'
            'textFontSize -= 2;\n'
            '}\n'
            '}\n'
            'jQuery("#article_content").css("font-size", textFontSize + '
            'unit);\n'
            '});\n'
            '});\n'
            ' \n'
            ' \n'
            '     \n'
            '\n'
            '\r\n'
            '\r\n'
            '\n'
            '\n'
            '  \n'
            '     © 2019 极乐科技 | \n'
            '         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n'
            '         \n'
            '        \r\n'
            'var _hmt = _hmt || [];\r\n'
            '(function() {\r\n'
            '  var hm = document.createElement("script");\r\n'
            '  hm.src = '
            '"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b";\r\n'
            '  var s = document.getElementsByTagName("script")[0]; \r\n'
            '  s.parentNode.insertBefore(hm, s);\r\n'
            '})();\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '  '
            "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n"
            '  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new '
            'Date();a=s.createElement(o),\r\n'
            '  '
            'm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n'
            '  '
            "})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n"
            '\r\n'
            "  ga('create', 'UA-98020757-1', 'auto');\r\n"
            "  ga('send', 'pageview');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=(\'https:\'==document.location.protocol?\'https://\':\'http://\')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.growingio.com/2.1/gio.js","gio");\r\n'
            "  gio('init','874f0f6c4c3a4387', {});\r\n"
            '\r\n'
            '//custom page code begin here\r\n'
            '\r\n'
            '//custom page code end here\r\n'
            '\r\n'
            "gio('send');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '     \n'
            '   \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            '  \n'
            '\n'
            '\n'
            '\n'
            '返回顶部\n'
            '\n'
            '\n'
            'jQuery.noConflict();\n'
            'jQuery(function(){\n'
            '        //首先将#back-to-top隐藏\n'
            '        jQuery("#share").hide();\n'
            '        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n'
            '        jQuery(function () {\n'
            '            jQuery(window).scroll(function(){\n'
            '                if (jQuery(window).scrollTop()>100){\n'
            '                    jQuery("#share").fadeIn();\n'
            '                }\n'
            '                else\n'
            '                {\n'
            '                    jQuery("#share").fadeOut();\n'
            '                }\n'
            '            });\n'
            '            //当点击跳转链接后，回到页面顶部位置\n'
            '            jQuery("#totop").click(function(){\n'
            "                jQuery('body,html').animate({scrollTop:0},500);\n"
            '                return false;\n'
            '            });\n'
            '        });\n'
            '    }); \n'
            '\n'
            '\n'
            ' \n'
            ' \t\t\t\r\n'
            '\t\t\t\r\n'
            '\t\t\t\tvar tipsinfo = '
            "'9999|X3.2|0.6||0||0|7|1564035900|ef732c1391769e61a270097c9ba33326|2';",
 'pub_time': '2016-10-23 12:34',
 'title': '有渔微信小程序系统进阶《四》小程序组件 '}
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-135-1.html>
{'author': '天下雪',
 'content': '小程序开发的wxml里，用到了Mustache语法。所以，非常有必要把Mustache研究下。什么是Mustache?Mustache是一个logic-less（轻逻辑）模板解析引擎，它是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，通常是标准的HTML文档。比如小程序的wxml中的代码：{{userInfo.nickName}}，这里的{{ '
            '}}就是Mustache的语法。1、Mustache的模板语法很简单，就那么几个：{{keyName}}{{{keyName}}}{{#keyName}} '
            '{{/keyName}}{{^keyName}} '
            '{{/keyName}}{{.}}{{!comments}}{{>partials}}\xa01、{{keyName}}⑴\xa0'
            '简单的变量替换：{{name}}var data = { "name": "weChat" '
            '};Mustache.render（"{{name}} is excellent."，data）;返回\xa0weChat is '
            'excellent.⑵\xa0变量含有html的代码，如：、等而不想转义，可以在用{{&name}}var data = {    '
            '"name" : "<br>weChat<br>"};var output = '
            'Mustache.render("{{&name}} is excellent.", '
            'data);console.log(output);返回：<br>weChat<br> is excellent.\xa0'
            '去掉"&"的返回是转义为：<br>weChat<br> is excellent.另外，你也可以用{{{ '
            '}}}代替{{&}}。\xa0⑶\xa0若是对象，还能声明其属性var data = {              "name" '
            ': {              "first" : "Chen"，              "last" : '
            '"Jackson"              }，              "age" : 18         };var '
            'output = Mustache.render(           "name:{{name.first}} '
            '{{name.last}}，age:{{age}}", '
            'data);console.log(output);返回：name:Chen Jackson，age:18\xa0'
            '2、{{#keyName}} '
            '{{/keyName}}以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似if、foreach的功能。var '
            'data = {    "stooges" : [ {        "name" : "Moe"    }， {        '
            '"name" : "Larry"    }， {        "name" : "Curly"    } ]};var '
            'output = '
            'Mustache.render("{{＃stooges}}<b>{{name}}</b>{{/stooges}}"，                 '
            'data);console.log(output);返回：<b>Moe</b><b>Larry</b><b>Curly</b>3、{{^keyName}} '
            '{{/keyName}}该语法与{{#keyName}} {{/keyName}}类似，不同在于它是当keyName值为null, '
            'undefined, false时才渲染输出该区块内容。比如：var data = {             "name" : '
            '"<br>weChat<br>"         };    var tpl = ‘{{^nothing}}没找到 nothing '
            '键名就会渲染这段{{/nothing}}’;    var output = Mustache.render(tpl, '
            'data);返回：没找到\xa0nothing\xa0键名就会渲染这段\xa04、{{.}}\xa0\xa0\xa0\xa0'
            '{{.}}表示枚举，可以循环输出整个数组，例如：var data = {    "product": ["Macbook '
            '","iPhone ","iPod ","iPad "]}var tpl = \'{{#product}} '
            "<p>{{.}}</p> {{/product}}';var html = Mustache.render(tpl, "
            'data);返回：<p>Macbook </p> <p>iPhone </p> <p>iPod </p> <p>iPad '
            '</p>\xa05、{{! \xa0'
            '}}表示注释6、{{>partials}}以>开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。',
 'pub_time': '2016-10-23 12:36',
 'title': '有渔微信小程序技术分析《五》Mustache语法要点总结 '}
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-136-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-139-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-140-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-138-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-136-1.html>
{'author': '天下雪',
 'content': '小程序开发框架提供丰富的API，可以方便地调用微信提供的功能，比如获取用户信息，本地存储，微信支付等功能。目前，小程序的API分成下面几个大类：网络、媒体、数据、位置、设备、界面、开放接口。小程序API的具体参考文档：\xa0\xa0\xa0\xa0'
            'https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=1476197491659\xa0'
            '看千遍，不如自己做一遍。做一遍后，就能更加深刻地认识小程序的某个API，然后举一反三，通过查询腾讯的API文档，就能掌握其他API了。好了，下面开始干活。\xa0\xa0\xa0\xa0'
            '1、wx.requestwx.request发起的是https请求。一个微信小程序，同时只能有5个网络请求连接。wx.request的参数如下：参数类型是否必填说明urlString是开发者服务器接口地址dataObject、String否请求的参数headerObject否设置请求的\xa0'
            'header , header\xa0中不能设置ReferermethodString否默认为\xa0'
            'GET，有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, '
            'CONNECTsuccessFunction否收到开发者服务成功返回的回调函数，res = {data: '
            "'开发者服务器返回的内容'}failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）\xa0"
            '我们请求这个restful '
            'API：http://news-at.zhihu.com/api/4/news/latest，然后把数据显示出来。⑴\xa0'
            '我先用postMan测试下这个restful API，看下显示的数据是什么？⑵\xa0'
            '在app.js中添加一个getHttpRequest()函数。getHttpData: function(){    return '
            '“测试wx.request”},⑶\xa0index.js的onLoad()函数修改成：onLoad: function () '
            '{    var that = this    var httpData = app.getHttpData()    '
            'that.setData({username:httpData})}\xa0 \xa0 \xa0⑷\xa0'
            '编译后，能看到如下界面：\xa0 \xa0 \xa0⑸\xa0'
            '我们把getHttpData的代码进行升级，如下所示：getHttpData: function(callback){    '
            "wx.request({    url: 'http://www.yangfuhai.com/api',    data: "
            "{      x: '' ,      y: ''    },    header: {      'Content-Type': "
            "'application/json'    },    success: function(res) {      "
            'callback(res.data)    }    })}⑹\xa0index.js的onLoad()函数修改成：onLoad: '
            'function () {    var that = this    '
            'app.getHttpData(function(data){        '
            'console.log(data.date)        '
            'that.setData({username:data.date})    })}\xa0 \xa0 \xa0⑺\xa0'
            '编译后，能看到如下界面：\xa0 \xa0 \xa0⑻\xa0'
            '把that.setData({username:data.date})修改成：that.setData({username:data.stories[0].title})\xa0 \xa0 \xa0'
            '编译后，看到如下界面：\xa0 \xa0 \xa0'
            '在前面的例子中，data.stories返回的是个数组列表，我们通过data.stories[0].title得到了数组的第1个对象的title。现在让我们回顾下小程序的渲染功能，用wx:for把data.stories循环地列出来。⑴\xa0'
            'index.wxml里添加如下代码：  <view wx:for="{{items}}">    {{index}}: '
            '{{item.title}}  </view>⑵\xa0index.js的onLoad()函数修改成：  onLoad: '
            'function () {    var that = this    '
            'app.getHttpData(function(data){        '
            'that.setData({items:data.stories})    })  }\xa0 \xa0 \xa0'
            '编译后，看到如下界面：',
 'pub_time': '2016-10-23 12:42',
 'title': '有渔微信小程序系统概述《六》小程序的API '}
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-139-1.html>
{'author': '天下雪',
 'content': '在微信小程序中想要实现下拉刷新，是很方便的。但是如何使用，在文档上找起来却不是很方便。话不多说，直接上文档截图\r\n'
            '很明显，enablePullDownRefresh '
            '这个属性设置为true。就默认开启了下拉刷新。enablePullDownRefresh可以 写在app.json 中 '
            '和页面的***.jsonapp.json\xa0\r\n'
            '***.json\r\n'
            '两者的区别是，app.json 是全局型的下拉刷新，而***.json '
            '是单个页面的下拉刷新，只能设置window相关的配置项，以决定本页面的窗口表现，所以无需写window这个键。\xa0 '
            '剩下的就是监听下拉刷新了，直接上代码。\r\n'
            '\xa0 \xa0wx.stopPullDownRefresh() 是隐藏下拉刷新动画icon。剩下的就是下拉刷新后你要写的逻辑了',
 'pub_time': '2016-10-24 11:20',
 'title': '微信小程序 原生实现下拉刷新 '}
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-140-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-138-1.html>
{'author': '天下雪',
 'content': '最终效果图：\xa0'
            '样式丑哭了，我毕竟不是前端，宗旨就是练练手，体验微信小程序的开发，以最直接的方式获取12306数据查询火车票。\xa0'
            '目录结构：search1是出发站列表，search2是目的站列表，命名没有太好好想。\xa0'
            '车站信息12306查询页面，打开浏览器开发者工具分析请求，发现各个车站的信息都在这个JS文件中：当然车站的信息会发生变动，所以最好的方式就是抓取数据，我现在为了方便，直接把数据拷贝过来，就是一大堆字符串：通过正则截取出目前项目需要的两个东西，如：北京北 '
            'VAP\xa0'
            '在search1.js和search2.js中各自放了这个字符串，本想按照data:{}的方式放在app.js中，可是取不到，这个该如何实现？\xa0'
            '请求信息12306查询页面，点击查询按钮的时候，它会发送两个请求：第一个是日志请求，这里不需要，它有什么作用12306知道第二个才是我们需要的，拷贝它的请求地址，构建我们程序的请求url中最后的queryC，之前是query的，可能过段时间变为queryD、query0...\xa0'
            '又一个变化的地方，也可以说处处皆会变化，毕竟12306不是自己做的，无法掌控，所以最好还是抓取数据的方式来做，我现在方便直接写死了。leftTicketDTO.train_date \xa0'
            '日期，格式：2016-10-13leftTicketDTO.from_station \xa0'
            '出发站编码，上面那堆车站信息中的，北京北为VAPleftTicketDTO.to_station \xa0'
            '目的站编码，同上purpose_codes \xa0普通（ADULT）或学生（0X00）\xa0'
            '响应信息参数错误或没给全返回的JSON：{"status":false,"c_url":"leftTicket/queryC","c_name":"CLeftTicketUrl"}一般正常的格式为：要是提交的是昨天的日期，则messages中会有消息，但status和httpstatus仍然为true和200。于是乎对返回结果有了如下判断：\xa0\xa0'
            '展示信息\xa0先看看data中的有什么东东：用到的参数，能够确认其作用的：车次 station_train_code始发站 '
            'start_station_name终点站 end_station_name出发站 from_station_name目的站 '
            'to_station_name出发时间 start_time目的时间 arrive_time历时时间 lishi商务座 '
            'swz_num一等座 zy_num二等座 ze_num软卧 rw_num硬卧 yw_num软座 rz_num硬座 yz_num无座 '
            'wz_num特等座 '
            'tz_numgr_num和qt_num，猜测为高级软卧和其他，gg_num和yb_num就实在想不到了。需要注意的是，座位的票数超过某个数的返回值是“有”，而低于则返回的是数字，所以在显示数据列表之前还得处理下。\xa0\xa0'
            '在写程序的时候我发现我有挺多想法想写出来的，可到真正要写博客的时候却想不出要写什么了，悲哀！日后想到在补充吧。附上源码：http://pan.baidu.com/s/1hrKWRac或者直接下载：TrainTicket.rar',
 'pub_time': '2016-10-24 11:15',
 'title': '微信小程序实战教程：火车票查询，直取12306数据 '}
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=225)
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-26-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-141-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:01 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-26-1.html>
{'author': 'qq515373375',
 'content': '1条件渲染：小程序：用 wx:if="{{condition}}" 来判断是否需要渲染该代码块。<view '
            'wx:if="{{condition}}">\u3000\u3000\u3000\u3000True</view>ng2: \xa0'
            '用 *ngIf="condition"来判断是否需要渲染该代码块。<p \xa0'
            '*ngIf="condition">\u3000\u3000\u3000\u3000condition is true and '
            'ngIf is true.</p>对于ng2, '
            '当=号里面的值为真时才渲染标签内的元素，为假时将元素移除。注意：这里是将元素从DOM树里面完全移除，而不是隐藏。 '
            '对于需要频繁切换可见性的元素来说，改变元素的display无疑要比频繁的移除和重新渲染高效的多。 '
            '不过，angulra2开发者认为，在大多数 '
            'UI中，当我们“关闭”一个组件时，在相当长时间内都不大可能想再见到它——可能永远也不见。 '
            '而且，当我们隐藏掉一个元素时，组件的行为还在继续——它仍然附加在它所属的 DOM 元素上， 它也仍在监听事件。 Angular '
            '会继续检查哪些能影响数据绑定的变更。 组件原本要做的那些事情仍在继续。 虽然不可见，组件及其各级子组件仍然占用着资源。 \xa0'
            '虽然每种方法都有各自的优点和缺点，但使用 ngIf '
            '来移除不需要的组件通常都会比隐藏它们更好一些。微信小程序文档较少，不过根据文档中这段话：一般来说，wx:if 有更高的切换消耗而 '
            'hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 '
            'wx:if 较好可以推测wx:if和*ngIf实质是一样的，虽然在写法上有些区别，wx是将条件包裹在{{ condition '
            '}}里面。\xa02 '
            '循环列表渲染小程序：列表渲染：默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item<view '
            'wx:for="{{items}}">\u3000\u3000{{index}}: '
            '{{item}}</view>如某个数组为[a,b,c,d]，则对应的下标index为0,1,2,3，对应的变量名item为a,b,c,d使用wx:for-item可以指定数组当前元素的变量名；使用wx:for-index可以指定数组当前下标的变量名；如： '
            '<view wx:for="{{array}}" wx:for-index="idx" '
            'wx:for-item="itemName">\u3000\u3000\u3000\u3000 \xa0{{idx}}: '
            '{{itemName.message}}\xa0 \xa0 \xa0 </view>则此时下标idx为0,1,2,3, '
            '变量名itemName为a,b,c,dng2:<div *ngFor="let hero of heroes; let '
            'i=index">\u3000\u3000\u3000\u3000{{i + 1}} - '
            '{{hero.fullName}}</div>ng2里指定变量名用的是let hero of '
            'heroes，即设置变量名为hero，对应微信的 wx:for-item="itemName；指定下标let \xa0'
            'i=index，对应微信的wx:for-index="idx";上面这种写法实际上已经经过语法糖包装后的写法，原来的写法太啰嗦，形似类似：\xa0'
            '<template ngFor let-item [ngForOf]="items" let-i="index" '
            '[ngForTrackBy]="trackByFn">\u3000\u3000\u3000\u3000'
            '<li>...</li></template>\xa03数据绑定微信：数据绑定使用 Mustache '
            '语法（双大括号）将变量包起来\u3000\u3000\u3000\u3000<view> {{ message }} '
            '</view>并在js文件里面设置对应的变量值Page({\u3000\u3000data: '
            "{\u3000\u3000\u3000\u3000message: 'Hello MINA!'\u3000\u3000"
            '}})微信小程序没有双向数据绑定，要改变变量值时，需要通过setdata改变，监听事件如eventname: '
            'function(e) {\u3000\u3000this.setData({\u3000\u3000\u3000\u3000'
            'data: "im_new"\u3000\u3000})}注意不能这样this.data="im_new"，否则会出错\xa0'
            'ng2:ng2:主要看一下双向数据绑定：<input '
            '[(ngModel)]="currentHero.firstName">（123）表示绑定事件，[12345]表示绑定数据通过[( '
            ')]即可实现双向数据绑定这是种简写的形式，背后是这样写的<input\u3000\u3000\u3000\u3000'
            '[ngModel]="currentHero.firstName"\u3000\u3000\u3000\u3000'
            '(ngModelChange)="currentHero.firstName=$event">',
 'pub_time': '2016-10-13 18:30',
 'title': 'anjular2和微信小程序的对比 '}
2019-07-25 14:25:01 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-142-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-27-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-141-1.html>
{'author': '天下雪',
 'content': '一：toast组件toast消息提示框，可用在提示一些信息，比如清楚缓存给用户一个友好的提示！或操作一些请求不想让用户有什么操作，toast也可以做到因为toast显示时其他操作是无效的主要属性：wxml<!----><button '
            'type="primary" '
            'bindtap="listenerButton">显示loading</button><!--默认隐藏--><loading '
            'hidden="{{hiddenLoading}}">正在加载</loading>jsPage({  data:{    // '
            'text:"这是一个页面"    hiddenToast: true  },/** * 监听button点击事件 */  '
            'listenerButton: function() {      this.setData({          '
            'hiddenToast: !this.data.hiddenToast      })  },  /**   *    '
            'toast显示时间到时处理业务    */  toastHidden:function(){      '
            'this.setData({          hiddenToast: true      })  },  '
            'onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  '
            'onReady:function(){    // 页面渲染完成  },  onShow:function(){    // '
            '页面显示  },  onHide:function(){    // 页面隐藏  },  '
            'onUnload:function(){    // 页面关闭  '
            '}})二：loading组件loading通常使用在请求网络数据时的一种方式，通过hidden属性设置显示与否主要属性：wxml<!----><button '
            'type="primary" '
            'bindtap="listenerButton">显示loading</button><!--默认隐藏--><loading '
            'hidden="{{hiddenLoading}}">正在加载</loading>jsPage({  data:{    // '
            'text:"这是一个页面"    hiddenLoading: true  },  /**   * 监听button点击事件   '
            '*/  listenerButton:function(){      this.setData({          '
            'hiddenLoading: !this.data.hiddenLoading      })  },  '
            'onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  '
            'onReady:function(){    // 页面渲染完成  },  onShow:function(){    // '
            '页面显示  },  onHide:function(){    // 页面隐藏  },  '
            'onUnload:function(){    // 页面关闭  '
            '}})三：navigator组件navigator跳转分为两个状态一种是关闭当前页面一种是不关闭当前页面。用redirect属性指定。主要属性：wxml<navigator '
            'url="../index/index">点击跳转不关闭当前页面</navigator><navigator '
            'url="../logs/logs" redirect="true" >点击跳转关闭当前页面</navigator>',
 'pub_time': '2016-10-24 12:35',
 'title': '微信小程序把玩《八》：toast组件，loading组件，navigator组件 '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-24-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-142-1.html>
{'author': '天下雪',
 'content': '一：audio组件音频播放已经封装的很好！只需配合属性设置即可！ '
            '（method和data配合使用）主要属性：wxml<!--监听button点击事件--><button '
            'bindtap="listenerButton">点击显示视频组件</button><!--视频组件src资源地址，binderror为监听错误信息--><video     '
            'src="http://mvvideo1.meitudata.com/575c2b652d7375255.mp4"    '
            'style="width: 100%; height: 100%"    hidden="{{hiddenVideo}}"    '
            'binderror="listenerVideo" />jsPage({  data:{    // '
            'text:"这是一个页面"    hiddenVideo: true  },  /**   * 监听视频加载错误状态   */  '
            'listenerVideo:function(e) {      console.log(e.detail.errMsg);  '
            '},  /**   * 监听button点击事件   */  listenerButton:function() {      '
            'this.setData({          hiddenVideo: !this.data.hiddenVideo      '
            '})  }})二：image组件image组件也是一个程序不可缺少的，可以这样说一个app中image组件随处可以看到，一般 '
            'image有两种加载方式第一种是网络图片第二种是本地图片资源，都用src属性去指定。重点属性：三种缩放模式九种剪切方式wxml<!--3中是缩放模式    '
            'scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满image元素    aspectFit   '
            '保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。    aspectFill  '
            '保持纵横比缩放图片，只保证图片的短边能完全显示出来--><view>aspectFit '
            '保持纵横比缩放图片，只保证图片的短边能完全显示出来</view><image style="width: 100%; '
            'height:100%" mode="aspectFit" '
            'src="../../image/image.jpg"/><!--9种是裁剪模式    top '
            '不缩放图片，只显示图片的顶部区域    bottom,同上    left    right    top right    '
            'top left    bottom right    bottom left--><view>bottom '
            '不缩放图片，只显示图片的底部区域</view><image style="width: 100%; height: 100%" '
            'mode="bottom" src="../../image/image.jpg"/><view>left '
            '不缩放图片，只显示图片的左边区域</view><image style="width: 100%; height: 100%" '
            'mode="left" src="../../image/image.jpg"/><view>top right '
            '不缩放图片，只显示图片的右上边区域</view><image style="width: 100%; height: 100%" '
            'mode="top right" '
            'src="../../image/image.jpg"/>三：video组件视频播放组件与图片加载组件也没啥差别，使用起来也没啥注意的重要属性：wxml<!--监听button点击事件--><button '
            'bindtap="listenerButton">点击显示视频组件</button><!--视频组件src资源地址，binderror为监听错误信息--><video     '
            'src="http://mvvideo1.meitudata.com/575c2b652d7375255.mp4"    '
            'style="width: 100%; height: 100%"    hidden="{{hiddenVideo}}"    '
            'binderror="listenerVideo" />jsPage({  data:{    // '
            'text:"这是一个页面"    hiddenVideo: true  },  /**   * 监听视频加载错误状态   */  '
            'listenerVideo:function(e) {      console.log(e.detail.errMsg);  '
            '},  /**   * 监听button点击事件   */  listenerButton:function() {      '
            'this.setData({          hiddenVideo: !this.data.hiddenVideo      '
            '})  }})',
 'pub_time': '2016-10-24 15:35',
 'title': '微信小程序把玩《九》：audio组件，image组件，video组件 '}
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-27-1.html>
{'author': 'qq515373375',
 'content': '先简单说一下，小程序的结构如图所示1、每个视图(.wxml)只需要添加对应名字的脚本（.js）和样式（.wxss）就可以了，不需要引用，page下面的脚本以及样式都是继承至最外面的app.js '
            ', app.wxcss2、脚本也就是.js文件，他有固定格式：page，是用于获取数据的3、utils是用来放置数据接口的\xa0'
            '数据访问，如果懂点ajax，都不是问题，没啥好讲的微信小程序，因为IDE太烂了，如果代码再写得难以阅读，整个项目就很难维护了。因为没有写过app，不知道在app中数据访问是怎么封装的作为一个有3天工作经验的小程序码农，觉得如果每个页面的数据都是自己去访问数据接口，那就太不OOP了然后想到了linq '
            'to '
            'sql，只取了其中的两个方法，原本打算用singelordefault，firstordefault的，想想也麻烦，就用了getbyparams,getbyid，根据条件查找出所有数据，或者根据id获取一条数据直接看方法吧，有点啰嗦了const '
            "API_URL = 'http://localhost:4424/api/'function "
            'getApi(url,params){\xa0 return new Promise((res,rej)=>{\xa0 \xa0 '
            "wx.request({\xa0 \xa0 \xa0 url:API_URL+'/'+url,\xa0 \xa0 \xa0 "
            'data:Object.assign({},params),\xa0 \xa0 \xa0 '
            "header:{'Content-Type': 'application/json'},\xa0 \xa0 \xa0 "
            'success:res,\xa0 \xa0 \xa0 fail:rej\xa0 \xa0 })\xa0 '
            '})}module.exports = {\xa0 '
            "GetByParams(url,page=1,pageSize=20,search = ''){\xa0 \xa0 const "
            'params = { start: (page - 1) * pageSize, pageSize: pageSize '
            '}\xa0 \xa0 return getApi(url, search ? Object.assign(params, { q: '
            'search }) : params)\xa0 \xa0 \xa0 .then(res => res.data)\xa0 '
            '},\xa0 GetById(url,id){\xa0 \xa0 return getApi(url, '
            'id)\xa0 \xa0 \xa0 .then(res => res.data)\xa0 }}module.exports = '
            '{}是固定写法，里面写一个一个的方法，每个方法用,隔开。我设置了一个url参数，因为不可能把所有的接口都放在一个conntroller里面，所以url的格式是“conntroller/action”看一个调用的栗子吧，就明白怎么用了const '
            "req = require('../../utils/util.js')Page({\xa0 data: {\xa0 \xa0 "
            'imgUrls: [],\xa0 \xa0 indicatorDots: true,\xa0 \xa0 autoplay: '
            'true,\xa0 \xa0 interval: 2000,\xa0 \xa0 duration: 2000\xa0 },\xa0 '
            "onLoad(){\xa0 \xa0 req.GetByParams('home/homebanner')//看这里 \xa0 "
            '看这里 \xa0 看这里\xa0 \xa0 '
            '.then(d=>this.setData({imgUrls:d,loading:false}))\xa0 \xa0 '
            '.catch(e=>{\xa0 \xa0 \xa0 '
            'this.setData({imgUrls:[],loading:false})\xa0 \xa0 })\xa0 '
            "}})这是index的获取banner图的方法，req.GetByParams('home/homebanner')，这里也可以带参数，也可以空着最终的页面是这样的在右边的红色框里面，我们可以看到请求返回的数据，也可以在右边修改数据，界面会跟随着变化，这是关于调试的事情了",
 'pub_time': '2016-10-13 18:34',
 'title': '微信小程序的数据访问 '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-25-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-143-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=229)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-24-1.html>
{'author': '天下雪',
 'content': '今天，我们都想学前端！！！1、HTML基础入门带你从最最基础的知识开始，认识 HTML，通过 HTML '
            '文件的结构、常用的标签、元素、属性、样式、超文本等内容让大家对 HTML '
            '有一个完整的认识！2、HTML5基础入门HTML5有很多新特性，这个教程就带你入门了解HTML5的一些新特性。我们知道啊：html是结构 '
            '（网页一个架子，显示内容）、css是样式（添加背景图片，边框等来修饰）、js是行为（用户操作，华丽的动画）所以呢，光学HTML肯定是不够滴，还需要学习css和js才行啊。3、CSS速成教程这个教程啊，就是带你入门学习CSS知识的，让你对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。4、Javascript基础这个教程呢，是教你学习 '
            'JavaScript 的语法及事件、对象、DOM '
            '等基础知识，可以让网页按照你的想法“动”起来。以上呢，是基础，基础打牢了才能动手开发呀，但是，光有理论基础是不够的，还需要在实际开发“小程序”之前，做一些项目，练练手，把所学到的基础知识加以运用！5、HTML5两步实现拼图游戏这个项目就是教你使用HTML5和css3实现的九宫格拼图游戏。做出来是这样的：6、SCSS（SASS）画小黄人这个项目呢，教你通过 '
            'SCSS（SASS）画一个会眨眼睛的小黄人，主要学习 '
            'CSS3。画出来是这样的：7、JavaScript实现玫瑰花这个项目呢，主要是教你用JavaScript语言实现一朵漂亮的玫瑰花。实现出来是这样的：',
 'pub_time': '2016-10-13 18:06',
 'title': '微信小程序开发准备：必修课程推荐 '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-28-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-25-1.html>
{'author': 'qq515373375',
 'content': '背景有幸参加微信小程序的内测，由于公司之前已经有自己的服务大号，积累转化了大量的会员所以在做小程序时，要实现会员的互通，想到的是 '
            'unionid\xa0'
            '开发文档wx.login(OBJECT)调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid）\xa0'
            '及本次登录的\xa0'
            '会话密钥（session_key）参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=1474887500719wx.getUserInfo(OBJECT)获取用户信息，需要先调用\xa0'
            'wx.login\xa0'
            '接口其中需要的unionid在调用成功返回的参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html?t=1474887500618是个加密数据，解密算法参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html\xa0'
            '实现code 换取 session_key前端先调 wx.login 得到code后端换取session_key和openid， '
            'openid返回前端，session_key保存（缓存）解密用注意：一个code只能换取一次；再次调用\xa0wx.login， '
            '会导致上一次的 session_key 失效，解密出来的都是乱码\u3000\u30002.\xa0解密前端先调 '
            'wx.getUserInfo\xa0得到encryptData用login返回的openid，encryptData '
            '调后端解密刚开始按开发文档，用C# '
            '系统自带AES解密失败报“填充无效，无法被移除”异常在网上扒拉了一圈，也没找到有用的信息，最终在github上，找带了参考代码，自己再改改，才解密成功结语代码本身没啥牛逼的，希望贴出来能对后面的开发伙伴有所帮助 '
            ':)',
 'pub_time': '2016-10-13 18:24',
 'title': '微信小程序用户信息解密 C# '}
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-143-1.html>
{'author': '天下雪',
 'content': '一：wx.request(object) API这里通过干活集中营的API接口真实请求下数据。如果提示URL 域名不合法，请在 '
            'mp 后台配置后重试修改asdebug.js两行代码即可可看下面图定位到asdebug.js文件打开搜索关键字URL '
            '域名不合法关键字就是提示错误信息注释两行代码主要方法：wxml<button type="primary" '
            'bindtap="listenerButtonDownLoadFile">下载图片</button><image '
            'src="{{resource}}" style="width:100%; height: 80%"/>jsPage({  '
            'data:{    // text:"这是一个页面"    resource: \'\'  },  '
            'onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  '
            '/**   * 下载文件   */  listenerButtonDownLoadFile: function() {      '
            'var that = this;      wx.downloadFile({          url: '
            "'https://t2.27270.com/uploads/tu/201609/240/1mb2dybkw2x.jpg',          "
            "type: 'image',          success:function(res){              "
            'console.log(res.tempFilePath);              '
            'that.setData({                  resource: '
            'res.tempFilePath,              })          },          '
            'fail:function(err){              console.log(err)          '
            '},          complete:function(e) {              '
            'console.log(e)          }      })  }})二：wx.uploadFile(object), '
            'wx.downloadFile(object) '
            'API反正我是没有测通这两个API！！！！不知道用的方式不对还是其他的！！！先记录下回头再说。。。主要方法：wx.uploadFile(OBJECT)上传wx.downloadFile(OBJECT)下载wxml<button '
            'type="primary" '
            'bindtap="listenerButtonDownLoadFile">下载图片button>\r\n'
            '\r\n'
            '<image src="{{resource}}" style="width:100%; height: '
            '80%"/>123123jsPage({\r\n'
            '  data:{\r\n'
            '    // text:"这是一个页面"\r\n'
            "    resource: ''\r\n"
            '  },\r\n'
            '  onLoad:function(options){\r\n'
            '    // 页面初始化 options为页面跳转所带来的参数\r\n'
            '  },\r\n'
            '  /**\r\n'
            '   * 下载文件\r\n'
            '   */\r\n'
            '  listenerButtonDownLoadFile: function() {\r\n'
            '      var that = this;\r\n'
            '      wx.downloadFile({\r\n'
            '          url: '
            "'https://t2.27270.com/uploads/tu/201609/240/1mb2dybkw2x.jpg',\r\n"
            "          type: 'image',\r\n"
            '          success:function(res){\r\n'
            '              console.log(res.tempFilePath);\r\n'
            '              that.setData({\r\n'
            '                  resource: res.tempFilePath,\r\n'
            '              })\r\n'
            '          },\r\n'
            '          fail:function(err){\r\n'
            '              console.log(err)\r\n'
            '          },\r\n'
            '          complete:function(e) {\r\n'
            '              console.log(e)\r\n'
            '          }\r\n'
            '      })\r\n'
            '  }\r\n'
            '})',
 'pub_time': '2016-10-24 15:48',
 'title': '微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object) '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-33-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-28-1.html>
{'author': 'qq515373375',
 'content': '选择图片时可设置图片是否是原图，图片来源。这用的也挺常见的，比如个人中心中设置头像，可以与wx.upLoadFile()API使用主要方法：wx.chooseImage(object)wxml<button '
            'type="primary" '
            'bindtap="listenerButtonChooseImage">点击我选择相册button><image '
            'src="{{source}}" mode="aspecFill" style="width: 640rpx; height: '
            '640rpx"/>jsPage({ \xa0data:{ \xa0 \xa0// text:"这是一个页面" \xa0 \xa0'
            "source: '' \xa0}, \xa0/** \xa0 * 选择相册或者相机 配合上传图片接口用 \xa0 */ \xa0"
            'listenerButtonChooseImage: function() { \xa0 \xa0 \xa0var that = '
            'this; \xa0 \xa0 \xa0wx.chooseImage({ \xa0 \xa0 \xa0 \xa0 \xa0'
            'count: 1, \xa0 \xa0 \xa0 \xa0 \xa0'
            '//original原图，compressed压缩图 \xa0 \xa0 \xa0 \xa0 \xa0sizeType: '
            "['original'], \xa0 \xa0 \xa0 \xa0 \xa0//album来源相册 "
            "camera相机 \xa0 \xa0 \xa0 \xa0 \xa0 sourceType: ['album', "
            "'camera'], \xa0 \xa0 \xa0 \xa0 \xa0"
            '//成功时会回调 \xa0 \xa0 \xa0 \xa0 \xa0success: function(res) '
            '{ \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            '//重绘视图 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            'that.setData({ \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            'source: res.tempFilePaths \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0'
            '}) \xa0 \xa0 \xa0 \xa0 \xa0} \xa0 \xa0 \xa0}) \xa0'
            '},wx.previewImage(object)这又是一个奇葩API真实搞不懂怎么用这个。先模仿下官方咋使用但是没有效果，搞懂了在补充下自己的使用wxml<button '
            'type="primary" '
            'bindtap="listenerButtonPreviewImage">展示图片button>jsvar app = '
            'getApp()\u3000\u3000Page({\u3000\u3000\u3000\u3000data: '
            "{\u3000\u3000\u3000\u3000\u3000\u3000banner:['../images/big.png', "
            "'../images/big.png', "
            "'../images/big.png'],\u3000\u3000\u3000\u3000\u3000\u3000"
            'modalHidden: true\u3000\u3000\u3000\u3000'
            '},\u3000\u3000\u3000\u3000'
            'tapMove:function(e){\u3000\u3000\u3000\u3000\u3000\u3000'
            'this.setData({\xa0\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000'
            'num: e.detail.current+1\u3000\u3000\u3000\u3000\u3000\u3000'
            '})\u3000\u3000\u3000\u3000},/**\xa0 * 预览图片\xa0\xa0 '
            '*/\xa0\u3000\u3000listenerButtonPreviewImage: function() '
            '{\xa0 \xa0\u3000\u3000\u3000\u3000'
            'wx.previewImage({\xa0 \xa0 \xa0\u3000\u3000\u3000\u3000\u3000\u3000'
            'current: '
            "'../images/big.png',\xa0 \xa0 \xa0 \xa0 \u3000\u3000\u3000\u3000"
            '//这根本就不走\xa0 \xa0 \xa0 \xa0\u3000\u3000\u3000\u3000 success: '
            'function(res) {\xa0 \xa0 \xa0 \xa0 \xa0 \u3000\u3000\u3000\u3000'
            'console.log(res);\xa0 \xa0 \xa0 \xa0\u3000\u3000\u3000\u3000 '
            '},\xa0 \xa0 \xa0 \xa0 \u3000\u3000\u3000\u3000'
            '//也根本不走\xa0 \xa0 \xa0 \xa0\u3000\u3000\u3000\u3000 fail: '
            'function() {\xa0 \xa0 \xa0 \xa0 \xa0 \u3000\u3000\u3000\u3000'
            "console.log('fail')\xa0 \xa0 \xa0 \xa0\u3000\u3000\u3000\u3000 "
            '},\u3000\u3000\u3000\u3000\u3000\u3000'
            'complete:function(){\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000'
            "console.log('complete')\u3000\u3000\u3000\u3000\u3000\u3000"
            '}\xa0 \u3000\u3000\u3000\u3000\u3000\u3000 '
            '})\xa0\u3000\u3000\u3000\u3000\u3000\u3000},onLoad: function () '
            '{\xa0var that = '
            'this;that.setData({num:1,count:that.data.banner.length})}})',
 'pub_time': '2016-10-13 18:36',
 'title': '微信小程序之预览图片 '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-34-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-32-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-33-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-34-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-224-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-32-1.html>
{'author': '天下雪',
 'content': '什么是微信小程序工具破解开始教程DEMO展示iOS开发如何应对微信小程序热潮本文主要摘录微信小程序工具破解和第一个Hello '
            'World DMEO，其他内容可以从 “阅读原文” '
            '中获取什么是微信小程序及其学习价值微信小程序是一种全新的连接用户与服务的方式，可以在微信内被便捷地获取和传播，同时具有出色的使用体验。在微信的发现Tab中增加一个“小程序”入口，点开之后，会出现自己开启的小程序。来看下小程序提供哪些开发能力？视图容器：视图(View)、滚动视图、Swiper，图标、文本、进度条，按钮、表单等等操作反馈，导航媒体组件：音频、图片、视频，地图位置服务画布，文件操作能力网络：上传下载能力、WebSocket数据：数据缓存能力位置：获取位置、查看位置设备：网络状态、系统信息、重力感应、罗盘界面：设置导航条、导航、动画、绘图等等开放接口：登录，包括签名加密，用户信息、微信支付、模板消息一句话，App能做的事，它都能做，微信是通过weixin '
            'jssdk兑现这个承诺的。。小程序的体验和原生 app 几乎没有差异。。。（惊）工具破解开发工具 v0.7百度:\xa0'
            'https://pan.baidu.com/s/1pLxqFzH\xa0（密码: bwt9）360:\xa0'
            'https://yunpan.cn/ckvTYFHWzYYFV\xa0（提取码：e09b）开发工具 v0.9百度:\xa0'
            'https://pan.baidu.com/s/1pLTKIqJ\xa0（密码: iswg）360:\xa0'
            'https://yunpan.cn/ckvXjEbnFYMSC\xa0（提取码：f9ca）Demo源代码百度:\xa0'
            'https://pan.baidu.com/s/1o8hJFuU\xa0（密码: bsky）360:\xa0'
            'https://yunpan.cn/ckvXAacJjvsgR\xa0'
            '（提取码：3327）微信小程序开发文档：http://notedown.cn/weixin/api/\xa0'
            'Mac测试可用，Windows测试可用下载开发工具，并安装（注意：一定要安装0.9版本）打开『微信Web开发者工具』的程序目录Windows：使用资源管理器查看Mac：右键点击图标，选择『显示包内容』进入程序目录后，替换以下文件（只需要替换0.9版本里的，0.7版本用来登陆）：替换文件下载请戳原文链接enjoy开始运行『微信Web开发者工具』通过微信扫描二维码创建项目AppID：随便填项目名称：随便填本地开发目录：选择一个目录点击「添加项目」此时如果出错，先退出再重进此时，能够看到项目列表了打开项目开始开发enjoyDEMO创建项目打开项目所在目录下载「Demo源代码」并解压覆盖打开项目Good '
            'luck',
 'pub_time': '2016-10-14 11:25',
 'title': 'iOS程序员上手微信小程序指南：含demo及工具下载 '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-35-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-224-1.html>
{'author': '天下雪',
 'content': '下面是我初步探究所做的简单整理。开发工具下载目录结构我们在微信提供的开发工具中新建一个项目，开发工具会给我们建立一个最基本的目录结构和示例Demo代码，结构如下：结构很简单，程序主体部分由app.js,app.json,app.wxss三个文件组成，而且必须放在项目的根目录。页面由四个文件组成，分别是：文件类型作用必填js页面逻辑yeswxml页面结构yeswxss页面样式nojson页面配置no配置使用app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 '
            'tab 等。每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 '
            '页面的配置比app.json全局配置简单得多，只是设置\xa0app.json\xa0中的\xa0window\xa0'
            '配置项的内容，页面中配置项会覆盖\xa0app.json\xa0的\xa0window\xa0'
            '中相同的配置项。逻辑层1.注册程序App()\xa0函数用来注册一个小程序。接受一个 object '
            '参数，其指定小程序的生命周期函数等。示例：App({\r\n'
            '  onLaunch: function() {\r\n'
            '    // Do something initial when launch.\r\n'
            '  },\r\n'
            '  onShow: function() {\r\n'
            '      // Do something when show.\r\n'
            '  },\r\n'
            '  onHide: function() {\r\n'
            '      // Do something when hide.\r\n'
            '  },\r\n'
            "  globalData: 'I am global data'\r\n"
            '})2.注册页面Page()\xa0函数用来注册一个页面。接受一个 object '
            '参数，其指定页面的初始数据、生命周期函数、事件处理函数等。Page({\r\n'
            '  data: {\r\n'
            '    text: "This is page data."\r\n'
            '  },\r\n'
            '  onLoad: function(options) {\r\n'
            '    // Do some initialize when page load.\r\n'
            '  },\r\n'
            '  onReady: function() {\r\n'
            '    // Do something when page ready.\r\n'
            '  },\r\n'
            '  onShow: function() {\r\n'
            '    // Do something when page show.\r\n'
            '  },\r\n'
            '  onHide: function() {\r\n'
            '    // Do something when page hide.\r\n'
            '  },\r\n'
            '  onUnload: function() {\r\n'
            '    // Do something when page close.\r\n'
            '  },\r\n'
            '  onPullDownRefresh: function() {\r\n'
            '    // Do something when pull down\r\n'
            '  },\r\n'
            '  // Event handler.\r\n'
            '  viewTap: function() {\r\n'
            '    this.setData({\r\n'
            "      text: 'Set some data for updating view.'\r\n"
            '    })\r\n'
            '  }\r\n'
            '});3.模块化可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 '
            'exports 才能对外暴露接口。需要注意的是：exports\xa0是\xa0module.exports\xa0'
            '的一个引用，因此在模块里边随意更改\xa0exports\xa0的指向会造成未知的错误。所以我们更推荐开发者采用\xa0'
            'module.exports\xa0来暴露模块接口，除非你已经清晰知道这两者的关系。小程序目前不支持直接引入\xa0'
            'node_modules\xa0, 开发者需要使用到\xa0node_modules\xa0'
            '时候建议拷贝出相关的代码到小程序的目录中。4.API小程序开发框架提供丰富的微信原生 '
            'API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。5.ES6 转 '
            'ES5微信小程序运行在三端：iOS、Android 和用于调试的开发者工具在 iOS 上，小程序的 javascript '
            '代码是运行在 JavaScriptCore 中在 Android 上，小程序的 javascript 代码是运行在 X5 内核中在 '
            '开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome） '
            '中虽然三个运行环境在大部分情况下是相似的，但是还有一些细微的区别，为了帮助开发者解决这种区别带来的困扰，开发工具会自动帮助开发者将 '
            'ES6 的代码转为 ES5 '
            '的代码。对于使用其他构建工具的开发者，可以在项目也开中关掉这个功能，使用自己的构建和转码工具。视图层和我之前对微信小程序的直觉不同，微信小程序不支持也不兼容HTML，而是微信全新定义的规范，它的视图文件的后缀名为.wxml，是基于xml进行的扩展，其样式表文件也并非CSS，而是.wxss,兼容受限的部分CSS写法。视图渲染时，采用了类似单向数据绑定的方式进行数据绑定，WXML '
            '中的动态数据均来自对应Page的data。使用Mustache语法（双大括号）将变量包起来:<view> {{ message '
            '}} '
            '</view>框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。支持条件渲染、列表渲染、模板、事件WXSS(WeiXin '
            'Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。WXSS\xa0用来决定\xa0WXML\xa0'
            '的组件应该怎么显示。WXSS\xa0具有\xa0CSS\xa0大部分特性。 同时为了更适合开发微信小程序，我们对\xa0'
            'CSS\xa0进行了扩充以及修改。与 CSS '
            '相比我们扩展的特性有：尺寸单位样式导入框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。组件文档微信小程序官方文档传送门',
 'pub_time': '2016-11-1 11:13',
 'title': '【摘要】微信小程序初步探究简单整理 '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-31-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-226-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-35-1.html>
{'author': '天下雪',
 'content': '1应用号的真实名称叫「微信小程序」，而不是应用号。这个名字还是很可爱的。2小程序的开发文档是微信提供的所有开发文档里最详细最丰富的。3和我在《别开发 '
            'app 了》猜测的类似，微信不仅提供丰富的 '
            'API，还提供了足够多的框架和组建。你可以去回顾我的老文章。4接口和框架异常丰富，包括：视图、内容、按钮、导航、多媒体、网络能力、罗盘、重力感应、画板等。5有了这个框架和丰富的组件，小程序的启动和运行速度将可以和原生 '
            'app 媲美。能实现的功能也将被纯网页的服务号要多得多。6微信不仅提供了详细的文档，还提供了多平台的开发工具，包括 '
            'Mac、Linux、Windows。7小程序开发后，不能直接发布，需要经过审核，类似 App '
            'Store。这是好事。8微信除了提供开发文档，还提供了比服务号更详尽的设计规范，还有布局时会用到的控件。9不像完全基于网页的服务号，小程序将拥有缓存能力。想象一下这是多么美好的事。10会 '
            'Javascript 的工程师，将会越来越吃香。',
 'pub_time': '2016-10-15 01:46',
 'title': '微信小程序几个令人兴奋的细节 '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-227-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-31-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-226-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-225-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-227-1.html>
{'author': '天下雪',
 'content': '一：弹框组件modalmodalmodal类似于javascript中的confirm弹框，默认情况下是一个带有确认取消的弹框，不过点击取消后弹框不会自动隐藏，需要通过触发事件调用函数来控制hidden属性。官方文档.wxml<modal '
            'hidden="{{hidden}}" title="这里是title" confirm-text="自定义确定按钮" '
            'cancel-text="自定义取消按钮" bindcancel="cancel" bindconfirm="confirm" '
            'no-cancel="{{nocancel}}">\r\n'
            '    这是对话框的内容。\r\n'
            '</modal>.jsPage({\r\n'
            '    data:{\r\n'
            '        hidden:false,\r\n'
            '        nocancel:false\r\n'
            '    },\r\n'
            '    cancel: function(){\r\n'
            '        this.setData({\r\n'
            '             hidden: true\r\n'
            '        });\r\n'
            '    },\r\n'
            '    confirm: function(){\r\n'
            '        this.setData({\r\n'
            '             nocancel: !this.data.nocancel\r\n'
            '        });    \r\n'
            '        console.log("clicked confirm");\r\n'
            '    }\r\n'
            '})        '
            '运行效果二：底部菜单action-sheetaction-sheetaction-sheet是从底部弹出的选择菜单，子菜单通过action-sheet-item和action-sheet-cancel指定，action-sheet-item是菜单项，action-sheet-cancel顾名思义是取消隐藏菜单，我们可以通过为action-sheet-item添加bindtap来触发点击后作出的相应，点击action-sheet-cancel时会触发action-sheet的bindchange事件。可以在bindchange绑定的函数中控制菜单的显示。另外点击空白处时菜单也会隐藏。官方文档\xa0\xa0'
            '.wxml<button type="default" bindtap="actionSheetTap">弹出action '
            'sheet</button>\r\n'
            '<action-sheet hidden="{{actionSheetHidden}}" '
            'bindchange="actionSheetChange">\r\n'
            '    <block wx:for-items="{{actionSheetItems}}">\r\n'
            '        <action-sheet-item  '
            'bindtap="bind{{item}}">{{item}}</action-sheet-item>\r\n'
            '    </block>\r\n'
            '    <action-sheet-cancel >取消</action-sheet-cancel>\r\n'
            "</action-sheet>.jsvar items = ['item1', 'item2', 'item3', "
            "'item4']\r\n"
            'var pageObject = {\r\n'
            '  data: {\r\n'
            '    actionSheetHidden: true,\r\n'
            '    actionSheetItems: items\r\n'
            '  },\r\n'
            '  actionSheetTap: function(e) {\r\n'
            '    console.log(this);\r\n'
            '    this.setData({\r\n'
            '      actionSheetHidden: !this.data.actionSheetHidden\r\n'
            '    })\r\n'
            '  },\r\n'
            '  actionSheetChange: function(e) {\r\n'
            '    this.setData({\r\n'
            '      actionSheetHidden: !this.data.actionSheetHidden\r\n'
            '    });\r\n'
            '    '
            'console.log("点击ation-sheet-cancel，会触发action-sheet绑定的事件。在这里可以通过改变hidden控制菜单的隐藏");\r\n'
            '  }\r\n'
            '}\r\n'
            '\r\n'
            'for (var i = 0; i < items.length; ++i) {\r\n'
            '  (function(itemName) {\r\n'
            "    pageObject['bind' + itemName] = function(e) {\r\n"
            "      console.log('click' + itemName, e)\r\n"
            '    }\r\n'
            '  })(items[i])\r\n'
            '}\r\n'
            '\r\n'
            'Page(pageObject)运行效果如何让点击空白处时不隐藏图片呢？另外点击取消的时候自动隐藏菜单不就算了，非要自己写一句话让它隐藏，真麻烦。',
 'pub_time': '2016-11-1 12:00',
 'title': 'Acmen、L学习案例集锦《二》弹框组件modal，底部菜单action-sheet '}
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-225-1.html>
{'author': '天下雪',
 'content': '目标使用LeanCloud '
            'JS_SDK读取电商系统的商品分类准备在https://www.leancloud.cn上注册帐号，创建仓库，建Category表，建title字段无限级分类建表结构建立字段parent，类型为Pointer，指向Category对象下载JS_SDKhttps://unpkg.com/leancloud-storage@2.0.0-beta.2/dist/av-weapp.js文档出处：https://leancloud.cn/docs/weapp.html安装将上面的js文件保存此util目录使用在category.js中引入const '
            "AV = require('../../utils/av-weapp.js')连接数据仓库，取查询所有分类Page({\r\n"
            '    onLoad: function(){\r\n'
            '        AV.init({ \r\n'
            '        appId: "SgHcsYqoLaFTG0XDMD3Gtm0I-gzGzoHsz", \r\n'
            '        appKey: "xdv2nwjUK5waNglFoFXkQcxP",\r\n'
            '        });\r\n'
            "        var query = new AV.Query('Category');\r\n"
            '        query.find().then(function (categories) {\r\n'
            '            for (var i = 0; i < categories.length; i++) {\r\n'
            '                var category = categories[i];\r\n'
            '                console.log(category.attributes.title);\r\n'
            '            }\r\n'
            '        }).catch(function(error) {\r\n'
            '            alert(JSON.stringify(error));\r\n'
            '        });\r\n'
            '    }\r\n'
            '})\r\n'
            '这时控件台可以看到输出category所有分类潮流女装 连衣裙 针织开衫 羽绒服 时尚T恤 家用电器 电视 '
            "空调条件查询获得顶级分类query.equalTo('parent',null);\r\n"
            '这时控件台可以看到输出category顶级分类潮流女装 家用电器Pointer方式查询二级分类        // '
            '查询父级分类下的所有子类\r\n'
            "        var parent = AV.Object.createWithoutData('Category', "
            "'581415bf2e958a005492150b');\r\n"
            "        query.equalTo('parent',parent);\r\n"
            '这时控件台可以看到输出category潮流女装分类下的所有子类连衣裙\r\n'
            '针织开衫\r\n'
            '羽绒服\r\n'
            '时尚T恤\r\n'
            '配合布局与js文件，实现分类页面wxml:<view class="container">\r\n'
            '    <!-- 侧边栏 -->\r\n'
            '    赞赏 \n'
            '                             \n'
            '                 \n'
            '                邀请 \n'
            '               \n'
            '               \n'
            '               \n'
            '            \n'
            '             \n'
            '                         \n'
            '              \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鲜花                \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                鸡蛋                \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            'function errorhandle_clickhandle(message, values) {\r\n'
            "if(values['id']) {\r\n"
            'showCreditPrompt();\r\n'
            "show_click(values['idtype'], values['id'], values['clickid']);\r\n"
            '}\r\n'
            '}\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '            \n'
            '\n'
            '分享至 :\n'
            '\n'
            '\n'
            'QQ空间\n'
            '\n'
            'window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName(\'head\')[0]||body).appendChild(createElement(\'script\')).src=\'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=\'+~(-new '
            'Date()/36e5)];\n'
            '\n'
            '收藏\n'
            '\n'
            '             \n'
            '                         \n'
            '              一斤代码深入理解系列《四》：微信小程序和服务器通信-WebSocket ... ... \n'
            '              丛九九微信小程序demo实战教程：Bilibili排行榜 \n'
            '            \n'
            '             \n'
            '            \n'
            '                  原作者: 黄秀杰 \n'
            '                  来自: 授权地址 \n'
            '                   \n'
            '                   \n'
            '                              \n'
            '            \r\n'
            '    /*700*200 创建于 2017/12/12*/\r\n'
            '    var cpro_id = "u3158955";\r\n'
            '\r\n'
            ' \n'
            '            \n'
            '                        \n'
            '              \n'
            '                相关阅读\n'
            '              \n'
            '              \n'
            '                \n'
            '                                    \n'
            '                  • 秀杰实战教程系列《一》：记账应用开发\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《二》：微信小程序绘图课程之饼图\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《三》：下拉筛选菜单WXDropDownMenu组件\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《四》：倒计时组件，LXStepper组件-商品数量加减 ...\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《五》：实战课程之记账应用开发（续）\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《六》：服务端之用户注册与登录基于ThinkPHP5描述 ...\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《七》：实现购物车页面\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《八》：记账应用实战服务端之用户注册与登录基于Codeigniter3描述 '
            '...\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《九》：应用实例教程服务端登录篇\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《十》：服务端实现账目CRUD\n'
            '                                    \n'
            '                  • 秀杰实战教程系列《十一》：对接服务端账目CRUD\n'
            '                                    \n'
            '                  • leancloud：SDK 跨平台支持常见问题及解决方案实践\n'
            '                                    \n'
            '                  • 微信小程序取值传值方式小结\n'
            '                                    \n'
            '                  • Charlotte微信小程序开发（一）--数据存储\n'
            '                                  \n'
            '              \n'
            '            \n'
            '             \n'
            '            \n'
            '          \n'
            '           \n'
            '        \n'
            '      \n'
            '       \n'
            '       \n'
            '      \r\n'
            '   \r\n'
            '    0 条回复\r\n'
            '  \r\n'
            '   \r\n'
            '    \r\n'
            '     \r\n'
            '     \r\n'
            '    \r\n'
            '        \r\n'
            '      \r\n'
            '  \r\n'
            '\r\n'
            '        \r\n'
            '    \r\n'
            '     \r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '                \r\n'
            '\r\n'
            '\r\n'
            '\t\t\r\n'
            'updateseccode(\'cSCCF1Fc\', \'<sec> <span id="sec<hash>" '
            'onclick="showMenu(this.id);"><sec></span><div id="sec<hash>_menu" '
            'class="p_pop p_opt" style="display:none"><sec></div>\', '
            "'portal::view');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '发表回复\r\n'
            '                \r\n'
            '\r\n'
            '           \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '    \r\n'
            '\r\n'
            '   \r\n'
            '    \r\n'
            '        \r\n'
            '    jQuery(function(){\r\n'
            'jQuery("#tedt .pt").focus(function(){\r\n'
            '  jQuery(this).addClass("bgchange");\r\n'
            '}).blur(function(){\r\n'
            '  jQuery(this).removeClass("bgchange");\r\n'
            '});\r\n'
            '    });\r\n'
            '     \r\n'
            '\r\n'
            '    \r\n'
            '    \r\n'
            ' \n'
            '       \n'
            '       \n'
            '    \n'
            '  \n'
            '  \n'
            '    \r\n'
            '推荐教程\r\n'
            '\r\n'
            '\r\n'
            '当微信小程序遇上 '
            'TensorFlow：本地缓存模2019-07-03如何两步完成一个抽奖小程序2019-07-04马蜂窝旅游小程序2019-07-03Taro撸一个简版的微信读书小程序2019-07-05微信小程序打怪之定时发送模板消息(node版)2019-07-04我的第一个小程序：小程序与SEO2019-07-05开发 '
            '地图标记工具 '
            '后记2019-07-03微信小程序--wx.request封装和使用2019-07-03微信小程序-麦当劳点餐+爬虫2019-07-03\r\n'
            '\r\n'
            '\n'
            '     \n'
            '      \r\n'
            '最新Demo\r\n'
            '\r\n'
            '\r\n'
            '校园综合服务平台小程序2019-07-13一款适合全民朗读的音频小程序源码2019-07-01微信小程序作品-食堂供餐服务小程序2019-06-27农物小助手-AR扫病害2019-06-26微信公众平台登录小程序后台问题2019-06-26有人有用测试号开发的社区类或者论坛类源码2019-06-22小程序商城—自己开发的源码，有需要学习交2019-06-14微信小游戏坦克大战源码2019-06-12像企业介绍和产品介绍的小程序吗求个代码是2019-05-30\r\n'
            '\r\n'
            ' \n'
            '    \n'
            '  \n'
            '\n'
            '\n'
            '\n'
            ' \n'
            '   \n'
            '\n'
            '\n'
            ' \n'
            'jQuery(function() {\n'
            'jQuery("span").click(function() {\n'
            'var thisEle = jQuery("#article_content").css("font-size");\n'
            'var textFontSize = parseFloat(thisEle, 10);\n'
            'var unit = thisEle.slice( - 2);\n'
            'var cName = jQuery(this).attr("class");\n'
            'if (cName == "bigger") {\n'
            'if (textFontSize <= 22) {\n'
            'textFontSize += 2;\n'
            '}\n'
            '} else if (cName == "smaller") {\n'
            'if (textFontSize >= 12) {\n'
            'textFontSize -= 2;\n'
            '}\n'
            '}\n'
            'jQuery("#article_content").css("font-size", textFontSize + '
            'unit);\n'
            '});\n'
            '});\n'
            ' \n'
            ' \n'
            '     \n'
            '\n'
            '\r\n'
            '\r\n'
            '\n'
            '\n'
            '  \n'
            '     © 2019 极乐科技 | \n'
            '         鄂ICP备14019861号 |         鄂公网安备：42018502003797 | 网站地图\n'
            '         \n'
            '        \r\n'
            'var _hmt = _hmt || [];\r\n'
            '(function() {\r\n'
            '  var hm = document.createElement("script");\r\n'
            '  hm.src = '
            '"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b";\r\n'
            '  var s = document.getElementsByTagName("script")[0]; \r\n'
            '  s.parentNode.insertBefore(hm, s);\r\n'
            '})();\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '  '
            "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n"
            '  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new '
            'Date();a=s.createElement(o),\r\n'
            '  '
            'm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n'
            '  '
            "})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n"
            '\r\n'
            "  ga('create', 'UA-98020757-1', 'auto');\r\n"
            "  ga('send', 'pageview');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=(\'https:\'==document.location.protocol?\'https://\':\'http://\')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.growingio.com/2.1/gio.js","gio");\r\n'
            "  gio('init','874f0f6c4c3a4387', {});\r\n"
            '\r\n'
            '//custom page code begin here\r\n'
            '\r\n'
            '//custom page code end here\r\n'
            '\r\n'
            "gio('send');\r\n"
            '\r\n'
            '\r\n'
            '\r\n'
            '     \n'
            '   \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            '\n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            ' \n'
            '\n'
            '  \n'
            '\n'
            '\n'
            '\n'
            '返回顶部\n'
            '\n'
            '\n'
            'jQuery.noConflict();\n'
            'jQuery(function(){\n'
            '        //首先将#back-to-top隐藏\n'
            '        jQuery("#share").hide();\n'
            '        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n'
            '        jQuery(function () {\n'
            '            jQuery(window).scroll(function(){\n'
            '                if (jQuery(window).scrollTop()>100){\n'
            '                    jQuery("#share").fadeIn();\n'
            '                }\n'
            '                else\n'
            '                {\n'
            '                    jQuery("#share").fadeOut();\n'
            '                }\n'
            '            });\n'
            '            //当点击跳转链接后，回到页面顶部位置\n'
            '            jQuery("#totop").click(function(){\n'
            "                jQuery('body,html').animate({scrollTop:0},500);\n"
            '                return false;\n'
            '            });\n'
            '        });\n'
            '    }); \n'
            '\n'
            '\n'
            ' \n'
            ' \t\t\t\r\n'
            '\t\t\t\r\n'
            '\t\t\t\tvar tipsinfo = '
            "'9999|X3.2|0.6||0||0|7|1564035901|a90b34321588b537f2e0379c47091f31|2';",
 'pub_time': '2016-11-1 11:42',
 'title': '秀杰实战教程系列《十二》：基于LeanCloud实现访问网络与数据存储 ... '}
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-229-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-228-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:02 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-29-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=235)
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-229-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
2019-07-25 14:25:02 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-228-1.html>
{'author': '天下雪',
 'content': '一：加载中提示框loadingloadingloading只有一个属性hidden.wxml<view>\r\n'
            '    <loading hidden="{{hidden}}">\r\n'
            '        加载中...\r\n'
            '    </loading>\r\n'
            '    <button bindtap="changeHidden">show/hidden</button>\r\n'
            '</view>.jsPage({\r\n'
            '    data:{\r\n'
            '        hidden:true\r\n'
            '    },\r\n'
            '    changeHidden: function(){\r\n'
            '        this.setData({\r\n'
            '            hidden: !this.data.hidden\r\n'
            '        });\r\n'
            '    }\r\n'
            '})        '
            '效果当弹框出现后，点击除弹框外不可相应，所以再次点击button并不能隐藏弹框。二：消息提示框toasttoasttoast为消息提示框，无按钮，如需关闭弹框可以添加事件设置hidden为true，在弹框显示后经过duration指定的时间后触发bindchange绑定的函数。官方文档.wxml<view>\r\n'
            '     <toast hidden="{{hidden}}" duration="2500" bindchange="open" '
            'bindtap="close">\r\n'
            '        内容\r\n'
            '    </toast>\r\n'
            '</view>.jsPage({\r\n'
            '    data:{\r\n'
            '        hidden:false\r\n'
            '    },\r\n'
            '    open: function(){\r\n'
            '        console.log("延时调用");\r\n'
            '    },\r\n'
            '    close: function(){\r\n'
            '        this.setData({\r\n'
            '            hidden:true\r\n'
            '    });\r\n'
            '        console.log("关闭弹框");\r\n'
            '    }\r\n'
            '})效果三：navigator页面跳转navigatornavigator跳转页面样式分为两种一种是左上角带返回按钮跳转到新的页面，另一种不带即在本页跳转，通过控制redirect属性.js<view>\r\n'
            '    <navigator url="../other/other" '
            'hover-class="changestyle">页面跳转，可以返回</navigator>\r\n'
            '</view>\r\n'
            '<view>\r\n'
            '    <navigator url="../other/other" hover-class="changestyle" '
            'redirect>页面跳转，无法返回</navigator>\r\n'
            '</view>wxss.changestyle{\r\n'
            '    color: red;\r\n'
            '}效果',
 'pub_time': '2016-11-1 12:05',
 'title': 'Acmen、L学习案例集锦《三》加载中提示框loading，消息提示框toast，navigator页面跳 ... '}
2019-07-25 14:25:03 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-29-1.html>
{'author': 'qq515373375',
 'content': '「小程序」这个划时代的产品发布快一周了，互联网技术人都在摩拳擦掌，跃跃欲试。可是小程序目前还在内测，首批只发放了\r\n'
            ' 200 个内测资格（泪流满面）。本以为没有 AppID \r\n'
            '这个月就与小程序无缘了，庆幸的是微信这两天发布了正式版开发者工具，无需内测邀请也可以尝鲜了。\r\n'
            '因此也就有了我与「小程序」的初体验，而我的感受只有一个字——爽！\r\n'
            '选择哪个「小程序」Demo？\r\n'
            '在知名同性交友网站 Github 上，「小程序」的 Demo 不少，但是大多只是简单的 API '
            '演示，有的甚至直接把页面数据写在了 \r\n'
            'json 文件里（分明有网络请求 '
            'API）。我想体验的是能够将服务端和小程序端无缝连接起来（体验够爽）的项目。最终，我选择了腾讯云官方推出的「小相册」项目。\r\n'
            '「小相册」主要实现了以下功能：\r\n'
            '\r\n'
            '列出对象存储 COS 中的图片列表。\r\n'
            '\r\n'
            '点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 对象存储 COS 中。\r\n'
            '\r\n'
            '轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片。\r\n'
            '\r\n'
            '长按任意图片，可将其保存到本地，或从 对象存储 COS 中删除。\r\n'
            '\r\n'
            '效果演示图（受开发工具的限制，部分功能尚未实现）\r\n'
            '\r\n'
            '对象存储服务（Cloud Object '
            'Service）是腾讯云推出的面向企业和个人开发者提供的高可用，高稳定，强安全的云端存储服务。可以将任意数量和形式的非结构化数据放入COS，并在其中实现数据的管理和处理。\r\n'
            '\r\n'
            '之所以选择腾讯云的 '
            'Demo，一是因为它是腾讯自家推出的，项目的质量有保障；二是因为它是少有的既讲小程序开发，又介绍云端部署的项目。\r\n'
            '稍微有点经验的程序员都知道，架构要动静分离，静态文件最好不要放在自己的服务器上，要放在专门用来存储的对象存储服务器COS上，并且用CDN '
            '加速。「小相册」后端采用的是 Node.js，Nginx作为反向代理。\r\n'
            '第一步：搭开发环境\r\n'
            '首先，我们需要在本地搭建好微信「小程序」的开发环境。即下载开发者工具。微信官方已经推出了正式版 '
            'IDE，大家没有必要再去下载破解版了。打开官网下载页面，根据自己的操作系统选择。我使用的是 Mac 版。\r\n'
            '安装好之后打开运行，会要求微信扫码登陆。之后，就可以看到创建项目的页面了。\r\n'
            '\r\n'
            '选择添加项目，没有 AppID '
            '就选无（如果乱写会报错，到时可能无法进入项目）。如果你选择的项目目录为空，请如图所示勾选在“当前目录中创建quick '
            'start项目”。\r\n'
            '\r\n'
            '点击“添加项目”之后，我们会进入开发工具的调试页面。\r\n'
            '第二步：下载「小相册」源码\r\n'
            '接下来，我们下载「小相册」的源码。可以选择直接从腾讯云官网提供的链接下载，也可以从腾讯云团队的 Github 仓库拉取。我推荐从 '
            'Github 仓库拉取，这样可以及时获取最新的代码。\r\n'
            'git clone https://github.com/CFETeam/weapp-demo-album.git\r\n'
            '最终，我们会得到类似这样的文件目录。\r\n'
            '\r\n'
            '简单解释下目录结构：\r\n'
            '\r\n'
            'applet（或app）: 「小相册」应用包代码，可直接在微信开发者工具中作为项目打开。\r\n'
            '\r\n'
            'server: 搭建的Node服务端代码，作为服务器和app通信，提供 CGI '
            '接口示例，用于拉取图片资源、上传图片、删除图片。\r\n'
            '\r\n'
            'assets：「小相册」的演示截图。\r\n'
            '\r\n'
            '源码下载完成之后，我们打开微信 web 开发者工具，新建项目「小相册」，选择目录applet（或app）。\r\n'
            '\r\n'
            '「小相册」源码分析\r\n'
            '在进行部署之前，我们来简单分析一下「小相册」的具体代码。毕竟只看效果不是我们的目的，我们的目的是以「小相册」为例，了解如何开发小程序并与服务端进行交互。「小相册」包含一个描述整体程序的 '
            'app 和多个描述各自页面的 page。主程序 app 主要由三个文件组成，分别是\xa0'
            'app.js（小程序逻辑）、app.json（小程序公共设置）和\xa0'
            'app.wxss（小程序公共样式表），其中前两个为必备文件。config.js\xa0'
            '文件中包含了一些部署域名的设置，现在不用管。在 pages 目录下，有两个 page 页面，分别是 index 和 '
            'album。页面结构算是比较简单的，其中 index \r\n'
            '是小程序启动时默认进入的页面。每个页面下，至少要有 .js（页面逻辑）和 '
            '.wxml（页面结构）两个文件，.wxss（页面样式表）和 \r\n'
            '.json（页面配置）文件为选填。你可能注意到了，这些文件的文件名与父目录的名称相同。这是微信官方的规定，目的是减少配置项，方便开发者。接下来我们以 '
            'index 页面为例做简单的解释。index.wxml\xa0'
            '是这个页面的表现层文件，其中的代码非常简单，可以分为上下两大部分。<view>\r\n'
            '    <view class="page-top">\r\n'
            '        <text class="username">恭喜你</text>\r\n'
            '        <text class="text-info">成功地搭建了一个微信小程序</text>\r\n'
            '        <view class="page-btn-wrap">\r\n'
            '            <button class="page-btn" '
            'bindtap="gotoAlbum">进入相册</button>\r\n'
            '        </view>\r\n'
            '    </view>\r\n'
            '    <view class="page-bottom">\r\n'
            '        <text class="qr-txt">分享二维码邀请好友结伴一起写小程序！</text>\r\n'
            '        <image src="../../images/qr.png" '
            'class="qr-img"></image>\r\n'
            '        <image src="../../images/logo.png" '
            'class="page-logo"></image>\r\n'
            '    </view>\r\n'
            '</view>\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '\r\n'
            '页面的演示效果如下：\r\n'
            '\r\n'
            '我们看到，页面上有一个“进入相册”的按钮。正常理解，点击后该按钮后我们就可以进入相册了（这不废话嘛）。那小程序背后是怎样实现该操作的呢？\r\n'
            '在\xa0index.wxml\xa0中，我们发现对应的 button 标签上定义了一个\xa0bindtap\xa0'
            '属性，绑定了一个叫做\xa0gotoAlbum\xa0的方法。而这个方法可以在\xa0index.js\xa0'
            '文件中找到。事实上，文件中也只定义了这一个方法，执行的具体动作就是跳转到 album 页面。\r\n'
            'Page({\r\n'
            '    // 前往相册页\r\n'
            '    gotoAlbum() {\r\n'
            "        wx.navigateTo({ url: '../album/album' });\r\n"
            '    },\r\n'
            '});\r\n'
            'album.js\xa0页面中编写了程序的主要逻辑，包括选择或拍摄图片、图片预览、图片下载和图片删除；album.wxml '
            '中三种视图容器 view、scroll-view、swiper均有使用，还提供了消息提示框 '
            'toast。具体方法和视图的实现请查看项目源码。所有的这些功能都写在 Page 类中。\r\n'
            'lib 目录下提供了小程序会用的一些辅助函数，包括异步访问和对象存储 COS 的 API。\r\n'
            '总的来说，和微信官方宣传的一样，在开发者工具下进行小程序的开发，效率确实提高了很多，而且有很多微信提高的组件和 '
            'API。所以，在开发速度这点上的体验还是非常爽的。\r\n'
            '另外，由于「小相册」需要使用诸多云端能力，如图片的上传和下载，我们还需要进行服务器端的部署和设置。具体请看接下来的步骤。\r\n'
            '第三步：云端部署 server 代码\r\n'
            '虽然服务端的开发不是本文的重点，但是为了全面地体验「小相册」的整个开发部署流程，我们还是有必要了解服务端的部署，这里我们使用的是腾讯云。\r\n'
            '如果你想更爽一点，那么可以选择腾讯云官方提供的小程序云端镜像。「小相册」的服务器运行代码和配置已经打包成腾讯云 CVM '
            '镜像，可以直接使用。可谓是一键部署好云端。\r\n'
            '如果你以前没有使用过腾讯云，可以选择免费试用（我已经领取了 8 天的个人版服务器），或者领取礼包以优惠的价格购买所需的服务。\r\n'
            '\r\n'
            '你也可以选择将「小相册」源码中的server文件夹上传到自己的服务器。\r\n'
            '第四步：准备域名和配置证书\r\n'
            '如果你已经有腾讯云的服务器和域名，并配置好了 https，那么可以跳过第 4-6 步。\r\n'
            '在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求。简单来说，就是你的域名必须走 https '
            '协议。所以你还需要为你的域名申请一个证书。如果没有域名，请先注册一个。由于我们没有收到内测，也就暂时不用登录微信公众平台配置通信域名了。\r\n'
            '第五步：Nginx 配置 https\r\n'
            '微信小程序云端示例镜像中，已经部署好了 Nginx，但是还需要在\xa0/etc/nginx/conf.d\xa0'
            '下修改配置中的域名、证书、私钥。\r\n'
            '\r\n'
            '请将红框部分换成自己的域名和证书，并且将\xa0proxy_pass\xa0设置为 Node.js 监听的端口，我的是 '
            '9993。\r\n'
            '配置完成后，重新加载配置文件并且重启 Nginx。\r\n'
            'sudo service nginx reload\r\n'
            'sudo service nginx restart\r\n'
            '第六步：域名解析\r\n'
            '我们还需要添加域名记录，将域名解析到我们的云服务器上，这样才可以使用域名进行 https '
            '服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们的域名就支持 '
            'https 访问了。\r\n'
            '\r\n'
            '\r\n'
            '第七步：开通和配置 COS\r\n'
            '由于我们希望实现动静分离的架构，所以选择把「小相册」的图片资源是存储在 COS 上的。要使用 COS 服务，需要登录\xa0COS '
            '管理控制台，然后在其中完成以下操作。\r\n'
            '\r\n'
            '点击创建 Bucket。会要求选择所属项目，填写相应名称。这里，我们只需要填上自己喜欢的 Bucket 名称即可。\r\n'
            '然后在 Bucket 列表中，点击刚刚创建的 Bucket。然后在新页面点击“获取API密钥”。\r\n'
            '弹出的页面中包括了我们所需要的三个信息：唯一的 APP ID，一对SecretID和SecretKey（用于调用 COS '
            'API）。保管好这些信息，我们在稍后会用到。最后，在新的 Bucket '
            '容器中创建文件夹，命名为photos。这点后面我们也会提到。\r\n'
            '第八步：启动「小相册」的服务端\r\n'
            '在官方提供的镜像中，小相册示例的 Node 服务代码已部署在目录\xa0'
            '/data/release/qcloud-applet-album\xa0'
            '下。进入该目录，如果是你自己的服务器，请进入相应的文件夹。\r\n'
            'cd /data/release/qcloud-applet-album\r\n'
            '在该目录下，有一个名为\xa0config.js\xa0的配置文件（如下所示），按注释修改对应的 COS 配置：\r\n'
            'module.exports = {\r\n'
            '    // Node 监听的端口号\r\n'
            "    port: '9993',\r\n"
            "    ROUTE_BASE_PATH: '/applet',\r\n"
            '\r\n'
            "    cosAppId: '填写开通 COS 时分配的 APP ID',\r\n"
            "    cosSecretId: '填写密钥 SecretID',\r\n"
            "    cosSecretKey: '填写密钥 SecretKey',\r\n"
            "    cosFileBucket: '填写创建的公有读私有写的bucket名称',\r\n"
            '};\r\n'
            '另外，cd ./routes/album/handlers，修改\xa0list.js，将\xa0const '
            'listPath\xa0的值修改为你的Bucket 下的图片存储路径。如果是根目录，则修改为\xa0'
            "'/'。当前服务端的代码中将该值设置为了\xa0'/photos'\xa0，如果你在第七步中没有创建该目录，则无法调试成功。\r\n"
            '小相册示例使用 pm2 管理 Node 进程，执行以下命令启动 node 服务：\r\n'
            'pm2\xa0start\xa0process.json\r\n'
            '第九步：配置「小相册」通信域名\r\n'
            '接下来，在微信 web 开发者工具打开「小相册」项目，并把源文件config.js中的通讯域名 host '
            '修改成你自己申请的域名。\r\n'
            '\r\n'
            '将蓝色框内的内容修改为自己的域名\r\n'
            '然后点击调试，即可打开小相册Demo开始体验。\r\n'
            '\r\n'
            '\r\n'
            '最后提示一点，截止目前为止，微信小程序提供的上传和下载 API '
            '无法在调试工具中正常工作，需要用手机微信扫码预览体验。但是由于没有内测资格，我们暂时是没办法体验了。\r\n'
            '嗯，就这点不够爽，没有内测邀请。',
 'pub_time': '2016-10-13 18:37',
 'title': '微信小程序的快速搭建 '}
2019-07-25 14:25:03 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-230-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:03 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-236-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:03 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-230-1.html>
{'author': '天下雪',
 'content': '目录微信小程序是什么？微信小程序与公众号有什么区别？微信小程序的语法？项目结构页面管理基础组件丰富的API项目运行过程开发者工具（IDE）DEMO目前遇到的问题微信小程序是什么？微信小程序是一种不需要下载安装即可使用的应用，它实现了应用「触手可及」的梦想，用户扫一扫或搜一下即可打开应用。目前是内测阶段，而且采用的是邀请制的方式，据说只有200个。https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1477656487237微信小程序与公众号有什么区别？在没有网络连接的情况下，微信公众号的功能无法使用，但微信小程序而言，只要小程序本身无需联网的工作，它能够在离线的情况下发挥作用。服务号与在微信中加载一般网页相比，小程序的加载十分快捷，会给用户一种使用流畅的感觉。而公众号里无论是访问图文消息，还是打开第三方开发的网页，相比起小程序而言，都会慢许多。微信为小程序提供了更强的绘图能力、丰富的界面控件和更全的操作反馈，这一切使得微信小程序会拥有更好的显示效果和交互能力。小程序不会和公众号一同挤在会话列表中，除了通过一个会话可以直接打开小程序，也能到小程序自己的存放列表搜索和打开小程序。预计小程序的列表入口会放在 '
            '"发现“ \\ “游戏” '
            '的下面。微信小程序提供了更强的网络连接能力，小程序能够更加自由的连接网络，也能更加安全的使用网络。能够便捷地访问智能设备链接，未来在微信中就能直接使用和操作其他智能硬件。微信小程序提供了成熟的媒体组件， '
            '微信小程序的开发者可以更容易地开发视频/音频等多媒体应用，用户使用起来也会更加的流畅。微信小程序不能够向用户推送图文，只能发送模板消息，从而不会无事打扰用户，也失去了通过图文消息激活用户和提高用户粘度的能力。微信小程序的语法？微信提供了丰富的框架组建和API接口供开发者调用，具体包含：界面、视图、内容、按钮、导航、多媒体、位置、数据等等。这些组件和接口能让建立在微信上的小程序在运行能力和流畅度上保持和Native '
            'APP一样的体验.项目结构最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。\xa0'
            'app.js\xa0小程序运行主要逻辑及入口，里面使用App()函数来注册一个小程序，普通页面的js文件中可以通过 '
            'getApp()函数拿到App()函数所拥有的参数，并调用其中的数据。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 '
            'API，如本例的同步存储及同步读取本地数据。小程序里面的JS文件都是模块化的，模块只有通过 module.exports 或者 '
            'exports 才能对外暴露接口。App({\r\n'
            '  onLaunch: function() {\r\n'
            '    //当小程序初始化完成时，会触发 onLaunch（全局只触发一次）\r\n'
            '  },\r\n'
            '  onShow: function() {\r\n'
            '   //当小程序启动，或从后台进入前台显示，会触发 onShow\r\n'
            '  },\r\n'
            '  onHide: function() {\r\n'
            '   //当小程序从前台进入后台，会触发 onHide\r\n'
            '  },\r\n'
            "  globalData: 'I am global data'\r\n"
            '})\r\n'
            'app.json\xa0'
            '是小程序的全局配置文件。可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口?背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。{\r\n'
            '  "pages": [\r\n'
            '    "pages/index/index",\r\n'
            '    "pages/logs/index"\r\n'
            '  ],\r\n'
            '  "window": {\r\n'
            '    "navigationBarTitleText": "Demo"\r\n'
            '  },\r\n'
            '  "tabBar": {\r\n'
            '    "list": [{\r\n'
            '      "pagePath": "pages/index/index",\r\n'
            '      "text": "首页"\r\n'
            '    }, {\r\n'
            '      "pagePath": "pages/logs/logs",\r\n'
            '      "text": "日志"\r\n'
            '    }]\r\n'
            '  },\r\n'
            '  "networkTimeout": {\r\n'
            '    "request": 10000,\r\n'
            '    "downloadFile": 10000\r\n'
            '  }\r\n'
            '}\r\n'
            'app.wxss\xa0是一个公共的样式文件，整个项目的每个页面都可以调用，我们可以在页面组件的 class 属性上直接使用 '
            'app.wxss '
            '中声明的样式规则，就如一个全局的css文件。小程序引入了一个rpx的尺寸单位（会内部转成rem），也可以用普通的单位，如px、em、rem、百分比等；/**app.wxss**/\r\n'
            '.container {\r\n'
            '  height: 100%;\r\n'
            '  display: flex;\r\n'
            '  flex-direction: column;\r\n'
            '  align-items: center;\r\n'
            '  justify-content: space-between;\r\n'
            '  padding: 200rpx 0;\r\n'
            '  box-sizing: border-box;\r\n'
            '  padding: 10rpx;\r\n'
            '} \r\n'
            '页面管理框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。框架采用的是双向数据绑定MVVM的模式。每个页面由4个文件组成，分别是页面逻辑文件JS、页面结构文件WXML、页面样式文件WXSS和页面配置文件JSON（这里的配置会覆盖全局的配置，即app.json）。微信小程序会读取这些文件，并生成小程序实例。小程序拥有全局的\xa0'
            'App\xa0和\xa0Page\xa0方法，用于进行程序和页面的注册，并且其中定义的方法可以被相互调用。Page({\r\n'
            '  data: {\r\n'
            '    text: "This is page data."\r\n'
            '  },\r\n'
            '  onLoad: function(options) {\r\n'
            '    // Do some initialize when page load.\r\n'
            '  },\r\n'
            '  onReady: function() {\r\n'
            '    // Do something when page ready.\r\n'
            '  },\r\n'
            '  onShow: function() {\r\n'
            '    // Do something when page show.\r\n'
            '  },\r\n'
            '  onHide: function() {\r\n'
            '    // Do something when page hide.\r\n'
            '  },\r\n'
            '  onUnload: function() {\r\n'
            '    // Do something when page close.\r\n'
            '  },\r\n'
            '  // Event handler.\r\n'
            '  viewTap: function() {\r\n'
            '    this.setData({\r\n'
            "      text: 'Set some data for updating view.'\r\n"
            '    })\r\n'
            '  }\r\n'
            '});\r\n'
            'WXML<!--index.wxml-->\r\n'
            '<view class="container">\r\n'
            '  <view  bindtap="bindViewTap" class="userinfo">\r\n'
            '    <image class="userinfo-avatar" src="{{userInfo.avatarUrl}}" '
            'background-size="cover"></image>\r\n'
            '    <text '
            'class="userinfo-nickname">{{userInfo.nickName}}</text>\r\n'
            '  </view>\r\n'
            '  <view class="usermotto">\r\n'
            '    <text class="user-motto">{{motto}}</text>\r\n'
            '  </view>\r\n'
            '</view>\r\n'
            '基础组件框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的微信小程序。具体基础组件有view、image、text、input、audio、canvas等等，每个组件都有非常丰富的属性及事件绑定； '
            '<video id="myVideo" src="{{src}}" '
            'binderror="videoErrorCallback" \r\n'
            ' bindplay="bindplayCallback" autoplay controls></video>\r\n'
            '丰富的API提供了丰富的微信原生API，可以方便的调起微信提供的能力，如请求接口、登录，本地存储，上传下载等；wx.request({\r\n'
            "  url: 'test.php', //仅为示例，并非真实的接口地址\r\n"
            '  data: {\r\n'
            "     x: '' ,\r\n"
            "     y: ''\r\n"
            '  },\r\n'
            '  header: {\r\n'
            "      'Content-Type': 'application/json'\r\n"
            '  },\r\n'
            '  success: function(res) {\r\n'
            '    console.log(res.data)\r\n'
            '  }\r\n'
            '})\r\n'
            '项目运行过程：第一步:加载项目根目录下的 app.js、 app.json、 '
            'app.wxss文件，同时会执行app.js文件，并触发其中的onLaunch 和 onShow '
            '函数;第二步:加载app.json中pages数组中配置的第一个页面，作为项目的欢迎页，同时会执行对应页面js文件，并触发 '
            'onLoad / onReady 和 onShow 函数;往后:页面可以通过事件与js文件交互，比如 '
            '在标签元素上绑定点击事件，并且指向js文件中的一个函数，就能用js中的逻辑去处理这个事件了开发者工具（IDE）为了帮助开发者简单和高效地开发微信小程序，我们推出了全新的开发者工具，集成了开发调试、代码编辑及程序发布等功能。IDE采用的是node-webkit加react编辑功能开发者可以在这里编写代码，并且有适当的代码提示功能。（建议开发者用专业的IDE开发代码，然后可以利用此工具预览代码）；调试功能这里可以预览开发的小程序，并且提供了丰富的调试工具，分为 '
            '6 '
            '大功能模块：Wxml、Console、Sources、Network、Appdata、Storage；在IDE上面一栏可以选择手机模式和网络模式，用于模拟各种终端及网络环境下的小程序运行情况；项目功能在这一栏可以设置小程序项目的本地路径，可以上传小程序，生成预览的二维码和一些可选项等等；注：上传及预览需要appid;下载地址https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1477656486010demo由于目前没有appid，只能在IDE中预览小程序目前遇到的问题由于目前还只是内测阶段beta版本，很多功能及bug也正在fix中，微信团队基本按照 '
            '2 周一次的节奏发布版本更新;小程序技术规范刚刚起步，复杂的需求还缺乏实施方式；由于小程序不是基于webview，而是运行在JS '
            'core中，所以没有window和document对象等，而且是MVVM双向数据绑定的模式，无法进行DOM的操作，所有的数据操作必须基于组件上的事件绑定，利用setData方式改变初始状态，一些浏览器插件也无法使用（因为插件基本都基于window和doucument对象），所有开发模式上要有一定的改变;图片没法根据宽度自适应高度，必须写死高度的值，这给开发造成一定的困扰，特别是宽度为百分比的时候；微信提供了调用接口的方法，但是必须是https协议;一些功能必须依赖于appid，比如登录，socket，支付等等；开发动画的时候，初始样式必须写style属性，写CSS没用；etc...',
 'pub_time': '2016-11-1 23:23',
 'title': '徐德明：微信小程序浅析 '}
2019-07-25 14:25:03 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-236-1.html>
{'author': '天下雪',
 'content': '一、微信小程序运行环境\xa0 \xa0 1、完全封闭的环境不等于浏览器环境\xa0 \xa0 '
            '2、WXML/WXSS/JS格式\xa0 \xa0 3、WXML 不等于 HTML\xa0 \xa0 4、WXSS 不等于 '
            'CSS3\xa0 \xa0 '
            '5、JS：支持ES6，ES5，不支持DOM(window,document,event,etc...)\xa0 \xa0 '
            '6、不支持WEBGL,包含部分Canvas API\xa0 \xa0 '
            '7、封闭的发布渠道：程序需通过官方IDE提交审核\xa0 \xa0 '
            '8、腾讯完全控制客户端底层的内部实现二、微信小程序Canvas游戏限制分析\xa0 \xa0 1、不支持Affine '
            'Transform 矩阵设置\xa0 \xa0 2、不支持globalAlpha（忘记淡入淡出）\xa0 \xa0 '
            '3、不支持贴图变色（无法创建缓存Canvas对象）\xa0 \xa0 4、不支持图集（无法创建Image对象）\xa0 \xa0 '
            '5、不支持BMFont字体\xa0 \xa0 6、不支持剪裁（忘记ScrollView)\xa0 \xa0 '
            '7、不支持WebGL，所以不支持任何高级特效\xa0 \xa0 '
            '8、严格的模块化，不支持全局变量注入，只支持global下注入\xa0 \xa0 9、不支持项目内文件加载\xa0 \xa0 '
            '10、不支持多点触摸\xa0 \xa0 11、不支持文字排版：换行，居中等\xa0 \xa0 '
            '12、不支持九宫格、重复填充、网格等渲染模式\xa0 \xa0 13、不支持skew\xa0 \xa0 '
            '14、不支持混合模式\xa0 '
            '*15、支持Creator组件：Label，Sprite,Button,Widget,Layout,Animation,其他都不支持',
 'pub_time': '2016-11-2 10:12',
 'title': 'websunny：微信小程序那点事：特性总结 '}
2019-07-25 14:25:03 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-235-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:03 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-231-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:03 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-238-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:03 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://www.wxapp-union.com/article-239-1.html> (referer: http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=224)
2019-07-25 14:25:03 [scrapy.core.scraper] DEBUG: Scraped from <200 http://www.wxapp-union.com/article-235-1.html>
{'author': None, 'content': '', 'pub_time': None, 'title': None}
